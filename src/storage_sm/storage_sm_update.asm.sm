Update:

    LOAD FREE ${GetRKey()} -> RKEY;

    // OldRoot = LeafNodeHash = Hash( 1 | 0 | 0 | 0, Hash( Key, Hash( OldValue[0-3], OldValue[4-7] ) ) )
    LOAD FREE ${GetOldValueLow()} -> VALUE_LOW;
    LOAD VALUE_LOW -> HASH_LEFT;
    LOAD FREE ${GetOldValueHigh()} -> VALUE_HIGH;
    LOAD VALUE_HIGH -> HASH_RIGHT;
    HASH -> HASH_RIGHT;
    LOAD RKEY -> HASH_LEFT;
    HASH -> HASH_RIGHT;
    LOAD FREE ${GetConstant(1,0,0,0)} -> HASH_LEFT;
    HASH -> OLD_ROOT;

    // NewRoot = LeafNodeHash = Hash( 1 | 0 | 0 | 0, Hash( Key, Hash( NewValue[0-3], NewValue[4-7] ) ) )
    LOAD FREE ${GetValueLow()} -> VALUE_LOW;
    LOAD VALUE_LOW -> HASH_LEFT;
    LOAD FREE ${GetValueHigh()} -> VALUE_HIGH;
    LOAD VALUE_HIGH -> HASH_RIGHT;
    HASH -> HASH_RIGHT;
    LOAD RKEY -> HASH_LEFT;
    HASH -> HASH_RIGHT;
    LOAD FREE ${GetConstant(1,0,0,0)} -> HASH_LEFT;
    HASH -> NEW_ROOT;

    // Init LEVEL, and rotate as per key level
    LOAD FREE ${GetConstant(1,0,0,0)} -> LEVEL;
    JMPZ FREE ${GetLevelBit(0)} -> Update_LevelBit1; // If level bit 0 is zero, then skip the next 1 rotation
    ROTATE_LEVEL;

Update_LevelBit1:

    JMPZ FREE ${GetLevelBit(1)} -> Update_ClimbTree; // If level bit 1 is zero, then skip the next 2 rotations
    ROTATE_LEVEL;
    ROTATE_LEVEL;

Update_ClimbTree:
    JMPZ FREE -> Update_Latch; // If (we are at the top of the tree) goto Update_Latch

    LOAD FREE ${GetNextKeyBit()} -> RKEY_BIT;
    JMPZ RKEY_BIT -> Update_SiblingIsRight2; // If next key bit is zero, then sibling is right (sibling's next key bit is 1)

Update_SiblingIsLeft2:

    // NewRoot = Hash ( SiblingHash, NewRoot )
    LOAD NEW_ROOT -> HASH_RIGHT;
    LOAD FREE ${GetSiblingHash()} -> HASH_LEFT;
    HASH -> NEW_ROOT;

    // OldRoot = Hash ( SiblingHash, OldRoot )
    LOAD OLD_ROOT -> HASH_RIGHT;
    HASH -> OLD_ROOT;

    // Update remaining key
    CLIMB_RKEY;
    ROTATE_LEVEL;

    goto Update_ClimbTree;

Update_SiblingIsRight2:

    // NewRoot = Hash ( NewRoot, SiblingHash )
    LOAD NEW_ROOT -> HASH_LEFT;
    LOAD FREE ${GetSiblingHash()} -> HASH_RIGHT;
    HASH -> NEW_ROOT

    // OldRoot = Hash ( OldRoot, SiblingHash )
    LOAD OLD_ROOT -> HASH_LEFT;
    HASH -> OLD_ROOT;

    // Update remaining key
    CLIMB_RKEY;
    ROTATE_LEVEL;

    goto Update_ClimbTree;


Update_Latch:
    LATCH;   // At this point consistency is granted: OLD_ROOT, NEW_ROOT, RKEY (complete key), VALUE_LOW, VALUE_HIGH, LEVEL