// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zk-prover.proto

#include "zk-prover.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace zkprover {
constexpr NoParams::NoParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct NoParamsDefaultTypeInternal {
  constexpr NoParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NoParamsDefaultTypeInternal() {}
  union {
    NoParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NoParamsDefaultTypeInternal _NoParams_default_instance_;
constexpr State::State(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : proof_(nullptr)
  , status_(0)
{}
struct StateDefaultTypeInternal {
  constexpr StateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StateDefaultTypeInternal() {}
  union {
    State _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StateDefaultTypeInternal _State_default_instance_;
constexpr ProofX::ProofX(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : proof_(){}
struct ProofXDefaultTypeInternal {
  constexpr ProofXDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ProofXDefaultTypeInternal() {}
  union {
    ProofX _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ProofXDefaultTypeInternal _ProofX_default_instance_;
constexpr PublicInputs::PublicInputs(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : oldstateroot_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , oldlocalexitroot_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , newstateroot_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , newlocalexitroot_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sequenceraddr_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , batchhashdata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , chainid_(0u)
  , batchnum_(0u){}
struct PublicInputsDefaultTypeInternal {
  constexpr PublicInputsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PublicInputsDefaultTypeInternal() {}
  union {
    PublicInputs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PublicInputsDefaultTypeInternal _PublicInputs_default_instance_;
constexpr Proof::Proof(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : proofa_()
  , proofb_()
  , proofc_()
  , publicinputsextended_(nullptr){}
struct ProofDefaultTypeInternal {
  constexpr ProofDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ProofDefaultTypeInternal() {}
  union {
    Proof _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ProofDefaultTypeInternal _Proof_default_instance_;
constexpr InputProver_KeysEntry_DoNotUse::InputProver_KeysEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct InputProver_KeysEntry_DoNotUseDefaultTypeInternal {
  constexpr InputProver_KeysEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InputProver_KeysEntry_DoNotUseDefaultTypeInternal() {}
  union {
    InputProver_KeysEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InputProver_KeysEntry_DoNotUseDefaultTypeInternal _InputProver_KeysEntry_DoNotUse_default_instance_;
constexpr InputProver::InputProver(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : txs_()
  , keys_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , globalexitroot_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , publicinputs_(nullptr){}
struct InputProverDefaultTypeInternal {
  constexpr InputProverDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InputProverDefaultTypeInternal() {}
  union {
    InputProver _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InputProverDefaultTypeInternal _InputProver_default_instance_;
constexpr PublicInputsExtended::PublicInputsExtended(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : inputhash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , publicinputs_(nullptr){}
struct PublicInputsExtendedDefaultTypeInternal {
  constexpr PublicInputsExtendedDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PublicInputsExtendedDefaultTypeInternal() {}
  union {
    PublicInputsExtended _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PublicInputsExtendedDefaultTypeInternal _PublicInputsExtended_default_instance_;
}  // namespace zkprover
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_zk_2dprover_2eproto[8];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_zk_2dprover_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_zk_2dprover_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_zk_2dprover_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zkprover::NoParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zkprover::State, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zkprover::State, status_),
  PROTOBUF_FIELD_OFFSET(::zkprover::State, proof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zkprover::ProofX, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zkprover::ProofX, proof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputs, oldstateroot_),
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputs, oldlocalexitroot_),
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputs, newstateroot_),
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputs, newlocalexitroot_),
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputs, sequenceraddr_),
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputs, batchhashdata_),
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputs, chainid_),
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputs, batchnum_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zkprover::Proof, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zkprover::Proof, proofa_),
  PROTOBUF_FIELD_OFFSET(::zkprover::Proof, proofb_),
  PROTOBUF_FIELD_OFFSET(::zkprover::Proof, proofc_),
  PROTOBUF_FIELD_OFFSET(::zkprover::Proof, publicinputsextended_),
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver_KeysEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver_KeysEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver_KeysEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver_KeysEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver, message_),
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver, publicinputs_),
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver, globalexitroot_),
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver, txs_),
  PROTOBUF_FIELD_OFFSET(::zkprover::InputProver, keys_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputsExtended, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputsExtended, publicinputs_),
  PROTOBUF_FIELD_OFFSET(::zkprover::PublicInputsExtended, inputhash_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::zkprover::NoParams)},
  { 6, -1, -1, sizeof(::zkprover::State)},
  { 14, -1, -1, sizeof(::zkprover::ProofX)},
  { 21, -1, -1, sizeof(::zkprover::PublicInputs)},
  { 35, -1, -1, sizeof(::zkprover::Proof)},
  { 45, 53, -1, sizeof(::zkprover::InputProver_KeysEntry_DoNotUse)},
  { 55, -1, -1, sizeof(::zkprover::InputProver)},
  { 66, -1, -1, sizeof(::zkprover::PublicInputsExtended)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zkprover::_NoParams_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zkprover::_State_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zkprover::_ProofX_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zkprover::_PublicInputs_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zkprover::_Proof_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zkprover::_InputProver_KeysEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zkprover::_InputProver_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zkprover::_PublicInputsExtended_default_instance_),
};

const char descriptor_table_protodef_zk_2dprover_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017zk-prover.proto\022\010zkprover\"\n\n\010NoParams\""
  "\211\001\n\005State\022&\n\006status\030\001 \001(\0162\026.zkprover.Sta"
  "te.Status\022\036\n\005proof\030\002 \001(\0132\017.zkprover.Proo"
  "f\"8\n\006Status\022\010\n\004IDLE\020\000\022\t\n\005ERROR\020\001\022\013\n\007PEND"
  "ING\020\002\022\014\n\010FINISHED\020\003\"\027\n\006ProofX\022\r\n\005proof\030\001"
  " \003(\t\"\277\001\n\014PublicInputs\022\024\n\014oldStateRoot\030\001 "
  "\001(\t\022\030\n\020oldLocalExitRoot\030\002 \001(\t\022\024\n\014newStat"
  "eRoot\030\003 \001(\t\022\030\n\020newLocalExitRoot\030\004 \001(\t\022\025\n"
  "\rsequencerAddr\030\005 \001(\t\022\025\n\rbatchHashData\030\006 "
  "\001(\t\022\017\n\007chainId\030\007 \001(\r\022\020\n\010batchNum\030\010 \001(\r\"\207"
  "\001\n\005Proof\022\016\n\006proofA\030\001 \003(\t\022 \n\006proofB\030\002 \003(\013"
  "2\020.zkprover.ProofX\022\016\n\006proofC\030\003 \003(\t\022<\n\024pu"
  "blicInputsExtended\030\004 \001(\0132\036.zkprover.Publ"
  "icInputsExtended\"\315\001\n\013InputProver\022\017\n\007mess"
  "age\030\001 \001(\t\022,\n\014publicInputs\030\002 \001(\0132\026.zkprov"
  "er.PublicInputs\022\026\n\016globalExitRoot\030\003 \001(\t\022"
  "\013\n\003txs\030\004 \003(\t\022-\n\004keys\030\005 \003(\0132\037.zkprover.In"
  "putProver.KeysEntry\032+\n\tKeysEntry\022\013\n\003key\030"
  "\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"W\n\024PublicInputs"
  "Extended\022,\n\014publicInputs\030\002 \001(\0132\026.zkprove"
  "r.PublicInputs\022\021\n\tinputHash\030\005 \001(\t2\334\001\n\010ZK"
  "Prover\0222\n\tGetStatus\022\022.zkprover.NoParams\032"
  "\017.zkprover.State\"\000\0228\n\010GenProof\022\025.zkprove"
  "r.InputProver\032\017.zkprover.Proof\"\000(\0010\001\022/\n\006"
  "Cancel\022\022.zkprover.NoParams\032\017.zkprover.St"
  "ate\"\000\0221\n\010GetProof\022\022.zkprover.NoParams\032\017."
  "zkprover.Proof\"\000b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_zk_2dprover_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zk_2dprover_2eproto = {
  false, false, 1064, descriptor_table_protodef_zk_2dprover_2eproto, "zk-prover.proto", 
  &descriptor_table_zk_2dprover_2eproto_once, nullptr, 0, 8,
  schemas, file_default_instances, TableStruct_zk_2dprover_2eproto::offsets,
  file_level_metadata_zk_2dprover_2eproto, file_level_enum_descriptors_zk_2dprover_2eproto, file_level_service_descriptors_zk_2dprover_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_zk_2dprover_2eproto_getter() {
  return &descriptor_table_zk_2dprover_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_zk_2dprover_2eproto(&descriptor_table_zk_2dprover_2eproto);
namespace zkprover {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* State_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_zk_2dprover_2eproto);
  return file_level_enum_descriptors_zk_2dprover_2eproto[0];
}
bool State_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr State_Status State::IDLE;
constexpr State_Status State::ERROR;
constexpr State_Status State::PENDING;
constexpr State_Status State::FINISHED;
constexpr State_Status State::Status_MIN;
constexpr State_Status State::Status_MAX;
constexpr int State::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

class NoParams::_Internal {
 public:
};

NoParams::NoParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:zkprover.NoParams)
}
NoParams::NoParams(const NoParams& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zkprover.NoParams)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoParams::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata NoParams::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zk_2dprover_2eproto_getter, &descriptor_table_zk_2dprover_2eproto_once,
      file_level_metadata_zk_2dprover_2eproto[0]);
}

// ===================================================================

class State::_Internal {
 public:
  static const ::zkprover::Proof& proof(const State* msg);
};

const ::zkprover::Proof&
State::_Internal::proof(const State* msg) {
  return *msg->proof_;
}
State::State(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:zkprover.State)
}
State::State(const State& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_proof()) {
    proof_ = new ::zkprover::Proof(*from.proof_);
  } else {
    proof_ = nullptr;
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:zkprover.State)
}

void State::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&proof_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&proof_)) + sizeof(status_));
}

State::~State() {
  // @@protoc_insertion_point(destructor:zkprover.State)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void State::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete proof_;
}

void State::ArenaDtor(void* object) {
  State* _this = reinterpret_cast< State* >(object);
  (void)_this;
}
void State::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void State::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void State::Clear() {
// @@protoc_insertion_point(message_clear_start:zkprover.State)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && proof_ != nullptr) {
    delete proof_;
  }
  proof_ = nullptr;
  status_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* State::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zkprover.State.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::zkprover::State_Status>(val));
        } else
          goto handle_unusual;
        continue;
      // .zkprover.Proof proof = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_proof(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* State::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zkprover.State)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .zkprover.State.Status status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // .zkprover.Proof proof = 2;
  if (this->_internal_has_proof()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::proof(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zkprover.State)
  return target;
}

size_t State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zkprover.State)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .zkprover.Proof proof = 2;
  if (this->_internal_has_proof()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *proof_);
  }

  // .zkprover.State.Status status = 1;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData State::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    State::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*State::GetClassData() const { return &_class_data_; }

void State::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<State *>(to)->MergeFrom(
      static_cast<const State &>(from));
}


void State::MergeFrom(const State& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:zkprover.State)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_proof()) {
    _internal_mutable_proof()->::zkprover::Proof::MergeFrom(from._internal_proof());
  }
  if (from._internal_status() != 0) {
    _internal_set_status(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void State::CopyFrom(const State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zkprover.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  return true;
}

void State::InternalSwap(State* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(State, status_)
      + sizeof(State::status_)
      - PROTOBUF_FIELD_OFFSET(State, proof_)>(
          reinterpret_cast<char*>(&proof_),
          reinterpret_cast<char*>(&other->proof_));
}

::PROTOBUF_NAMESPACE_ID::Metadata State::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zk_2dprover_2eproto_getter, &descriptor_table_zk_2dprover_2eproto_once,
      file_level_metadata_zk_2dprover_2eproto[1]);
}

// ===================================================================

class ProofX::_Internal {
 public:
};

ProofX::ProofX(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  proof_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:zkprover.ProofX)
}
ProofX::ProofX(const ProofX& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      proof_(from.proof_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zkprover.ProofX)
}

void ProofX::SharedCtor() {
}

ProofX::~ProofX() {
  // @@protoc_insertion_point(destructor:zkprover.ProofX)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ProofX::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProofX::ArenaDtor(void* object) {
  ProofX* _this = reinterpret_cast< ProofX* >(object);
  (void)_this;
}
void ProofX::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ProofX::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ProofX::Clear() {
// @@protoc_insertion_point(message_clear_start:zkprover.ProofX)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  proof_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProofX::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string proof = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_proof();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.ProofX.proof"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ProofX::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zkprover.ProofX)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string proof = 1;
  for (int i = 0, n = this->_internal_proof_size(); i < n; i++) {
    const auto& s = this->_internal_proof(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.ProofX.proof");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zkprover.ProofX)
  return target;
}

size_t ProofX::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zkprover.ProofX)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string proof = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(proof_.size());
  for (int i = 0, n = proof_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      proof_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProofX::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ProofX::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProofX::GetClassData() const { return &_class_data_; }

void ProofX::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ProofX *>(to)->MergeFrom(
      static_cast<const ProofX &>(from));
}


void ProofX::MergeFrom(const ProofX& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:zkprover.ProofX)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  proof_.MergeFrom(from.proof_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProofX::CopyFrom(const ProofX& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zkprover.ProofX)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProofX::IsInitialized() const {
  return true;
}

void ProofX::InternalSwap(ProofX* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  proof_.InternalSwap(&other->proof_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProofX::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zk_2dprover_2eproto_getter, &descriptor_table_zk_2dprover_2eproto_once,
      file_level_metadata_zk_2dprover_2eproto[2]);
}

// ===================================================================

class PublicInputs::_Internal {
 public:
};

PublicInputs::PublicInputs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:zkprover.PublicInputs)
}
PublicInputs::PublicInputs(const PublicInputs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  oldstateroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_oldstateroot().empty()) {
    oldstateroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_oldstateroot(), 
      GetArenaForAllocation());
  }
  oldlocalexitroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_oldlocalexitroot().empty()) {
    oldlocalexitroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_oldlocalexitroot(), 
      GetArenaForAllocation());
  }
  newstateroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_newstateroot().empty()) {
    newstateroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_newstateroot(), 
      GetArenaForAllocation());
  }
  newlocalexitroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_newlocalexitroot().empty()) {
    newlocalexitroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_newlocalexitroot(), 
      GetArenaForAllocation());
  }
  sequenceraddr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_sequenceraddr().empty()) {
    sequenceraddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sequenceraddr(), 
      GetArenaForAllocation());
  }
  batchhashdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_batchhashdata().empty()) {
    batchhashdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_batchhashdata(), 
      GetArenaForAllocation());
  }
  ::memcpy(&chainid_, &from.chainid_,
    static_cast<size_t>(reinterpret_cast<char*>(&batchnum_) -
    reinterpret_cast<char*>(&chainid_)) + sizeof(batchnum_));
  // @@protoc_insertion_point(copy_constructor:zkprover.PublicInputs)
}

void PublicInputs::SharedCtor() {
oldstateroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
oldlocalexitroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
newstateroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
newlocalexitroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
sequenceraddr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
batchhashdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&chainid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&batchnum_) -
    reinterpret_cast<char*>(&chainid_)) + sizeof(batchnum_));
}

PublicInputs::~PublicInputs() {
  // @@protoc_insertion_point(destructor:zkprover.PublicInputs)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PublicInputs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  oldstateroot_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  oldlocalexitroot_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  newstateroot_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  newlocalexitroot_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sequenceraddr_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  batchhashdata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PublicInputs::ArenaDtor(void* object) {
  PublicInputs* _this = reinterpret_cast< PublicInputs* >(object);
  (void)_this;
}
void PublicInputs::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PublicInputs::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PublicInputs::Clear() {
// @@protoc_insertion_point(message_clear_start:zkprover.PublicInputs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  oldstateroot_.ClearToEmpty();
  oldlocalexitroot_.ClearToEmpty();
  newstateroot_.ClearToEmpty();
  newlocalexitroot_.ClearToEmpty();
  sequenceraddr_.ClearToEmpty();
  batchhashdata_.ClearToEmpty();
  ::memset(&chainid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&batchnum_) -
      reinterpret_cast<char*>(&chainid_)) + sizeof(batchnum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PublicInputs::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string oldStateRoot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_oldstateroot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.PublicInputs.oldStateRoot"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string oldLocalExitRoot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_oldlocalexitroot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.PublicInputs.oldLocalExitRoot"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string newStateRoot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_newstateroot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.PublicInputs.newStateRoot"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string newLocalExitRoot = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_newlocalexitroot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.PublicInputs.newLocalExitRoot"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string sequencerAddr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_sequenceraddr();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.PublicInputs.sequencerAddr"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string batchHashData = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_batchhashdata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.PublicInputs.batchHashData"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 chainId = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          chainid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 batchNum = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          batchnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PublicInputs::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zkprover.PublicInputs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string oldStateRoot = 1;
  if (!this->_internal_oldstateroot().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_oldstateroot().data(), static_cast<int>(this->_internal_oldstateroot().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.PublicInputs.oldStateRoot");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_oldstateroot(), target);
  }

  // string oldLocalExitRoot = 2;
  if (!this->_internal_oldlocalexitroot().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_oldlocalexitroot().data(), static_cast<int>(this->_internal_oldlocalexitroot().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.PublicInputs.oldLocalExitRoot");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_oldlocalexitroot(), target);
  }

  // string newStateRoot = 3;
  if (!this->_internal_newstateroot().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_newstateroot().data(), static_cast<int>(this->_internal_newstateroot().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.PublicInputs.newStateRoot");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_newstateroot(), target);
  }

  // string newLocalExitRoot = 4;
  if (!this->_internal_newlocalexitroot().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_newlocalexitroot().data(), static_cast<int>(this->_internal_newlocalexitroot().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.PublicInputs.newLocalExitRoot");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_newlocalexitroot(), target);
  }

  // string sequencerAddr = 5;
  if (!this->_internal_sequenceraddr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequenceraddr().data(), static_cast<int>(this->_internal_sequenceraddr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.PublicInputs.sequencerAddr");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_sequenceraddr(), target);
  }

  // string batchHashData = 6;
  if (!this->_internal_batchhashdata().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batchhashdata().data(), static_cast<int>(this->_internal_batchhashdata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.PublicInputs.batchHashData");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_batchhashdata(), target);
  }

  // uint32 chainId = 7;
  if (this->_internal_chainid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_chainid(), target);
  }

  // uint32 batchNum = 8;
  if (this->_internal_batchnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_batchnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zkprover.PublicInputs)
  return target;
}

size_t PublicInputs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zkprover.PublicInputs)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string oldStateRoot = 1;
  if (!this->_internal_oldstateroot().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_oldstateroot());
  }

  // string oldLocalExitRoot = 2;
  if (!this->_internal_oldlocalexitroot().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_oldlocalexitroot());
  }

  // string newStateRoot = 3;
  if (!this->_internal_newstateroot().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newstateroot());
  }

  // string newLocalExitRoot = 4;
  if (!this->_internal_newlocalexitroot().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newlocalexitroot());
  }

  // string sequencerAddr = 5;
  if (!this->_internal_sequenceraddr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequenceraddr());
  }

  // string batchHashData = 6;
  if (!this->_internal_batchhashdata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batchhashdata());
  }

  // uint32 chainId = 7;
  if (this->_internal_chainid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_chainid());
  }

  // uint32 batchNum = 8;
  if (this->_internal_batchnum() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_batchnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PublicInputs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PublicInputs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PublicInputs::GetClassData() const { return &_class_data_; }

void PublicInputs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PublicInputs *>(to)->MergeFrom(
      static_cast<const PublicInputs &>(from));
}


void PublicInputs::MergeFrom(const PublicInputs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:zkprover.PublicInputs)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_oldstateroot().empty()) {
    _internal_set_oldstateroot(from._internal_oldstateroot());
  }
  if (!from._internal_oldlocalexitroot().empty()) {
    _internal_set_oldlocalexitroot(from._internal_oldlocalexitroot());
  }
  if (!from._internal_newstateroot().empty()) {
    _internal_set_newstateroot(from._internal_newstateroot());
  }
  if (!from._internal_newlocalexitroot().empty()) {
    _internal_set_newlocalexitroot(from._internal_newlocalexitroot());
  }
  if (!from._internal_sequenceraddr().empty()) {
    _internal_set_sequenceraddr(from._internal_sequenceraddr());
  }
  if (!from._internal_batchhashdata().empty()) {
    _internal_set_batchhashdata(from._internal_batchhashdata());
  }
  if (from._internal_chainid() != 0) {
    _internal_set_chainid(from._internal_chainid());
  }
  if (from._internal_batchnum() != 0) {
    _internal_set_batchnum(from._internal_batchnum());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PublicInputs::CopyFrom(const PublicInputs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zkprover.PublicInputs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicInputs::IsInitialized() const {
  return true;
}

void PublicInputs::InternalSwap(PublicInputs* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &oldstateroot_, lhs_arena,
      &other->oldstateroot_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &oldlocalexitroot_, lhs_arena,
      &other->oldlocalexitroot_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &newstateroot_, lhs_arena,
      &other->newstateroot_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &newlocalexitroot_, lhs_arena,
      &other->newlocalexitroot_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sequenceraddr_, lhs_arena,
      &other->sequenceraddr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &batchhashdata_, lhs_arena,
      &other->batchhashdata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PublicInputs, batchnum_)
      + sizeof(PublicInputs::batchnum_)
      - PROTOBUF_FIELD_OFFSET(PublicInputs, chainid_)>(
          reinterpret_cast<char*>(&chainid_),
          reinterpret_cast<char*>(&other->chainid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PublicInputs::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zk_2dprover_2eproto_getter, &descriptor_table_zk_2dprover_2eproto_once,
      file_level_metadata_zk_2dprover_2eproto[3]);
}

// ===================================================================

class Proof::_Internal {
 public:
  static const ::zkprover::PublicInputsExtended& publicinputsextended(const Proof* msg);
};

const ::zkprover::PublicInputsExtended&
Proof::_Internal::publicinputsextended(const Proof* msg) {
  return *msg->publicinputsextended_;
}
Proof::Proof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  proofa_(arena),
  proofb_(arena),
  proofc_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:zkprover.Proof)
}
Proof::Proof(const Proof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      proofa_(from.proofa_),
      proofb_(from.proofb_),
      proofc_(from.proofc_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_publicinputsextended()) {
    publicinputsextended_ = new ::zkprover::PublicInputsExtended(*from.publicinputsextended_);
  } else {
    publicinputsextended_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:zkprover.Proof)
}

void Proof::SharedCtor() {
publicinputsextended_ = nullptr;
}

Proof::~Proof() {
  // @@protoc_insertion_point(destructor:zkprover.Proof)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Proof::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete publicinputsextended_;
}

void Proof::ArenaDtor(void* object) {
  Proof* _this = reinterpret_cast< Proof* >(object);
  (void)_this;
}
void Proof::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Proof::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Proof::Clear() {
// @@protoc_insertion_point(message_clear_start:zkprover.Proof)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  proofa_.Clear();
  proofb_.Clear();
  proofc_.Clear();
  if (GetArenaForAllocation() == nullptr && publicinputsextended_ != nullptr) {
    delete publicinputsextended_;
  }
  publicinputsextended_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proof::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string proofA = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_proofa();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.Proof.proofA"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zkprover.ProofX proofB = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_proofb(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string proofC = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_proofc();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.Proof.proofC"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .zkprover.PublicInputsExtended publicInputsExtended = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_publicinputsextended(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Proof::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zkprover.Proof)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string proofA = 1;
  for (int i = 0, n = this->_internal_proofa_size(); i < n; i++) {
    const auto& s = this->_internal_proofa(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.Proof.proofA");
    target = stream->WriteString(1, s, target);
  }

  // repeated .zkprover.ProofX proofB = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_proofb_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_proofb(i), target, stream);
  }

  // repeated string proofC = 3;
  for (int i = 0, n = this->_internal_proofc_size(); i < n; i++) {
    const auto& s = this->_internal_proofc(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.Proof.proofC");
    target = stream->WriteString(3, s, target);
  }

  // .zkprover.PublicInputsExtended publicInputsExtended = 4;
  if (this->_internal_has_publicinputsextended()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::publicinputsextended(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zkprover.Proof)
  return target;
}

size_t Proof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zkprover.Proof)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string proofA = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(proofa_.size());
  for (int i = 0, n = proofa_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      proofa_.Get(i));
  }

  // repeated .zkprover.ProofX proofB = 2;
  total_size += 1UL * this->_internal_proofb_size();
  for (const auto& msg : this->proofb_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string proofC = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(proofc_.size());
  for (int i = 0, n = proofc_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      proofc_.Get(i));
  }

  // .zkprover.PublicInputsExtended publicInputsExtended = 4;
  if (this->_internal_has_publicinputsextended()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *publicinputsextended_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Proof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proof::GetClassData() const { return &_class_data_; }

void Proof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Proof *>(to)->MergeFrom(
      static_cast<const Proof &>(from));
}


void Proof::MergeFrom(const Proof& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:zkprover.Proof)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  proofa_.MergeFrom(from.proofa_);
  proofb_.MergeFrom(from.proofb_);
  proofc_.MergeFrom(from.proofc_);
  if (from._internal_has_publicinputsextended()) {
    _internal_mutable_publicinputsextended()->::zkprover::PublicInputsExtended::MergeFrom(from._internal_publicinputsextended());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proof::CopyFrom(const Proof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zkprover.Proof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proof::IsInitialized() const {
  return true;
}

void Proof::InternalSwap(Proof* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  proofa_.InternalSwap(&other->proofa_);
  proofb_.InternalSwap(&other->proofb_);
  proofc_.InternalSwap(&other->proofc_);
  swap(publicinputsextended_, other->publicinputsextended_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Proof::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zk_2dprover_2eproto_getter, &descriptor_table_zk_2dprover_2eproto_once,
      file_level_metadata_zk_2dprover_2eproto[4]);
}

// ===================================================================

InputProver_KeysEntry_DoNotUse::InputProver_KeysEntry_DoNotUse() {}
InputProver_KeysEntry_DoNotUse::InputProver_KeysEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void InputProver_KeysEntry_DoNotUse::MergeFrom(const InputProver_KeysEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata InputProver_KeysEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zk_2dprover_2eproto_getter, &descriptor_table_zk_2dprover_2eproto_once,
      file_level_metadata_zk_2dprover_2eproto[5]);
}

// ===================================================================

class InputProver::_Internal {
 public:
  static const ::zkprover::PublicInputs& publicinputs(const InputProver* msg);
};

const ::zkprover::PublicInputs&
InputProver::_Internal::publicinputs(const InputProver* msg) {
  return *msg->publicinputs_;
}
InputProver::InputProver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  txs_(arena),
  keys_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:zkprover.InputProver)
}
InputProver::InputProver(const InputProver& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      txs_(from.txs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  keys_.MergeFrom(from.keys_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_message().empty()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  globalexitroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_globalexitroot().empty()) {
    globalexitroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_globalexitroot(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_publicinputs()) {
    publicinputs_ = new ::zkprover::PublicInputs(*from.publicinputs_);
  } else {
    publicinputs_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:zkprover.InputProver)
}

void InputProver::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
globalexitroot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
publicinputs_ = nullptr;
}

InputProver::~InputProver() {
  // @@protoc_insertion_point(destructor:zkprover.InputProver)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void InputProver::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  globalexitroot_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete publicinputs_;
}

void InputProver::ArenaDtor(void* object) {
  InputProver* _this = reinterpret_cast< InputProver* >(object);
  (void)_this;
  _this->keys_. ~MapField();
}
inline void InputProver::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &InputProver::ArenaDtor);
  }
}
void InputProver::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InputProver::Clear() {
// @@protoc_insertion_point(message_clear_start:zkprover.InputProver)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  txs_.Clear();
  keys_.Clear();
  message_.ClearToEmpty();
  globalexitroot_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && publicinputs_ != nullptr) {
    delete publicinputs_;
  }
  publicinputs_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InputProver::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.InputProver.message"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zkprover.PublicInputs publicInputs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_publicinputs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string globalExitRoot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_globalexitroot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.InputProver.globalExitRoot"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string txs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_txs();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.InputProver.txs"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> keys = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&keys_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* InputProver::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zkprover.InputProver)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.InputProver.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  // .zkprover.PublicInputs publicInputs = 2;
  if (this->_internal_has_publicinputs()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::publicinputs(this), target, stream);
  }

  // string globalExitRoot = 3;
  if (!this->_internal_globalexitroot().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_globalexitroot().data(), static_cast<int>(this->_internal_globalexitroot().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.InputProver.globalExitRoot");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_globalexitroot(), target);
  }

  // repeated string txs = 4;
  for (int i = 0, n = this->_internal_txs_size(); i < n; i++) {
    const auto& s = this->_internal_txs(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.InputProver.txs");
    target = stream->WriteString(4, s, target);
  }

  // map<string, string> keys = 5;
  if (!this->_internal_keys().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "zkprover.InputProver.KeysEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "zkprover.InputProver.KeysEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_keys().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_keys().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_keys().begin();
          it != this->_internal_keys().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = InputProver_KeysEntry_DoNotUse::Funcs::InternalSerialize(5, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_keys().begin();
          it != this->_internal_keys().end(); ++it) {
        target = InputProver_KeysEntry_DoNotUse::Funcs::InternalSerialize(5, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zkprover.InputProver)
  return target;
}

size_t InputProver::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zkprover.InputProver)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string txs = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(txs_.size());
  for (int i = 0, n = txs_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      txs_.Get(i));
  }

  // map<string, string> keys = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_keys_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_keys().begin();
      it != this->_internal_keys().end(); ++it) {
    total_size += InputProver_KeysEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  // string globalExitRoot = 3;
  if (!this->_internal_globalexitroot().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_globalexitroot());
  }

  // .zkprover.PublicInputs publicInputs = 2;
  if (this->_internal_has_publicinputs()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *publicinputs_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InputProver::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    InputProver::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InputProver::GetClassData() const { return &_class_data_; }

void InputProver::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<InputProver *>(to)->MergeFrom(
      static_cast<const InputProver &>(from));
}


void InputProver::MergeFrom(const InputProver& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:zkprover.InputProver)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  txs_.MergeFrom(from.txs_);
  keys_.MergeFrom(from.keys_);
  if (!from._internal_message().empty()) {
    _internal_set_message(from._internal_message());
  }
  if (!from._internal_globalexitroot().empty()) {
    _internal_set_globalexitroot(from._internal_globalexitroot());
  }
  if (from._internal_has_publicinputs()) {
    _internal_mutable_publicinputs()->::zkprover::PublicInputs::MergeFrom(from._internal_publicinputs());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InputProver::CopyFrom(const InputProver& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zkprover.InputProver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputProver::IsInitialized() const {
  return true;
}

void InputProver::InternalSwap(InputProver* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  txs_.InternalSwap(&other->txs_);
  keys_.InternalSwap(&other->keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &globalexitroot_, lhs_arena,
      &other->globalexitroot_, rhs_arena
  );
  swap(publicinputs_, other->publicinputs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InputProver::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zk_2dprover_2eproto_getter, &descriptor_table_zk_2dprover_2eproto_once,
      file_level_metadata_zk_2dprover_2eproto[6]);
}

// ===================================================================

class PublicInputsExtended::_Internal {
 public:
  static const ::zkprover::PublicInputs& publicinputs(const PublicInputsExtended* msg);
};

const ::zkprover::PublicInputs&
PublicInputsExtended::_Internal::publicinputs(const PublicInputsExtended* msg) {
  return *msg->publicinputs_;
}
PublicInputsExtended::PublicInputsExtended(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:zkprover.PublicInputsExtended)
}
PublicInputsExtended::PublicInputsExtended(const PublicInputsExtended& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  inputhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_inputhash().empty()) {
    inputhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_inputhash(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_publicinputs()) {
    publicinputs_ = new ::zkprover::PublicInputs(*from.publicinputs_);
  } else {
    publicinputs_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:zkprover.PublicInputsExtended)
}

void PublicInputsExtended::SharedCtor() {
inputhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
publicinputs_ = nullptr;
}

PublicInputsExtended::~PublicInputsExtended() {
  // @@protoc_insertion_point(destructor:zkprover.PublicInputsExtended)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PublicInputsExtended::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  inputhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete publicinputs_;
}

void PublicInputsExtended::ArenaDtor(void* object) {
  PublicInputsExtended* _this = reinterpret_cast< PublicInputsExtended* >(object);
  (void)_this;
}
void PublicInputsExtended::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PublicInputsExtended::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PublicInputsExtended::Clear() {
// @@protoc_insertion_point(message_clear_start:zkprover.PublicInputsExtended)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  inputhash_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && publicinputs_ != nullptr) {
    delete publicinputs_;
  }
  publicinputs_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PublicInputsExtended::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zkprover.PublicInputs publicInputs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_publicinputs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string inputHash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_inputhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "zkprover.PublicInputsExtended.inputHash"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PublicInputsExtended::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zkprover.PublicInputsExtended)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .zkprover.PublicInputs publicInputs = 2;
  if (this->_internal_has_publicinputs()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::publicinputs(this), target, stream);
  }

  // string inputHash = 5;
  if (!this->_internal_inputhash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_inputhash().data(), static_cast<int>(this->_internal_inputhash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zkprover.PublicInputsExtended.inputHash");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_inputhash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zkprover.PublicInputsExtended)
  return target;
}

size_t PublicInputsExtended::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zkprover.PublicInputsExtended)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string inputHash = 5;
  if (!this->_internal_inputhash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_inputhash());
  }

  // .zkprover.PublicInputs publicInputs = 2;
  if (this->_internal_has_publicinputs()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *publicinputs_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PublicInputsExtended::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PublicInputsExtended::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PublicInputsExtended::GetClassData() const { return &_class_data_; }

void PublicInputsExtended::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PublicInputsExtended *>(to)->MergeFrom(
      static_cast<const PublicInputsExtended &>(from));
}


void PublicInputsExtended::MergeFrom(const PublicInputsExtended& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:zkprover.PublicInputsExtended)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_inputhash().empty()) {
    _internal_set_inputhash(from._internal_inputhash());
  }
  if (from._internal_has_publicinputs()) {
    _internal_mutable_publicinputs()->::zkprover::PublicInputs::MergeFrom(from._internal_publicinputs());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PublicInputsExtended::CopyFrom(const PublicInputsExtended& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zkprover.PublicInputsExtended)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicInputsExtended::IsInitialized() const {
  return true;
}

void PublicInputsExtended::InternalSwap(PublicInputsExtended* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &inputhash_, lhs_arena,
      &other->inputhash_, rhs_arena
  );
  swap(publicinputs_, other->publicinputs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PublicInputsExtended::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zk_2dprover_2eproto_getter, &descriptor_table_zk_2dprover_2eproto_once,
      file_level_metadata_zk_2dprover_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace zkprover
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::zkprover::NoParams* Arena::CreateMaybeMessage< ::zkprover::NoParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zkprover::NoParams >(arena);
}
template<> PROTOBUF_NOINLINE ::zkprover::State* Arena::CreateMaybeMessage< ::zkprover::State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zkprover::State >(arena);
}
template<> PROTOBUF_NOINLINE ::zkprover::ProofX* Arena::CreateMaybeMessage< ::zkprover::ProofX >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zkprover::ProofX >(arena);
}
template<> PROTOBUF_NOINLINE ::zkprover::PublicInputs* Arena::CreateMaybeMessage< ::zkprover::PublicInputs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zkprover::PublicInputs >(arena);
}
template<> PROTOBUF_NOINLINE ::zkprover::Proof* Arena::CreateMaybeMessage< ::zkprover::Proof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zkprover::Proof >(arena);
}
template<> PROTOBUF_NOINLINE ::zkprover::InputProver_KeysEntry_DoNotUse* Arena::CreateMaybeMessage< ::zkprover::InputProver_KeysEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zkprover::InputProver_KeysEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::zkprover::InputProver* Arena::CreateMaybeMessage< ::zkprover::InputProver >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zkprover::InputProver >(arena);
}
template<> PROTOBUF_NOINLINE ::zkprover::PublicInputsExtended* Arena::CreateMaybeMessage< ::zkprover::PublicInputsExtended >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zkprover::PublicInputsExtended >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
