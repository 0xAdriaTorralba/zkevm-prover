// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zk-prover.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zk_2dprover_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zk_2dprover_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zk_2dprover_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zk_2dprover_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zk_2dprover_2eproto;
namespace zkprover {
class InputProver;
struct InputProverDefaultTypeInternal;
extern InputProverDefaultTypeInternal _InputProver_default_instance_;
class InputProver_KeysEntry_DoNotUse;
struct InputProver_KeysEntry_DoNotUseDefaultTypeInternal;
extern InputProver_KeysEntry_DoNotUseDefaultTypeInternal _InputProver_KeysEntry_DoNotUse_default_instance_;
class NoParams;
struct NoParamsDefaultTypeInternal;
extern NoParamsDefaultTypeInternal _NoParams_default_instance_;
class Proof;
struct ProofDefaultTypeInternal;
extern ProofDefaultTypeInternal _Proof_default_instance_;
class ProofX;
struct ProofXDefaultTypeInternal;
extern ProofXDefaultTypeInternal _ProofX_default_instance_;
class PublicInputs;
struct PublicInputsDefaultTypeInternal;
extern PublicInputsDefaultTypeInternal _PublicInputs_default_instance_;
class PublicInputsExtended;
struct PublicInputsExtendedDefaultTypeInternal;
extern PublicInputsExtendedDefaultTypeInternal _PublicInputsExtended_default_instance_;
class State;
struct StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
}  // namespace zkprover
PROTOBUF_NAMESPACE_OPEN
template<> ::zkprover::InputProver* Arena::CreateMaybeMessage<::zkprover::InputProver>(Arena*);
template<> ::zkprover::InputProver_KeysEntry_DoNotUse* Arena::CreateMaybeMessage<::zkprover::InputProver_KeysEntry_DoNotUse>(Arena*);
template<> ::zkprover::NoParams* Arena::CreateMaybeMessage<::zkprover::NoParams>(Arena*);
template<> ::zkprover::Proof* Arena::CreateMaybeMessage<::zkprover::Proof>(Arena*);
template<> ::zkprover::ProofX* Arena::CreateMaybeMessage<::zkprover::ProofX>(Arena*);
template<> ::zkprover::PublicInputs* Arena::CreateMaybeMessage<::zkprover::PublicInputs>(Arena*);
template<> ::zkprover::PublicInputsExtended* Arena::CreateMaybeMessage<::zkprover::PublicInputsExtended>(Arena*);
template<> ::zkprover::State* Arena::CreateMaybeMessage<::zkprover::State>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zkprover {

enum State_Status : int {
  State_Status_IDLE = 0,
  State_Status_ERROR = 1,
  State_Status_PENDING = 2,
  State_Status_FINISHED = 3,
  State_Status_State_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  State_Status_State_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool State_Status_IsValid(int value);
constexpr State_Status State_Status_Status_MIN = State_Status_IDLE;
constexpr State_Status State_Status_Status_MAX = State_Status_FINISHED;
constexpr int State_Status_Status_ARRAYSIZE = State_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* State_Status_descriptor();
template<typename T>
inline const std::string& State_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, State_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function State_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    State_Status_descriptor(), enum_t_value);
}
inline bool State_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, State_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<State_Status>(
    State_Status_descriptor(), name, value);
}
// ===================================================================

class NoParams final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zkprover.NoParams) */ {
 public:
  inline NoParams() : NoParams(nullptr) {}
  explicit constexpr NoParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoParams(const NoParams& from);
  NoParams(NoParams&& from) noexcept
    : NoParams() {
    *this = ::std::move(from);
  }

  inline NoParams& operator=(const NoParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoParams& operator=(NoParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoParams* internal_default_instance() {
    return reinterpret_cast<const NoParams*>(
               &_NoParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NoParams& a, NoParams& b) {
    a.Swap(&b);
  }
  inline void Swap(NoParams* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NoParams* New() const final {
    return new NoParams();
  }

  NoParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NoParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NoParams& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NoParams& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zkprover.NoParams";
  }
  protected:
  explicit NoParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zkprover.NoParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zk_2dprover_2eproto;
};
// -------------------------------------------------------------------

class State final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zkprover.State) */ {
 public:
  inline State() : State(nullptr) {}
  ~State() override;
  explicit constexpr State(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  State(const State& from);
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const State& default_instance() {
    return *internal_default_instance();
  }
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline State* New() const final {
    return new State();
  }

  State* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<State>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const State& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const State& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zkprover.State";
  }
  protected:
  explicit State(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef State_Status Status;
  static constexpr Status IDLE =
    State_Status_IDLE;
  static constexpr Status ERROR =
    State_Status_ERROR;
  static constexpr Status PENDING =
    State_Status_PENDING;
  static constexpr Status FINISHED =
    State_Status_FINISHED;
  static inline bool Status_IsValid(int value) {
    return State_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    State_Status_Status_MIN;
  static constexpr Status Status_MAX =
    State_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    State_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return State_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return State_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return State_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProofFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // .zkprover.Proof proof = 2;
  bool has_proof() const;
  private:
  bool _internal_has_proof() const;
  public:
  void clear_proof();
  const ::zkprover::Proof& proof() const;
  PROTOBUF_MUST_USE_RESULT ::zkprover::Proof* release_proof();
  ::zkprover::Proof* mutable_proof();
  void set_allocated_proof(::zkprover::Proof* proof);
  private:
  const ::zkprover::Proof& _internal_proof() const;
  ::zkprover::Proof* _internal_mutable_proof();
  public:
  void unsafe_arena_set_allocated_proof(
      ::zkprover::Proof* proof);
  ::zkprover::Proof* unsafe_arena_release_proof();

  // .zkprover.State.Status status = 1;
  void clear_status();
  ::zkprover::State_Status status() const;
  void set_status(::zkprover::State_Status value);
  private:
  ::zkprover::State_Status _internal_status() const;
  void _internal_set_status(::zkprover::State_Status value);
  public:

  // @@protoc_insertion_point(class_scope:zkprover.State)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zkprover::Proof* proof_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zk_2dprover_2eproto;
};
// -------------------------------------------------------------------

class ProofX final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zkprover.ProofX) */ {
 public:
  inline ProofX() : ProofX(nullptr) {}
  ~ProofX() override;
  explicit constexpr ProofX(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProofX(const ProofX& from);
  ProofX(ProofX&& from) noexcept
    : ProofX() {
    *this = ::std::move(from);
  }

  inline ProofX& operator=(const ProofX& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProofX& operator=(ProofX&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProofX& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProofX* internal_default_instance() {
    return reinterpret_cast<const ProofX*>(
               &_ProofX_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProofX& a, ProofX& b) {
    a.Swap(&b);
  }
  inline void Swap(ProofX* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProofX* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProofX* New() const final {
    return new ProofX();
  }

  ProofX* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProofX>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProofX& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProofX& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProofX* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zkprover.ProofX";
  }
  protected:
  explicit ProofX(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofFieldNumber = 1,
  };
  // repeated string proof = 1;
  int proof_size() const;
  private:
  int _internal_proof_size() const;
  public:
  void clear_proof();
  const std::string& proof(int index) const;
  std::string* mutable_proof(int index);
  void set_proof(int index, const std::string& value);
  void set_proof(int index, std::string&& value);
  void set_proof(int index, const char* value);
  void set_proof(int index, const char* value, size_t size);
  std::string* add_proof();
  void add_proof(const std::string& value);
  void add_proof(std::string&& value);
  void add_proof(const char* value);
  void add_proof(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proof() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proof();
  private:
  const std::string& _internal_proof(int index) const;
  std::string* _internal_add_proof();
  public:

  // @@protoc_insertion_point(class_scope:zkprover.ProofX)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zk_2dprover_2eproto;
};
// -------------------------------------------------------------------

class PublicInputs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zkprover.PublicInputs) */ {
 public:
  inline PublicInputs() : PublicInputs(nullptr) {}
  ~PublicInputs() override;
  explicit constexpr PublicInputs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicInputs(const PublicInputs& from);
  PublicInputs(PublicInputs&& from) noexcept
    : PublicInputs() {
    *this = ::std::move(from);
  }

  inline PublicInputs& operator=(const PublicInputs& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicInputs& operator=(PublicInputs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicInputs& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicInputs* internal_default_instance() {
    return reinterpret_cast<const PublicInputs*>(
               &_PublicInputs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PublicInputs& a, PublicInputs& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicInputs* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicInputs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PublicInputs* New() const final {
    return new PublicInputs();
  }

  PublicInputs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PublicInputs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublicInputs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PublicInputs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicInputs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zkprover.PublicInputs";
  }
  protected:
  explicit PublicInputs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldStateRootFieldNumber = 1,
    kOldLocalExitRootFieldNumber = 2,
    kNewStateRootFieldNumber = 3,
    kNewLocalExitRootFieldNumber = 4,
    kSequencerAddrFieldNumber = 5,
    kBatchHashDataFieldNumber = 6,
    kChainIdFieldNumber = 7,
    kBatchNumFieldNumber = 8,
  };
  // string oldStateRoot = 1;
  void clear_oldstateroot();
  const std::string& oldstateroot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oldstateroot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oldstateroot();
  PROTOBUF_MUST_USE_RESULT std::string* release_oldstateroot();
  void set_allocated_oldstateroot(std::string* oldstateroot);
  private:
  const std::string& _internal_oldstateroot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldstateroot(const std::string& value);
  std::string* _internal_mutable_oldstateroot();
  public:

  // string oldLocalExitRoot = 2;
  void clear_oldlocalexitroot();
  const std::string& oldlocalexitroot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oldlocalexitroot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oldlocalexitroot();
  PROTOBUF_MUST_USE_RESULT std::string* release_oldlocalexitroot();
  void set_allocated_oldlocalexitroot(std::string* oldlocalexitroot);
  private:
  const std::string& _internal_oldlocalexitroot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldlocalexitroot(const std::string& value);
  std::string* _internal_mutable_oldlocalexitroot();
  public:

  // string newStateRoot = 3;
  void clear_newstateroot();
  const std::string& newstateroot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newstateroot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newstateroot();
  PROTOBUF_MUST_USE_RESULT std::string* release_newstateroot();
  void set_allocated_newstateroot(std::string* newstateroot);
  private:
  const std::string& _internal_newstateroot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newstateroot(const std::string& value);
  std::string* _internal_mutable_newstateroot();
  public:

  // string newLocalExitRoot = 4;
  void clear_newlocalexitroot();
  const std::string& newlocalexitroot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newlocalexitroot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newlocalexitroot();
  PROTOBUF_MUST_USE_RESULT std::string* release_newlocalexitroot();
  void set_allocated_newlocalexitroot(std::string* newlocalexitroot);
  private:
  const std::string& _internal_newlocalexitroot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newlocalexitroot(const std::string& value);
  std::string* _internal_mutable_newlocalexitroot();
  public:

  // string sequencerAddr = 5;
  void clear_sequenceraddr();
  const std::string& sequenceraddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceraddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceraddr();
  PROTOBUF_MUST_USE_RESULT std::string* release_sequenceraddr();
  void set_allocated_sequenceraddr(std::string* sequenceraddr);
  private:
  const std::string& _internal_sequenceraddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceraddr(const std::string& value);
  std::string* _internal_mutable_sequenceraddr();
  public:

  // string batchHashData = 6;
  void clear_batchhashdata();
  const std::string& batchhashdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batchhashdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batchhashdata();
  PROTOBUF_MUST_USE_RESULT std::string* release_batchhashdata();
  void set_allocated_batchhashdata(std::string* batchhashdata);
  private:
  const std::string& _internal_batchhashdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batchhashdata(const std::string& value);
  std::string* _internal_mutable_batchhashdata();
  public:

  // uint32 chainId = 7;
  void clear_chainid();
  ::PROTOBUF_NAMESPACE_ID::uint32 chainid() const;
  void set_chainid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_chainid() const;
  void _internal_set_chainid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 batchNum = 8;
  void clear_batchnum();
  ::PROTOBUF_NAMESPACE_ID::uint32 batchnum() const;
  void set_batchnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_batchnum() const;
  void _internal_set_batchnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zkprover.PublicInputs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oldstateroot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oldlocalexitroot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newstateroot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newlocalexitroot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceraddr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batchhashdata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 chainid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 batchnum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zk_2dprover_2eproto;
};
// -------------------------------------------------------------------

class Proof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zkprover.Proof) */ {
 public:
  inline Proof() : Proof(nullptr) {}
  ~Proof() override;
  explicit constexpr Proof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proof(const Proof& from);
  Proof(Proof&& from) noexcept
    : Proof() {
    *this = ::std::move(from);
  }

  inline Proof& operator=(const Proof& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proof& operator=(Proof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proof& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proof* internal_default_instance() {
    return reinterpret_cast<const Proof*>(
               &_Proof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Proof& a, Proof& b) {
    a.Swap(&b);
  }
  inline void Swap(Proof* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Proof* New() const final {
    return new Proof();
  }

  Proof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Proof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Proof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zkprover.Proof";
  }
  protected:
  explicit Proof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofAFieldNumber = 1,
    kProofBFieldNumber = 2,
    kProofCFieldNumber = 3,
    kPublicInputsExtendedFieldNumber = 4,
  };
  // repeated string proofA = 1;
  int proofa_size() const;
  private:
  int _internal_proofa_size() const;
  public:
  void clear_proofa();
  const std::string& proofa(int index) const;
  std::string* mutable_proofa(int index);
  void set_proofa(int index, const std::string& value);
  void set_proofa(int index, std::string&& value);
  void set_proofa(int index, const char* value);
  void set_proofa(int index, const char* value, size_t size);
  std::string* add_proofa();
  void add_proofa(const std::string& value);
  void add_proofa(std::string&& value);
  void add_proofa(const char* value);
  void add_proofa(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proofa() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proofa();
  private:
  const std::string& _internal_proofa(int index) const;
  std::string* _internal_add_proofa();
  public:

  // repeated .zkprover.ProofX proofB = 2;
  int proofb_size() const;
  private:
  int _internal_proofb_size() const;
  public:
  void clear_proofb();
  ::zkprover::ProofX* mutable_proofb(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zkprover::ProofX >*
      mutable_proofb();
  private:
  const ::zkprover::ProofX& _internal_proofb(int index) const;
  ::zkprover::ProofX* _internal_add_proofb();
  public:
  const ::zkprover::ProofX& proofb(int index) const;
  ::zkprover::ProofX* add_proofb();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zkprover::ProofX >&
      proofb() const;

  // repeated string proofC = 3;
  int proofc_size() const;
  private:
  int _internal_proofc_size() const;
  public:
  void clear_proofc();
  const std::string& proofc(int index) const;
  std::string* mutable_proofc(int index);
  void set_proofc(int index, const std::string& value);
  void set_proofc(int index, std::string&& value);
  void set_proofc(int index, const char* value);
  void set_proofc(int index, const char* value, size_t size);
  std::string* add_proofc();
  void add_proofc(const std::string& value);
  void add_proofc(std::string&& value);
  void add_proofc(const char* value);
  void add_proofc(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proofc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proofc();
  private:
  const std::string& _internal_proofc(int index) const;
  std::string* _internal_add_proofc();
  public:

  // .zkprover.PublicInputsExtended publicInputsExtended = 4;
  bool has_publicinputsextended() const;
  private:
  bool _internal_has_publicinputsextended() const;
  public:
  void clear_publicinputsextended();
  const ::zkprover::PublicInputsExtended& publicinputsextended() const;
  PROTOBUF_MUST_USE_RESULT ::zkprover::PublicInputsExtended* release_publicinputsextended();
  ::zkprover::PublicInputsExtended* mutable_publicinputsextended();
  void set_allocated_publicinputsextended(::zkprover::PublicInputsExtended* publicinputsextended);
  private:
  const ::zkprover::PublicInputsExtended& _internal_publicinputsextended() const;
  ::zkprover::PublicInputsExtended* _internal_mutable_publicinputsextended();
  public:
  void unsafe_arena_set_allocated_publicinputsextended(
      ::zkprover::PublicInputsExtended* publicinputsextended);
  ::zkprover::PublicInputsExtended* unsafe_arena_release_publicinputsextended();

  // @@protoc_insertion_point(class_scope:zkprover.Proof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proofa_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zkprover::ProofX > proofb_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proofc_;
  ::zkprover::PublicInputsExtended* publicinputsextended_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zk_2dprover_2eproto;
};
// -------------------------------------------------------------------

class InputProver_KeysEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InputProver_KeysEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InputProver_KeysEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  InputProver_KeysEntry_DoNotUse();
  explicit constexpr InputProver_KeysEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InputProver_KeysEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InputProver_KeysEntry_DoNotUse& other);
  static const InputProver_KeysEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InputProver_KeysEntry_DoNotUse*>(&_InputProver_KeysEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zkprover.InputProver.KeysEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zkprover.InputProver.KeysEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class InputProver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zkprover.InputProver) */ {
 public:
  inline InputProver() : InputProver(nullptr) {}
  ~InputProver() override;
  explicit constexpr InputProver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputProver(const InputProver& from);
  InputProver(InputProver&& from) noexcept
    : InputProver() {
    *this = ::std::move(from);
  }

  inline InputProver& operator=(const InputProver& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputProver& operator=(InputProver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputProver& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputProver* internal_default_instance() {
    return reinterpret_cast<const InputProver*>(
               &_InputProver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InputProver& a, InputProver& b) {
    a.Swap(&b);
  }
  inline void Swap(InputProver* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputProver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputProver* New() const final {
    return new InputProver();
  }

  InputProver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputProver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputProver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InputProver& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputProver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zkprover.InputProver";
  }
  protected:
  explicit InputProver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTxsFieldNumber = 4,
    kKeysFieldNumber = 5,
    kMessageFieldNumber = 1,
    kGlobalExitRootFieldNumber = 3,
    kPublicInputsFieldNumber = 2,
  };
  // repeated string txs = 4;
  int txs_size() const;
  private:
  int _internal_txs_size() const;
  public:
  void clear_txs();
  const std::string& txs(int index) const;
  std::string* mutable_txs(int index);
  void set_txs(int index, const std::string& value);
  void set_txs(int index, std::string&& value);
  void set_txs(int index, const char* value);
  void set_txs(int index, const char* value, size_t size);
  std::string* add_txs();
  void add_txs(const std::string& value);
  void add_txs(std::string&& value);
  void add_txs(const char* value);
  void add_txs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txs();
  private:
  const std::string& _internal_txs(int index) const;
  std::string* _internal_add_txs();
  public:

  // map<string, string> keys = 5;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_keys() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_keys();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      keys() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_keys();

  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string globalExitRoot = 3;
  void clear_globalexitroot();
  const std::string& globalexitroot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_globalexitroot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_globalexitroot();
  PROTOBUF_MUST_USE_RESULT std::string* release_globalexitroot();
  void set_allocated_globalexitroot(std::string* globalexitroot);
  private:
  const std::string& _internal_globalexitroot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_globalexitroot(const std::string& value);
  std::string* _internal_mutable_globalexitroot();
  public:

  // .zkprover.PublicInputs publicInputs = 2;
  bool has_publicinputs() const;
  private:
  bool _internal_has_publicinputs() const;
  public:
  void clear_publicinputs();
  const ::zkprover::PublicInputs& publicinputs() const;
  PROTOBUF_MUST_USE_RESULT ::zkprover::PublicInputs* release_publicinputs();
  ::zkprover::PublicInputs* mutable_publicinputs();
  void set_allocated_publicinputs(::zkprover::PublicInputs* publicinputs);
  private:
  const ::zkprover::PublicInputs& _internal_publicinputs() const;
  ::zkprover::PublicInputs* _internal_mutable_publicinputs();
  public:
  void unsafe_arena_set_allocated_publicinputs(
      ::zkprover::PublicInputs* publicinputs);
  ::zkprover::PublicInputs* unsafe_arena_release_publicinputs();

  // @@protoc_insertion_point(class_scope:zkprover.InputProver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txs_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      InputProver_KeysEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr globalexitroot_;
  ::zkprover::PublicInputs* publicinputs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zk_2dprover_2eproto;
};
// -------------------------------------------------------------------

class PublicInputsExtended final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zkprover.PublicInputsExtended) */ {
 public:
  inline PublicInputsExtended() : PublicInputsExtended(nullptr) {}
  ~PublicInputsExtended() override;
  explicit constexpr PublicInputsExtended(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicInputsExtended(const PublicInputsExtended& from);
  PublicInputsExtended(PublicInputsExtended&& from) noexcept
    : PublicInputsExtended() {
    *this = ::std::move(from);
  }

  inline PublicInputsExtended& operator=(const PublicInputsExtended& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicInputsExtended& operator=(PublicInputsExtended&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicInputsExtended& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicInputsExtended* internal_default_instance() {
    return reinterpret_cast<const PublicInputsExtended*>(
               &_PublicInputsExtended_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PublicInputsExtended& a, PublicInputsExtended& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicInputsExtended* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicInputsExtended* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PublicInputsExtended* New() const final {
    return new PublicInputsExtended();
  }

  PublicInputsExtended* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PublicInputsExtended>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublicInputsExtended& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PublicInputsExtended& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicInputsExtended* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zkprover.PublicInputsExtended";
  }
  protected:
  explicit PublicInputsExtended(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputHashFieldNumber = 5,
    kPublicInputsFieldNumber = 2,
  };
  // string inputHash = 5;
  void clear_inputhash();
  const std::string& inputhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_inputhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_inputhash();
  PROTOBUF_MUST_USE_RESULT std::string* release_inputhash();
  void set_allocated_inputhash(std::string* inputhash);
  private:
  const std::string& _internal_inputhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inputhash(const std::string& value);
  std::string* _internal_mutable_inputhash();
  public:

  // .zkprover.PublicInputs publicInputs = 2;
  bool has_publicinputs() const;
  private:
  bool _internal_has_publicinputs() const;
  public:
  void clear_publicinputs();
  const ::zkprover::PublicInputs& publicinputs() const;
  PROTOBUF_MUST_USE_RESULT ::zkprover::PublicInputs* release_publicinputs();
  ::zkprover::PublicInputs* mutable_publicinputs();
  void set_allocated_publicinputs(::zkprover::PublicInputs* publicinputs);
  private:
  const ::zkprover::PublicInputs& _internal_publicinputs() const;
  ::zkprover::PublicInputs* _internal_mutable_publicinputs();
  public:
  void unsafe_arena_set_allocated_publicinputs(
      ::zkprover::PublicInputs* publicinputs);
  ::zkprover::PublicInputs* unsafe_arena_release_publicinputs();

  // @@protoc_insertion_point(class_scope:zkprover.PublicInputsExtended)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inputhash_;
  ::zkprover::PublicInputs* publicinputs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zk_2dprover_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NoParams

// -------------------------------------------------------------------

// State

// .zkprover.State.Status status = 1;
inline void State::clear_status() {
  status_ = 0;
}
inline ::zkprover::State_Status State::_internal_status() const {
  return static_cast< ::zkprover::State_Status >(status_);
}
inline ::zkprover::State_Status State::status() const {
  // @@protoc_insertion_point(field_get:zkprover.State.status)
  return _internal_status();
}
inline void State::_internal_set_status(::zkprover::State_Status value) {
  
  status_ = value;
}
inline void State::set_status(::zkprover::State_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:zkprover.State.status)
}

// .zkprover.Proof proof = 2;
inline bool State::_internal_has_proof() const {
  return this != internal_default_instance() && proof_ != nullptr;
}
inline bool State::has_proof() const {
  return _internal_has_proof();
}
inline void State::clear_proof() {
  if (GetArenaForAllocation() == nullptr && proof_ != nullptr) {
    delete proof_;
  }
  proof_ = nullptr;
}
inline const ::zkprover::Proof& State::_internal_proof() const {
  const ::zkprover::Proof* p = proof_;
  return p != nullptr ? *p : reinterpret_cast<const ::zkprover::Proof&>(
      ::zkprover::_Proof_default_instance_);
}
inline const ::zkprover::Proof& State::proof() const {
  // @@protoc_insertion_point(field_get:zkprover.State.proof)
  return _internal_proof();
}
inline void State::unsafe_arena_set_allocated_proof(
    ::zkprover::Proof* proof) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_);
  }
  proof_ = proof;
  if (proof) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zkprover.State.proof)
}
inline ::zkprover::Proof* State::release_proof() {
  
  ::zkprover::Proof* temp = proof_;
  proof_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zkprover::Proof* State::unsafe_arena_release_proof() {
  // @@protoc_insertion_point(field_release:zkprover.State.proof)
  
  ::zkprover::Proof* temp = proof_;
  proof_ = nullptr;
  return temp;
}
inline ::zkprover::Proof* State::_internal_mutable_proof() {
  
  if (proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::zkprover::Proof>(GetArenaForAllocation());
    proof_ = p;
  }
  return proof_;
}
inline ::zkprover::Proof* State::mutable_proof() {
  ::zkprover::Proof* _msg = _internal_mutable_proof();
  // @@protoc_insertion_point(field_mutable:zkprover.State.proof)
  return _msg;
}
inline void State::set_allocated_proof(::zkprover::Proof* proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete proof_;
  }
  if (proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::zkprover::Proof>::GetOwningArena(proof);
    if (message_arena != submessage_arena) {
      proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof, submessage_arena);
    }
    
  } else {
    
  }
  proof_ = proof;
  // @@protoc_insertion_point(field_set_allocated:zkprover.State.proof)
}

// -------------------------------------------------------------------

// ProofX

// repeated string proof = 1;
inline int ProofX::_internal_proof_size() const {
  return proof_.size();
}
inline int ProofX::proof_size() const {
  return _internal_proof_size();
}
inline void ProofX::clear_proof() {
  proof_.Clear();
}
inline std::string* ProofX::add_proof() {
  std::string* _s = _internal_add_proof();
  // @@protoc_insertion_point(field_add_mutable:zkprover.ProofX.proof)
  return _s;
}
inline const std::string& ProofX::_internal_proof(int index) const {
  return proof_.Get(index);
}
inline const std::string& ProofX::proof(int index) const {
  // @@protoc_insertion_point(field_get:zkprover.ProofX.proof)
  return _internal_proof(index);
}
inline std::string* ProofX::mutable_proof(int index) {
  // @@protoc_insertion_point(field_mutable:zkprover.ProofX.proof)
  return proof_.Mutable(index);
}
inline void ProofX::set_proof(int index, const std::string& value) {
  proof_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zkprover.ProofX.proof)
}
inline void ProofX::set_proof(int index, std::string&& value) {
  proof_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zkprover.ProofX.proof)
}
inline void ProofX::set_proof(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proof_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zkprover.ProofX.proof)
}
inline void ProofX::set_proof(int index, const char* value, size_t size) {
  proof_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zkprover.ProofX.proof)
}
inline std::string* ProofX::_internal_add_proof() {
  return proof_.Add();
}
inline void ProofX::add_proof(const std::string& value) {
  proof_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zkprover.ProofX.proof)
}
inline void ProofX::add_proof(std::string&& value) {
  proof_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zkprover.ProofX.proof)
}
inline void ProofX::add_proof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proof_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zkprover.ProofX.proof)
}
inline void ProofX::add_proof(const char* value, size_t size) {
  proof_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zkprover.ProofX.proof)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProofX::proof() const {
  // @@protoc_insertion_point(field_list:zkprover.ProofX.proof)
  return proof_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProofX::mutable_proof() {
  // @@protoc_insertion_point(field_mutable_list:zkprover.ProofX.proof)
  return &proof_;
}

// -------------------------------------------------------------------

// PublicInputs

// string oldStateRoot = 1;
inline void PublicInputs::clear_oldstateroot() {
  oldstateroot_.ClearToEmpty();
}
inline const std::string& PublicInputs::oldstateroot() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputs.oldStateRoot)
  return _internal_oldstateroot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_oldstateroot(ArgT0&& arg0, ArgT... args) {
 
 oldstateroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zkprover.PublicInputs.oldStateRoot)
}
inline std::string* PublicInputs::mutable_oldstateroot() {
  std::string* _s = _internal_mutable_oldstateroot();
  // @@protoc_insertion_point(field_mutable:zkprover.PublicInputs.oldStateRoot)
  return _s;
}
inline const std::string& PublicInputs::_internal_oldstateroot() const {
  return oldstateroot_.Get();
}
inline void PublicInputs::_internal_set_oldstateroot(const std::string& value) {
  
  oldstateroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_oldstateroot() {
  
  return oldstateroot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublicInputs::release_oldstateroot() {
  // @@protoc_insertion_point(field_release:zkprover.PublicInputs.oldStateRoot)
  return oldstateroot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublicInputs::set_allocated_oldstateroot(std::string* oldstateroot) {
  if (oldstateroot != nullptr) {
    
  } else {
    
  }
  oldstateroot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oldstateroot,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:zkprover.PublicInputs.oldStateRoot)
}

// string oldLocalExitRoot = 2;
inline void PublicInputs::clear_oldlocalexitroot() {
  oldlocalexitroot_.ClearToEmpty();
}
inline const std::string& PublicInputs::oldlocalexitroot() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputs.oldLocalExitRoot)
  return _internal_oldlocalexitroot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_oldlocalexitroot(ArgT0&& arg0, ArgT... args) {
 
 oldlocalexitroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zkprover.PublicInputs.oldLocalExitRoot)
}
inline std::string* PublicInputs::mutable_oldlocalexitroot() {
  std::string* _s = _internal_mutable_oldlocalexitroot();
  // @@protoc_insertion_point(field_mutable:zkprover.PublicInputs.oldLocalExitRoot)
  return _s;
}
inline const std::string& PublicInputs::_internal_oldlocalexitroot() const {
  return oldlocalexitroot_.Get();
}
inline void PublicInputs::_internal_set_oldlocalexitroot(const std::string& value) {
  
  oldlocalexitroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_oldlocalexitroot() {
  
  return oldlocalexitroot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublicInputs::release_oldlocalexitroot() {
  // @@protoc_insertion_point(field_release:zkprover.PublicInputs.oldLocalExitRoot)
  return oldlocalexitroot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublicInputs::set_allocated_oldlocalexitroot(std::string* oldlocalexitroot) {
  if (oldlocalexitroot != nullptr) {
    
  } else {
    
  }
  oldlocalexitroot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oldlocalexitroot,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:zkprover.PublicInputs.oldLocalExitRoot)
}

// string newStateRoot = 3;
inline void PublicInputs::clear_newstateroot() {
  newstateroot_.ClearToEmpty();
}
inline const std::string& PublicInputs::newstateroot() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputs.newStateRoot)
  return _internal_newstateroot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_newstateroot(ArgT0&& arg0, ArgT... args) {
 
 newstateroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zkprover.PublicInputs.newStateRoot)
}
inline std::string* PublicInputs::mutable_newstateroot() {
  std::string* _s = _internal_mutable_newstateroot();
  // @@protoc_insertion_point(field_mutable:zkprover.PublicInputs.newStateRoot)
  return _s;
}
inline const std::string& PublicInputs::_internal_newstateroot() const {
  return newstateroot_.Get();
}
inline void PublicInputs::_internal_set_newstateroot(const std::string& value) {
  
  newstateroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_newstateroot() {
  
  return newstateroot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublicInputs::release_newstateroot() {
  // @@protoc_insertion_point(field_release:zkprover.PublicInputs.newStateRoot)
  return newstateroot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublicInputs::set_allocated_newstateroot(std::string* newstateroot) {
  if (newstateroot != nullptr) {
    
  } else {
    
  }
  newstateroot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), newstateroot,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:zkprover.PublicInputs.newStateRoot)
}

// string newLocalExitRoot = 4;
inline void PublicInputs::clear_newlocalexitroot() {
  newlocalexitroot_.ClearToEmpty();
}
inline const std::string& PublicInputs::newlocalexitroot() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputs.newLocalExitRoot)
  return _internal_newlocalexitroot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_newlocalexitroot(ArgT0&& arg0, ArgT... args) {
 
 newlocalexitroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zkprover.PublicInputs.newLocalExitRoot)
}
inline std::string* PublicInputs::mutable_newlocalexitroot() {
  std::string* _s = _internal_mutable_newlocalexitroot();
  // @@protoc_insertion_point(field_mutable:zkprover.PublicInputs.newLocalExitRoot)
  return _s;
}
inline const std::string& PublicInputs::_internal_newlocalexitroot() const {
  return newlocalexitroot_.Get();
}
inline void PublicInputs::_internal_set_newlocalexitroot(const std::string& value) {
  
  newlocalexitroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_newlocalexitroot() {
  
  return newlocalexitroot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublicInputs::release_newlocalexitroot() {
  // @@protoc_insertion_point(field_release:zkprover.PublicInputs.newLocalExitRoot)
  return newlocalexitroot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublicInputs::set_allocated_newlocalexitroot(std::string* newlocalexitroot) {
  if (newlocalexitroot != nullptr) {
    
  } else {
    
  }
  newlocalexitroot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), newlocalexitroot,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:zkprover.PublicInputs.newLocalExitRoot)
}

// string sequencerAddr = 5;
inline void PublicInputs::clear_sequenceraddr() {
  sequenceraddr_.ClearToEmpty();
}
inline const std::string& PublicInputs::sequenceraddr() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputs.sequencerAddr)
  return _internal_sequenceraddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_sequenceraddr(ArgT0&& arg0, ArgT... args) {
 
 sequenceraddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zkprover.PublicInputs.sequencerAddr)
}
inline std::string* PublicInputs::mutable_sequenceraddr() {
  std::string* _s = _internal_mutable_sequenceraddr();
  // @@protoc_insertion_point(field_mutable:zkprover.PublicInputs.sequencerAddr)
  return _s;
}
inline const std::string& PublicInputs::_internal_sequenceraddr() const {
  return sequenceraddr_.Get();
}
inline void PublicInputs::_internal_set_sequenceraddr(const std::string& value) {
  
  sequenceraddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_sequenceraddr() {
  
  return sequenceraddr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublicInputs::release_sequenceraddr() {
  // @@protoc_insertion_point(field_release:zkprover.PublicInputs.sequencerAddr)
  return sequenceraddr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublicInputs::set_allocated_sequenceraddr(std::string* sequenceraddr) {
  if (sequenceraddr != nullptr) {
    
  } else {
    
  }
  sequenceraddr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sequenceraddr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:zkprover.PublicInputs.sequencerAddr)
}

// string batchHashData = 6;
inline void PublicInputs::clear_batchhashdata() {
  batchhashdata_.ClearToEmpty();
}
inline const std::string& PublicInputs::batchhashdata() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputs.batchHashData)
  return _internal_batchhashdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_batchhashdata(ArgT0&& arg0, ArgT... args) {
 
 batchhashdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zkprover.PublicInputs.batchHashData)
}
inline std::string* PublicInputs::mutable_batchhashdata() {
  std::string* _s = _internal_mutable_batchhashdata();
  // @@protoc_insertion_point(field_mutable:zkprover.PublicInputs.batchHashData)
  return _s;
}
inline const std::string& PublicInputs::_internal_batchhashdata() const {
  return batchhashdata_.Get();
}
inline void PublicInputs::_internal_set_batchhashdata(const std::string& value) {
  
  batchhashdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_batchhashdata() {
  
  return batchhashdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublicInputs::release_batchhashdata() {
  // @@protoc_insertion_point(field_release:zkprover.PublicInputs.batchHashData)
  return batchhashdata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublicInputs::set_allocated_batchhashdata(std::string* batchhashdata) {
  if (batchhashdata != nullptr) {
    
  } else {
    
  }
  batchhashdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batchhashdata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:zkprover.PublicInputs.batchHashData)
}

// uint32 chainId = 7;
inline void PublicInputs::clear_chainid() {
  chainid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PublicInputs::_internal_chainid() const {
  return chainid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PublicInputs::chainid() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputs.chainId)
  return _internal_chainid();
}
inline void PublicInputs::_internal_set_chainid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  chainid_ = value;
}
inline void PublicInputs::set_chainid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_chainid(value);
  // @@protoc_insertion_point(field_set:zkprover.PublicInputs.chainId)
}

// uint32 batchNum = 8;
inline void PublicInputs::clear_batchnum() {
  batchnum_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PublicInputs::_internal_batchnum() const {
  return batchnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PublicInputs::batchnum() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputs.batchNum)
  return _internal_batchnum();
}
inline void PublicInputs::_internal_set_batchnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  batchnum_ = value;
}
inline void PublicInputs::set_batchnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_batchnum(value);
  // @@protoc_insertion_point(field_set:zkprover.PublicInputs.batchNum)
}

// -------------------------------------------------------------------

// Proof

// repeated string proofA = 1;
inline int Proof::_internal_proofa_size() const {
  return proofa_.size();
}
inline int Proof::proofa_size() const {
  return _internal_proofa_size();
}
inline void Proof::clear_proofa() {
  proofa_.Clear();
}
inline std::string* Proof::add_proofa() {
  std::string* _s = _internal_add_proofa();
  // @@protoc_insertion_point(field_add_mutable:zkprover.Proof.proofA)
  return _s;
}
inline const std::string& Proof::_internal_proofa(int index) const {
  return proofa_.Get(index);
}
inline const std::string& Proof::proofa(int index) const {
  // @@protoc_insertion_point(field_get:zkprover.Proof.proofA)
  return _internal_proofa(index);
}
inline std::string* Proof::mutable_proofa(int index) {
  // @@protoc_insertion_point(field_mutable:zkprover.Proof.proofA)
  return proofa_.Mutable(index);
}
inline void Proof::set_proofa(int index, const std::string& value) {
  proofa_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zkprover.Proof.proofA)
}
inline void Proof::set_proofa(int index, std::string&& value) {
  proofa_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zkprover.Proof.proofA)
}
inline void Proof::set_proofa(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proofa_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zkprover.Proof.proofA)
}
inline void Proof::set_proofa(int index, const char* value, size_t size) {
  proofa_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zkprover.Proof.proofA)
}
inline std::string* Proof::_internal_add_proofa() {
  return proofa_.Add();
}
inline void Proof::add_proofa(const std::string& value) {
  proofa_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zkprover.Proof.proofA)
}
inline void Proof::add_proofa(std::string&& value) {
  proofa_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zkprover.Proof.proofA)
}
inline void Proof::add_proofa(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proofa_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zkprover.Proof.proofA)
}
inline void Proof::add_proofa(const char* value, size_t size) {
  proofa_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zkprover.Proof.proofA)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Proof::proofa() const {
  // @@protoc_insertion_point(field_list:zkprover.Proof.proofA)
  return proofa_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Proof::mutable_proofa() {
  // @@protoc_insertion_point(field_mutable_list:zkprover.Proof.proofA)
  return &proofa_;
}

// repeated .zkprover.ProofX proofB = 2;
inline int Proof::_internal_proofb_size() const {
  return proofb_.size();
}
inline int Proof::proofb_size() const {
  return _internal_proofb_size();
}
inline void Proof::clear_proofb() {
  proofb_.Clear();
}
inline ::zkprover::ProofX* Proof::mutable_proofb(int index) {
  // @@protoc_insertion_point(field_mutable:zkprover.Proof.proofB)
  return proofb_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zkprover::ProofX >*
Proof::mutable_proofb() {
  // @@protoc_insertion_point(field_mutable_list:zkprover.Proof.proofB)
  return &proofb_;
}
inline const ::zkprover::ProofX& Proof::_internal_proofb(int index) const {
  return proofb_.Get(index);
}
inline const ::zkprover::ProofX& Proof::proofb(int index) const {
  // @@protoc_insertion_point(field_get:zkprover.Proof.proofB)
  return _internal_proofb(index);
}
inline ::zkprover::ProofX* Proof::_internal_add_proofb() {
  return proofb_.Add();
}
inline ::zkprover::ProofX* Proof::add_proofb() {
  ::zkprover::ProofX* _add = _internal_add_proofb();
  // @@protoc_insertion_point(field_add:zkprover.Proof.proofB)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zkprover::ProofX >&
Proof::proofb() const {
  // @@protoc_insertion_point(field_list:zkprover.Proof.proofB)
  return proofb_;
}

// repeated string proofC = 3;
inline int Proof::_internal_proofc_size() const {
  return proofc_.size();
}
inline int Proof::proofc_size() const {
  return _internal_proofc_size();
}
inline void Proof::clear_proofc() {
  proofc_.Clear();
}
inline std::string* Proof::add_proofc() {
  std::string* _s = _internal_add_proofc();
  // @@protoc_insertion_point(field_add_mutable:zkprover.Proof.proofC)
  return _s;
}
inline const std::string& Proof::_internal_proofc(int index) const {
  return proofc_.Get(index);
}
inline const std::string& Proof::proofc(int index) const {
  // @@protoc_insertion_point(field_get:zkprover.Proof.proofC)
  return _internal_proofc(index);
}
inline std::string* Proof::mutable_proofc(int index) {
  // @@protoc_insertion_point(field_mutable:zkprover.Proof.proofC)
  return proofc_.Mutable(index);
}
inline void Proof::set_proofc(int index, const std::string& value) {
  proofc_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zkprover.Proof.proofC)
}
inline void Proof::set_proofc(int index, std::string&& value) {
  proofc_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zkprover.Proof.proofC)
}
inline void Proof::set_proofc(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proofc_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zkprover.Proof.proofC)
}
inline void Proof::set_proofc(int index, const char* value, size_t size) {
  proofc_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zkprover.Proof.proofC)
}
inline std::string* Proof::_internal_add_proofc() {
  return proofc_.Add();
}
inline void Proof::add_proofc(const std::string& value) {
  proofc_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zkprover.Proof.proofC)
}
inline void Proof::add_proofc(std::string&& value) {
  proofc_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zkprover.Proof.proofC)
}
inline void Proof::add_proofc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proofc_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zkprover.Proof.proofC)
}
inline void Proof::add_proofc(const char* value, size_t size) {
  proofc_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zkprover.Proof.proofC)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Proof::proofc() const {
  // @@protoc_insertion_point(field_list:zkprover.Proof.proofC)
  return proofc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Proof::mutable_proofc() {
  // @@protoc_insertion_point(field_mutable_list:zkprover.Proof.proofC)
  return &proofc_;
}

// .zkprover.PublicInputsExtended publicInputsExtended = 4;
inline bool Proof::_internal_has_publicinputsextended() const {
  return this != internal_default_instance() && publicinputsextended_ != nullptr;
}
inline bool Proof::has_publicinputsextended() const {
  return _internal_has_publicinputsextended();
}
inline void Proof::clear_publicinputsextended() {
  if (GetArenaForAllocation() == nullptr && publicinputsextended_ != nullptr) {
    delete publicinputsextended_;
  }
  publicinputsextended_ = nullptr;
}
inline const ::zkprover::PublicInputsExtended& Proof::_internal_publicinputsextended() const {
  const ::zkprover::PublicInputsExtended* p = publicinputsextended_;
  return p != nullptr ? *p : reinterpret_cast<const ::zkprover::PublicInputsExtended&>(
      ::zkprover::_PublicInputsExtended_default_instance_);
}
inline const ::zkprover::PublicInputsExtended& Proof::publicinputsextended() const {
  // @@protoc_insertion_point(field_get:zkprover.Proof.publicInputsExtended)
  return _internal_publicinputsextended();
}
inline void Proof::unsafe_arena_set_allocated_publicinputsextended(
    ::zkprover::PublicInputsExtended* publicinputsextended) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(publicinputsextended_);
  }
  publicinputsextended_ = publicinputsextended;
  if (publicinputsextended) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zkprover.Proof.publicInputsExtended)
}
inline ::zkprover::PublicInputsExtended* Proof::release_publicinputsextended() {
  
  ::zkprover::PublicInputsExtended* temp = publicinputsextended_;
  publicinputsextended_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zkprover::PublicInputsExtended* Proof::unsafe_arena_release_publicinputsextended() {
  // @@protoc_insertion_point(field_release:zkprover.Proof.publicInputsExtended)
  
  ::zkprover::PublicInputsExtended* temp = publicinputsextended_;
  publicinputsextended_ = nullptr;
  return temp;
}
inline ::zkprover::PublicInputsExtended* Proof::_internal_mutable_publicinputsextended() {
  
  if (publicinputsextended_ == nullptr) {
    auto* p = CreateMaybeMessage<::zkprover::PublicInputsExtended>(GetArenaForAllocation());
    publicinputsextended_ = p;
  }
  return publicinputsextended_;
}
inline ::zkprover::PublicInputsExtended* Proof::mutable_publicinputsextended() {
  ::zkprover::PublicInputsExtended* _msg = _internal_mutable_publicinputsextended();
  // @@protoc_insertion_point(field_mutable:zkprover.Proof.publicInputsExtended)
  return _msg;
}
inline void Proof::set_allocated_publicinputsextended(::zkprover::PublicInputsExtended* publicinputsextended) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete publicinputsextended_;
  }
  if (publicinputsextended) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::zkprover::PublicInputsExtended>::GetOwningArena(publicinputsextended);
    if (message_arena != submessage_arena) {
      publicinputsextended = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, publicinputsextended, submessage_arena);
    }
    
  } else {
    
  }
  publicinputsextended_ = publicinputsextended;
  // @@protoc_insertion_point(field_set_allocated:zkprover.Proof.publicInputsExtended)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InputProver

// string message = 1;
inline void InputProver::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& InputProver::message() const {
  // @@protoc_insertion_point(field_get:zkprover.InputProver.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputProver::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zkprover.InputProver.message)
}
inline std::string* InputProver::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:zkprover.InputProver.message)
  return _s;
}
inline const std::string& InputProver::_internal_message() const {
  return message_.Get();
}
inline void InputProver::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputProver::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputProver::release_message() {
  // @@protoc_insertion_point(field_release:zkprover.InputProver.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputProver::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:zkprover.InputProver.message)
}

// .zkprover.PublicInputs publicInputs = 2;
inline bool InputProver::_internal_has_publicinputs() const {
  return this != internal_default_instance() && publicinputs_ != nullptr;
}
inline bool InputProver::has_publicinputs() const {
  return _internal_has_publicinputs();
}
inline void InputProver::clear_publicinputs() {
  if (GetArenaForAllocation() == nullptr && publicinputs_ != nullptr) {
    delete publicinputs_;
  }
  publicinputs_ = nullptr;
}
inline const ::zkprover::PublicInputs& InputProver::_internal_publicinputs() const {
  const ::zkprover::PublicInputs* p = publicinputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::zkprover::PublicInputs&>(
      ::zkprover::_PublicInputs_default_instance_);
}
inline const ::zkprover::PublicInputs& InputProver::publicinputs() const {
  // @@protoc_insertion_point(field_get:zkprover.InputProver.publicInputs)
  return _internal_publicinputs();
}
inline void InputProver::unsafe_arena_set_allocated_publicinputs(
    ::zkprover::PublicInputs* publicinputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(publicinputs_);
  }
  publicinputs_ = publicinputs;
  if (publicinputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zkprover.InputProver.publicInputs)
}
inline ::zkprover::PublicInputs* InputProver::release_publicinputs() {
  
  ::zkprover::PublicInputs* temp = publicinputs_;
  publicinputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zkprover::PublicInputs* InputProver::unsafe_arena_release_publicinputs() {
  // @@protoc_insertion_point(field_release:zkprover.InputProver.publicInputs)
  
  ::zkprover::PublicInputs* temp = publicinputs_;
  publicinputs_ = nullptr;
  return temp;
}
inline ::zkprover::PublicInputs* InputProver::_internal_mutable_publicinputs() {
  
  if (publicinputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::zkprover::PublicInputs>(GetArenaForAllocation());
    publicinputs_ = p;
  }
  return publicinputs_;
}
inline ::zkprover::PublicInputs* InputProver::mutable_publicinputs() {
  ::zkprover::PublicInputs* _msg = _internal_mutable_publicinputs();
  // @@protoc_insertion_point(field_mutable:zkprover.InputProver.publicInputs)
  return _msg;
}
inline void InputProver::set_allocated_publicinputs(::zkprover::PublicInputs* publicinputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete publicinputs_;
  }
  if (publicinputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::zkprover::PublicInputs>::GetOwningArena(publicinputs);
    if (message_arena != submessage_arena) {
      publicinputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, publicinputs, submessage_arena);
    }
    
  } else {
    
  }
  publicinputs_ = publicinputs;
  // @@protoc_insertion_point(field_set_allocated:zkprover.InputProver.publicInputs)
}

// string globalExitRoot = 3;
inline void InputProver::clear_globalexitroot() {
  globalexitroot_.ClearToEmpty();
}
inline const std::string& InputProver::globalexitroot() const {
  // @@protoc_insertion_point(field_get:zkprover.InputProver.globalExitRoot)
  return _internal_globalexitroot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputProver::set_globalexitroot(ArgT0&& arg0, ArgT... args) {
 
 globalexitroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zkprover.InputProver.globalExitRoot)
}
inline std::string* InputProver::mutable_globalexitroot() {
  std::string* _s = _internal_mutable_globalexitroot();
  // @@protoc_insertion_point(field_mutable:zkprover.InputProver.globalExitRoot)
  return _s;
}
inline const std::string& InputProver::_internal_globalexitroot() const {
  return globalexitroot_.Get();
}
inline void InputProver::_internal_set_globalexitroot(const std::string& value) {
  
  globalexitroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InputProver::_internal_mutable_globalexitroot() {
  
  return globalexitroot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InputProver::release_globalexitroot() {
  // @@protoc_insertion_point(field_release:zkprover.InputProver.globalExitRoot)
  return globalexitroot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InputProver::set_allocated_globalexitroot(std::string* globalexitroot) {
  if (globalexitroot != nullptr) {
    
  } else {
    
  }
  globalexitroot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), globalexitroot,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:zkprover.InputProver.globalExitRoot)
}

// repeated string txs = 4;
inline int InputProver::_internal_txs_size() const {
  return txs_.size();
}
inline int InputProver::txs_size() const {
  return _internal_txs_size();
}
inline void InputProver::clear_txs() {
  txs_.Clear();
}
inline std::string* InputProver::add_txs() {
  std::string* _s = _internal_add_txs();
  // @@protoc_insertion_point(field_add_mutable:zkprover.InputProver.txs)
  return _s;
}
inline const std::string& InputProver::_internal_txs(int index) const {
  return txs_.Get(index);
}
inline const std::string& InputProver::txs(int index) const {
  // @@protoc_insertion_point(field_get:zkprover.InputProver.txs)
  return _internal_txs(index);
}
inline std::string* InputProver::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:zkprover.InputProver.txs)
  return txs_.Mutable(index);
}
inline void InputProver::set_txs(int index, const std::string& value) {
  txs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zkprover.InputProver.txs)
}
inline void InputProver::set_txs(int index, std::string&& value) {
  txs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zkprover.InputProver.txs)
}
inline void InputProver::set_txs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zkprover.InputProver.txs)
}
inline void InputProver::set_txs(int index, const char* value, size_t size) {
  txs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zkprover.InputProver.txs)
}
inline std::string* InputProver::_internal_add_txs() {
  return txs_.Add();
}
inline void InputProver::add_txs(const std::string& value) {
  txs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zkprover.InputProver.txs)
}
inline void InputProver::add_txs(std::string&& value) {
  txs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zkprover.InputProver.txs)
}
inline void InputProver::add_txs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zkprover.InputProver.txs)
}
inline void InputProver::add_txs(const char* value, size_t size) {
  txs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zkprover.InputProver.txs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InputProver::txs() const {
  // @@protoc_insertion_point(field_list:zkprover.InputProver.txs)
  return txs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InputProver::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:zkprover.InputProver.txs)
  return &txs_;
}

// map<string, string> keys = 5;
inline int InputProver::_internal_keys_size() const {
  return keys_.size();
}
inline int InputProver::keys_size() const {
  return _internal_keys_size();
}
inline void InputProver::clear_keys() {
  keys_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InputProver::_internal_keys() const {
  return keys_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InputProver::keys() const {
  // @@protoc_insertion_point(field_map:zkprover.InputProver.keys)
  return _internal_keys();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InputProver::_internal_mutable_keys() {
  return keys_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InputProver::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_map:zkprover.InputProver.keys)
  return _internal_mutable_keys();
}

// -------------------------------------------------------------------

// PublicInputsExtended

// .zkprover.PublicInputs publicInputs = 2;
inline bool PublicInputsExtended::_internal_has_publicinputs() const {
  return this != internal_default_instance() && publicinputs_ != nullptr;
}
inline bool PublicInputsExtended::has_publicinputs() const {
  return _internal_has_publicinputs();
}
inline void PublicInputsExtended::clear_publicinputs() {
  if (GetArenaForAllocation() == nullptr && publicinputs_ != nullptr) {
    delete publicinputs_;
  }
  publicinputs_ = nullptr;
}
inline const ::zkprover::PublicInputs& PublicInputsExtended::_internal_publicinputs() const {
  const ::zkprover::PublicInputs* p = publicinputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::zkprover::PublicInputs&>(
      ::zkprover::_PublicInputs_default_instance_);
}
inline const ::zkprover::PublicInputs& PublicInputsExtended::publicinputs() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputsExtended.publicInputs)
  return _internal_publicinputs();
}
inline void PublicInputsExtended::unsafe_arena_set_allocated_publicinputs(
    ::zkprover::PublicInputs* publicinputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(publicinputs_);
  }
  publicinputs_ = publicinputs;
  if (publicinputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zkprover.PublicInputsExtended.publicInputs)
}
inline ::zkprover::PublicInputs* PublicInputsExtended::release_publicinputs() {
  
  ::zkprover::PublicInputs* temp = publicinputs_;
  publicinputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zkprover::PublicInputs* PublicInputsExtended::unsafe_arena_release_publicinputs() {
  // @@protoc_insertion_point(field_release:zkprover.PublicInputsExtended.publicInputs)
  
  ::zkprover::PublicInputs* temp = publicinputs_;
  publicinputs_ = nullptr;
  return temp;
}
inline ::zkprover::PublicInputs* PublicInputsExtended::_internal_mutable_publicinputs() {
  
  if (publicinputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::zkprover::PublicInputs>(GetArenaForAllocation());
    publicinputs_ = p;
  }
  return publicinputs_;
}
inline ::zkprover::PublicInputs* PublicInputsExtended::mutable_publicinputs() {
  ::zkprover::PublicInputs* _msg = _internal_mutable_publicinputs();
  // @@protoc_insertion_point(field_mutable:zkprover.PublicInputsExtended.publicInputs)
  return _msg;
}
inline void PublicInputsExtended::set_allocated_publicinputs(::zkprover::PublicInputs* publicinputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete publicinputs_;
  }
  if (publicinputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::zkprover::PublicInputs>::GetOwningArena(publicinputs);
    if (message_arena != submessage_arena) {
      publicinputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, publicinputs, submessage_arena);
    }
    
  } else {
    
  }
  publicinputs_ = publicinputs;
  // @@protoc_insertion_point(field_set_allocated:zkprover.PublicInputsExtended.publicInputs)
}

// string inputHash = 5;
inline void PublicInputsExtended::clear_inputhash() {
  inputhash_.ClearToEmpty();
}
inline const std::string& PublicInputsExtended::inputhash() const {
  // @@protoc_insertion_point(field_get:zkprover.PublicInputsExtended.inputHash)
  return _internal_inputhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputsExtended::set_inputhash(ArgT0&& arg0, ArgT... args) {
 
 inputhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zkprover.PublicInputsExtended.inputHash)
}
inline std::string* PublicInputsExtended::mutable_inputhash() {
  std::string* _s = _internal_mutable_inputhash();
  // @@protoc_insertion_point(field_mutable:zkprover.PublicInputsExtended.inputHash)
  return _s;
}
inline const std::string& PublicInputsExtended::_internal_inputhash() const {
  return inputhash_.Get();
}
inline void PublicInputsExtended::_internal_set_inputhash(const std::string& value) {
  
  inputhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublicInputsExtended::_internal_mutable_inputhash() {
  
  return inputhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublicInputsExtended::release_inputhash() {
  // @@protoc_insertion_point(field_release:zkprover.PublicInputsExtended.inputHash)
  return inputhash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublicInputsExtended::set_allocated_inputhash(std::string* inputhash) {
  if (inputhash != nullptr) {
    
  } else {
    
  }
  inputhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), inputhash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:zkprover.PublicInputsExtended.inputHash)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zkprover

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zkprover::State_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zkprover::State_Status>() {
  return ::zkprover::State_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zk_2dprover_2eproto
