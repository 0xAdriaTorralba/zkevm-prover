#include "main_exec_generated_fast.hpp"

#define MEM_OFFSET 0x30000
#define STACK_OFFSET 0x20000
#define CODE_OFFSET 0x10000
#define CTX_OFFSET 0x40000

vector<void *> main_exec_generated_fast_labels;
void main_exec_generated_fast (FiniteField &fr, const Input &input, Database &db, Counters &counters)
{
    // opN are local, uncommitted polynomials
    FieldElement op0, op1, op2, op3, op4, op5, op6, op7;
    FieldElement A0, A1, A2, A3, A4, A5, A6, A7;
    A7 = A6 = A5 = A4 = A3 = A2 = A1 = A0 = fr.zero();
    FieldElement B0, B1, B2, B3, B4, B5, B6, B7;
    B7 = B6 = B5 = B4 = B3 = B2 = B1 = B0 = fr.zero();
    FieldElement C0, C1, C2, C3, C4, C5, C6, C7;
    C7 = C6 = C5 = C4 = C3 = C2 = C1 = C0 = fr.zero();
    FieldElement D0, D1, D2, D3, D4, D5, D6, D7;
    D7 = D6 = D5 = D4 = D3 = D2 = D1 = D0 = fr.zero();
    FieldElement E0, E1, E2, E3, E4, E5, E6, E7;
    E7 = E6 = E5 = E4 = E3 = E2 = E1 = E0 = fr.zero();
    FieldElement SR0, SR1, SR2, SR3, SR4, SR5, SR6, SR7;
    SR7 = SR6 = SR5 = SR4 = SR3 = SR2 = SR1 = SR0 = fr.zero();
    FieldElement HASHPOS, GAS, CTX, PC, SP, RR, carry, MAXMEM;
    HASHPOS = GAS = CTX = PC = SP = RR = carry = MAXMEM = fr.zero();
    uint32_t addrRel = 0; // Relative and absolute address auxiliary variables
    uint64_t addr = 0;
    int64_t i=-1; // Number of this evaluation
    int64_t N=1<<23;
    int64_t o;
    int64_t maxMemCalculated;
    int64_t mm;
    int64_t incHashPos = 0;

    if (main_exec_generated_fast_labels.size()==0)
    {
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_0);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_4);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_5);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_6);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_7);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_8);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_9);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_10);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_11);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_12);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_13);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_14);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_15);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_16);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_17);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_18);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_19);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_20);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_21);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_22);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_23);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_24);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_25);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_26);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_27);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_28);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_29);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_30);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_31);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_32);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_33);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_34);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_35);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_36);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_37);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_38);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_39);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_40);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_41);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_42);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_43);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_44);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_45);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_46);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_47);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_48);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_49);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_50);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_51);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_52);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_53);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_54);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_55);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_56);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_57);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_58);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_59);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_60);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_61);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_62);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_63);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_64);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_65);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_66);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_67);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_68);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_69);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_70);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_71);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_72);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_73);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_74);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_75);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_76);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_77);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_78);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_79);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_80);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_81);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_82);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_83);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_84);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_85);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_86);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_87);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_88);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_89);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_90);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_91);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_92);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_93);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_94);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_95);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_96);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_97);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_98);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_99);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_100);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_101);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_102);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_103);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_104);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_105);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_106);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_107);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_108);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_109);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_110);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_111);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_112);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_113);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_114);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_115);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_116);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_117);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_118);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_119);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_120);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_121);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_122);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_123);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_124);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_125);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_126);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_127);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_128);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_129);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_130);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_131);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_132);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_133);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_134);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_135);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_136);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_137);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_138);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_139);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_140);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_141);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_142);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_143);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_144);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_145);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_146);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_147);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_148);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_149);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_150);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_151);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_152);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_153);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_154);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_155);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_156);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_157);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_158);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_159);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_160);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_161);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_162);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_163);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_164);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_165);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_166);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_167);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_168);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_169);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_170);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_171);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_172);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_173);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_174);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_175);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_176);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_177);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_178);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_179);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_180);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_181);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_182);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_183);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_184);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_185);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_186);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_187);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_188);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_189);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_190);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_191);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_192);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_193);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_194);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_195);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_196);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_197);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_198);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_199);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_200);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_201);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_202);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_203);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_204);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_205);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_206);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_207);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_208);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_209);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_210);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_211);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_212);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_213);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_214);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_215);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_216);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_217);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_218);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_219);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_220);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_221);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_222);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_223);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_224);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_225);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_226);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_227);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_228);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_229);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_230);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_231);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_232);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_233);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_234);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_235);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_236);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_237);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_238);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_239);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_240);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_241);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_242);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_243);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_244);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_245);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_246);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_247);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_248);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_249);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_250);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_251);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_252);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_253);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_254);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_255);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_256);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_257);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_258);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_259);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_260);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_261);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_262);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_263);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_264);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_265);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_266);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_267);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_268);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_269);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_270);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_271);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_272);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_273);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_274);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_275);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_276);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_277);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_278);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_279);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_280);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_281);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_282);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_283);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_284);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_285);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_286);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_287);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_288);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_289);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_290);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_291);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_292);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_293);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_294);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_295);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_296);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_297);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_298);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_299);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_300);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_301);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_302);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_303);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_304);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_305);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_306);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_307);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_308);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_309);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_310);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_311);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_312);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_313);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_314);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_315);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_316);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_317);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_318);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_319);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_320);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_321);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_322);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_323);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_324);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_325);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_326);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_327);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_328);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_329);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_330);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_331);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_332);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_333);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_334);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_335);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_336);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_337);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_338);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_339);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_340);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_341);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_342);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_343);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_344);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_345);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_346);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_347);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_348);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_349);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_350);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_351);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_352);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_353);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_354);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_355);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_356);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_357);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_358);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_359);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_360);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_361);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_362);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_363);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_364);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_365);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_366);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_367);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_368);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_369);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_370);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_371);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_372);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_373);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_374);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_375);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_376);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_377);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_378);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_379);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_380);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_381);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_382);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_383);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_384);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_385);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_386);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_387);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_388);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_389);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_390);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_391);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_392);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_393);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_394);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_395);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_396);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_397);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_398);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_399);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_400);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_401);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_402);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_403);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_404);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_405);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_406);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_407);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_408);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_409);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_410);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_411);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_412);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_413);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_414);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_415);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_416);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_417);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_418);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_419);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_420);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_421);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_422);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_423);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_424);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_425);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_426);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_427);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_428);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_429);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_430);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_431);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_432);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_433);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_434);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_435);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_436);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_437);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_438);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_439);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_440);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_441);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_442);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_443);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_444);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_445);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_446);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_447);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_448);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_449);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_450);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_451);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_452);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_453);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_454);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_455);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_456);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_457);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_458);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_459);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_460);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_461);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_462);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_463);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_464);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_465);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_466);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_467);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_468);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_469);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_470);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_471);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_472);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_473);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_474);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_475);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_476);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_477);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_478);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_479);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_480);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_481);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_482);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_483);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_484);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_485);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_486);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_487);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_488);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_489);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_490);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_491);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_492);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_493);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_494);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_495);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_496);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_497);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_498);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_499);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_500);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_501);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_502);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_503);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_504);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_505);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_506);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_507);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_508);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_509);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_510);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_511);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_512);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_513);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_514);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_515);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_516);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_517);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_518);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_519);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_520);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_521);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_522);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_523);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_524);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_525);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_526);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_527);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_528);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_529);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_530);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_531);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_532);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_533);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_534);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_535);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_536);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_537);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_538);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_539);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_540);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_541);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_542);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_543);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_544);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_545);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_546);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_547);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_548);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_549);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_550);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_551);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_552);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_553);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_554);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_555);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_556);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_557);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_558);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_559);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_560);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_561);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_562);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_563);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_564);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_565);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_566);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_567);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_568);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_569);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_570);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_571);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_572);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_573);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_574);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_575);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_576);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_577);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_578);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_579);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_580);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_581);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_582);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_583);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_584);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_585);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_586);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_587);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_588);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_589);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_590);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_591);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_592);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_593);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_594);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_595);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_596);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_597);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_598);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_599);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_600);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_601);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_602);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_603);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_604);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_605);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_606);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_607);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_608);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_609);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_610);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_611);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_612);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_613);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_614);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_615);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_616);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_617);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_618);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_619);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_620);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_621);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_622);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_623);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_624);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_625);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_626);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_627);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_628);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_629);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_630);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_631);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_632);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_633);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_634);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_635);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_636);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_637);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_638);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_639);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_640);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_641);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_642);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_643);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_644);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_645);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_646);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_647);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_648);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_649);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_650);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_651);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_652);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_653);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_654);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_655);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_656);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_657);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_658);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_659);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_660);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_661);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_662);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_663);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_664);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_665);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_666);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_667);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_668);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_669);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_670);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_671);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_672);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_673);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_674);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_675);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_676);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_677);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_678);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_679);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_680);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_681);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_682);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_683);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_684);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_685);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_686);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_687);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_688);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_689);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_690);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_691);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_692);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_693);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_694);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_695);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_696);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_697);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_698);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_699);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_700);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_701);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_702);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_703);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_704);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_705);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_706);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_707);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_708);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_709);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_710);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_711);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_712);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_713);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_714);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_715);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_716);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_717);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_718);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_719);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_720);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_721);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_722);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_723);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_724);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_725);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_726);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_727);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_728);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_729);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_730);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_731);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_732);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_733);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_734);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_735);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_736);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_737);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_738);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_739);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_740);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_741);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_742);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_743);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_744);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_745);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_746);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_747);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_748);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_749);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_750);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_751);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_752);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_753);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_754);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_755);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_756);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_757);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_758);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_759);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_760);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_761);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_762);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_763);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_764);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_765);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_766);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_767);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_768);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_769);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_770);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_771);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_772);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_773);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_774);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_775);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_776);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_777);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_778);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_779);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_780);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_781);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_782);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_783);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_784);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_785);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_786);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_787);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_788);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_789);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_790);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_791);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_792);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_793);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_794);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_795);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_796);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_797);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_798);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_799);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_800);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_801);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_802);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_803);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_804);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_805);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_806);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_807);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_808);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_809);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_810);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_811);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_812);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_813);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_814);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_815);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_816);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_817);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_818);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_819);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_820);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_821);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_822);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_823);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_824);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_825);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_826);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_827);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_828);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_829);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_830);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_831);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_832);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_833);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_834);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_835);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_836);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_837);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_838);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_839);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_840);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_841);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_842);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_843);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_844);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_845);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_846);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_847);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_848);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_849);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_850);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_851);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_852);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_853);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_854);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_855);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_856);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_857);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_858);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_859);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_860);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_861);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_862);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_863);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_864);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_865);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_866);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_867);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_868);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_869);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_870);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_871);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_872);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_873);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_874);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_875);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_876);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_877);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_878);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_879);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_880);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_881);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_882);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_883);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_884);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_885);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_886);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_887);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_888);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_889);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_890);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_891);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_892);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_893);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_894);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_895);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_896);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_897);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_898);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_899);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_900);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_901);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_902);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_903);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_904);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_905);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_906);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_907);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_908);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_909);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_910);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_911);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_912);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_913);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_914);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_915);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_916);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_917);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_918);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_919);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_920);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_921);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_922);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_923);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_924);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_925);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_926);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_927);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_928);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_929);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_930);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_931);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_932);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_933);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_934);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_935);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_936);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_937);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_938);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_939);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_940);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_941);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_942);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_943);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_944);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_945);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_946);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_947);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_948);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_949);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_950);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_951);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_952);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_953);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_954);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_955);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_956);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_957);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_958);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_959);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_960);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_961);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_962);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_963);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_964);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_965);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_966);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_967);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_968);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_969);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_970);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_971);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_972);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_973);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_974);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_975);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_976);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_977);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_978);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_979);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_980);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_981);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_982);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_983);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_984);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_985);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_986);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_987);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_988);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_989);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_990);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_991);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_992);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_993);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_994);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_995);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_996);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_997);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_998);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_999);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1000);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1001);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1002);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1003);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1004);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1005);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1006);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1007);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1008);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1009);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1010);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1011);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1012);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1013);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1014);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1015);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1016);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1017);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1018);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1019);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1020);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1021);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1022);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1023);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1024);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1025);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1026);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1027);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1028);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1029);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1030);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1031);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1032);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1033);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1034);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1035);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1036);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1037);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1038);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1039);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1040);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1041);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1042);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1043);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1044);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1045);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1046);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1047);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1048);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1049);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1050);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1051);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1052);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1053);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1054);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1055);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1056);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1057);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1058);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1059);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1060);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1061);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1062);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1063);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1064);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1065);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1066);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1067);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1068);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1069);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1070);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1071);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1072);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1073);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1074);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1075);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1076);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1077);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1078);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1079);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1080);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1081);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1082);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1083);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1084);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1085);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1086);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1087);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1088);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1089);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1090);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1091);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1092);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1093);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1094);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1095);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1096);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1097);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1098);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1099);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1100);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1101);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1102);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1103);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1104);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1105);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1106);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1107);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1108);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1109);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1110);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1111);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1112);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1113);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1114);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1115);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1116);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1117);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1118);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1119);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1120);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1121);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1122);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1123);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1124);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1125);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1126);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1127);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1128);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1129);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1130);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1131);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1132);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1133);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1134);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1135);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1136);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1137);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1138);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1139);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1140);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1141);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1142);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1143);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1144);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1145);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1146);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1147);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1148);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1149);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1150);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1151);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1152);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1153);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1154);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1155);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1156);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1157);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1158);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1159);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1160);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1161);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1162);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1163);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1164);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1165);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1166);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1167);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1168);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1169);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1170);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1171);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1172);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1173);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1174);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1175);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1176);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1177);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1178);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1179);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1180);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1181);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1182);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1183);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1184);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1185);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1186);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1187);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1188);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1189);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1190);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1191);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1192);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1193);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1194);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1195);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1196);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1197);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1198);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1199);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1200);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1201);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1202);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1203);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1204);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1205);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1206);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1207);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1208);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1209);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1210);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1211);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1212);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1213);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1214);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1215);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1216);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1217);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1218);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1219);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1220);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1221);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1222);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1223);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1224);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1225);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1226);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1227);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1228);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1229);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1230);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1231);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1232);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1233);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1234);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1235);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1236);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1237);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1238);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1239);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1240);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1241);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1242);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1243);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1244);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1245);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1246);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1247);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1248);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1249);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1250);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1251);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1252);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1253);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1254);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1255);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1256);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1257);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1258);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1259);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1260);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1261);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1262);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1263);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1264);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1265);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1266);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1267);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1268);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1269);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1270);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1271);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1272);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1273);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1274);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1275);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1276);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1277);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1278);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1279);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1280);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1281);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1282);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1283);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1284);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1285);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1286);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1287);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1288);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1289);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1290);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1291);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1292);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1293);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1294);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1295);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1296);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1297);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1298);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1299);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1300);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1301);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1302);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1303);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1304);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1305);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1306);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1307);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1308);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1309);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1310);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1311);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1312);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1313);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1314);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1315);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1316);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1317);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1318);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1319);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1320);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1321);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1322);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1323);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1324);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1325);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1326);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1327);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1328);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1329);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1330);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1331);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1332);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1333);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1334);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1335);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1336);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1337);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1338);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1339);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1340);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1341);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1342);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1343);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1344);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1345);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1346);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1347);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1348);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1349);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1350);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1351);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1352);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1353);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1354);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1355);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1356);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1357);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1358);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1359);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1360);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1361);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1362);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1363);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1364);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1365);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1366);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1367);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1368);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1369);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1370);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1371);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1372);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1373);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1374);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1375);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1376);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1377);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1378);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1379);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1380);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1381);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1382);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1383);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1384);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1385);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1386);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1387);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1388);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1389);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1390);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1391);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1392);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1393);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1394);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1395);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1396);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1397);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1398);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1399);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1400);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1401);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1402);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1403);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1404);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1405);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1406);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1407);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1408);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1409);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1410);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1411);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1412);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1413);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1414);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1415);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1416);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1417);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1418);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1419);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1420);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1421);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1422);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1423);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1424);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1425);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1426);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1427);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1428);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1429);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1430);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1431);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1432);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1433);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1434);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1435);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1436);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1437);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1438);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1439);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1440);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1441);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1442);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1443);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1444);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1445);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1446);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1447);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1448);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1449);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1450);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1451);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1452);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1453);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1454);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1455);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1456);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1457);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1458);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1459);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1460);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1461);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1462);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1463);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1464);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1465);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1466);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1467);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1468);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1469);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1470);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1471);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1472);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1473);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1474);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1475);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1476);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1477);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1478);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1479);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1480);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1481);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1482);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1483);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1484);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1485);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1486);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1487);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1488);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1489);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1490);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1491);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1492);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1493);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1494);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1495);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1496);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1497);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1498);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1499);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1500);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1501);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1502);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1503);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1504);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1505);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1506);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1507);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1508);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1509);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1510);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1511);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1512);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1513);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1514);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1515);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1516);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1517);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1518);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1519);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1520);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1521);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1522);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1523);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1524);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1525);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1526);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1527);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1528);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1529);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1530);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1531);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1532);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1533);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1534);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1535);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1536);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1537);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1538);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1539);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1540);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1541);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1542);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1543);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1544);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1545);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1546);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1547);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1548);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1549);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1550);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1551);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1552);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1553);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1554);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1555);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1556);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1557);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1558);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1559);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1560);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1561);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1562);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1563);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1564);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1565);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1566);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1567);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1568);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1569);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1570);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1571);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1572);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1573);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1574);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1575);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1576);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1577);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1578);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1579);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1580);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1581);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1582);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1583);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1584);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1585);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1586);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1587);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1588);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1589);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1590);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1591);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1592);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1593);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1594);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1595);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1596);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1597);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1598);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1599);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1600);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1601);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1602);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1603);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1604);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1605);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1606);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1607);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1608);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1609);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1610);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1611);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1612);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1613);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1614);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1615);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1616);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1617);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1618);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1619);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1620);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1621);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1622);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1623);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1624);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1625);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1626);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1627);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1628);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1629);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1630);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1631);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1632);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1633);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1634);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1635);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1636);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1637);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1638);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1639);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1640);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1641);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1642);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1643);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1644);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1645);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1646);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1647);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1648);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1649);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1650);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1651);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1652);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1653);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1654);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1655);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1656);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1657);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1658);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1659);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1660);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1661);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1662);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1663);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1664);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1665);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1666);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1667);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1668);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1669);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1670);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1671);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1672);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1673);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1674);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1675);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1676);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1677);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1678);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1679);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1680);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1681);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1682);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1683);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1684);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1685);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1686);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1687);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1688);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1689);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1690);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1691);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1692);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1693);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1694);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1695);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1696);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1697);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1698);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1699);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1700);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1701);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1702);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1703);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1704);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1705);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1706);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1707);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1708);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1709);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1710);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1711);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1712);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1713);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1714);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1715);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1716);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1717);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1718);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1719);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1720);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1721);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1722);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1723);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1724);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1725);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1726);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1727);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1728);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1729);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1730);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1731);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1732);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1733);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1734);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1735);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1736);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1737);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1738);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1739);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1740);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1741);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1742);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1743);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1744);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1745);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1746);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1747);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1748);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1749);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1750);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1751);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1752);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1753);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1754);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1755);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1756);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1757);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1758);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1759);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1760);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1761);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1762);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1763);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1764);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1765);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1766);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1767);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1768);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1769);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1770);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1771);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1772);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1773);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1774);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1775);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1776);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1777);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1778);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1779);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1780);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1781);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1782);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1783);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1784);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1785);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1786);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1787);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1788);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1789);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1790);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1791);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1792);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1793);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1794);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1795);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1796);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1797);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1798);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1799);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1800);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1801);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1802);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1803);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1804);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1805);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1806);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1807);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1808);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1809);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1810);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1811);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1812);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1813);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1814);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1815);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1816);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1817);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1818);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1819);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1820);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1821);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1822);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1823);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1824);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1825);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1826);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1827);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1828);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1829);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1830);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1831);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1832);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1833);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1834);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1835);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1836);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1837);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1838);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1839);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1840);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1841);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1842);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1843);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1844);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1845);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1846);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1847);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1848);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1849);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1850);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1851);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1852);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1853);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1854);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1855);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1856);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1857);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1858);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1859);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1860);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1861);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1862);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1863);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1864);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1865);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1866);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1867);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1868);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1869);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1870);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1871);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1872);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1873);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1874);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1875);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1876);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1877);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1878);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1879);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1880);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1881);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1882);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1883);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1884);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1885);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1886);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1887);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1888);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1889);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1890);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1891);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1892);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1893);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1894);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1895);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1896);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1897);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1898);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1899);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1900);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1901);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1902);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1903);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1904);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1905);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1906);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1907);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1908);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1909);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1910);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1911);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1912);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1913);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1914);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1915);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1916);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1917);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1918);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1919);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1920);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1921);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1922);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1923);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1924);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1925);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1926);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1927);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1928);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1929);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1930);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1931);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1932);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1933);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1934);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1935);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1936);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1937);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1938);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1939);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1940);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1941);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1942);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1943);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1944);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1945);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1946);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1947);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1948);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1949);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1950);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1951);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1952);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1953);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1954);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1955);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1956);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1957);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1958);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1959);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1960);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1961);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1962);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1963);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1964);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1965);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1966);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1967);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1968);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1969);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1970);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1971);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1972);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1973);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1974);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1975);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1976);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1977);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1978);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1979);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1980);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1981);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1982);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1983);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1984);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1985);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1986);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1987);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1988);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1989);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1990);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1991);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1992);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1993);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1994);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1995);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1996);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1997);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1998);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_1999);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2000);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2001);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2002);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2003);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2004);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2005);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2006);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2007);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2008);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2009);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2010);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2011);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2012);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2013);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2014);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2015);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2016);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2017);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2018);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2019);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2020);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2021);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2022);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2023);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2024);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2025);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2026);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2027);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2028);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2029);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2030);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2031);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2032);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2033);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2034);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2035);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2036);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2037);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2038);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2039);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2040);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2041);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2042);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2043);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2044);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2045);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2046);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2047);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2048);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2049);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2050);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2051);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2052);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2053);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2054);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2055);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2056);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2057);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2058);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2059);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2060);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2061);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2062);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2063);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2064);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2065);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2066);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2067);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2068);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2069);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2070);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2071);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2072);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2073);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2074);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2075);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2076);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2077);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2078);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2079);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2080);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2081);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2082);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2083);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2084);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2085);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2086);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2087);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2088);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2089);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2090);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2091);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2092);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2093);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2094);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2095);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2096);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2097);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2098);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2099);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2100);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2101);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2102);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2103);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2104);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2105);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2106);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2107);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2108);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2109);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2110);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2111);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2112);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2113);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2114);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2115);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2116);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2117);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2118);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2119);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2120);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2121);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2122);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2123);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2124);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2125);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2126);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2127);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2128);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2129);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2130);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2131);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2132);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2133);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2134);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2135);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2136);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2137);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2138);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2139);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2140);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2141);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2142);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2143);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2144);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2145);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2146);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2147);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2148);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2149);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2150);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2151);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2152);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2153);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2154);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2155);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2156);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2157);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2158);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2159);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2160);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2161);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2162);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2163);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2164);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2165);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2166);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2167);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2168);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2169);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2170);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2171);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2172);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2173);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2174);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2175);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2176);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2177);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2178);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2179);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2180);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2181);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2182);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2183);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2184);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2185);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2186);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2187);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2188);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2189);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2190);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2191);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2192);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2193);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2194);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2195);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2196);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2197);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2198);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2199);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2200);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2201);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2202);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2203);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2204);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2205);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2206);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2207);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2208);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2209);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2210);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2211);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2212);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2213);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2214);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2215);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2216);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2217);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2218);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2219);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2220);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2221);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2222);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2223);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2224);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2225);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2226);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2227);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2228);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2229);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2230);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2231);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2232);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2233);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2234);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2235);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2236);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2237);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2238);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2239);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2240);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2241);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2242);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2243);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2244);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2245);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2246);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2247);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2248);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2249);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2250);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2251);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2252);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2253);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2254);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2255);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2256);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2257);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2258);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2259);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2260);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2261);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2262);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2263);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2264);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2265);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2266);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2267);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2268);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2269);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2270);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2271);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2272);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2273);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2274);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2275);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2276);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2277);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2278);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2279);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2280);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2281);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2282);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2283);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2284);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2285);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2286);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2287);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2288);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2289);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2290);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2291);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2292);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2293);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2294);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2295);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2296);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2297);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2298);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2299);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2300);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2301);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2302);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2303);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2304);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2305);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2306);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2307);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2308);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2309);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2310);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2311);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2312);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2313);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2314);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2315);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2316);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2317);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2318);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2319);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2320);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2321);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2322);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2323);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2324);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2325);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2326);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2327);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2328);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2329);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2330);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2331);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2332);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2333);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2334);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2335);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2336);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2337);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2338);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2339);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2340);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2341);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2342);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2343);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2344);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2345);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2346);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2347);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2348);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2349);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2350);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2351);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2352);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2353);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2354);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2355);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2356);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2357);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2358);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2359);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2360);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2361);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2362);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2363);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2364);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2365);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2366);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2367);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2368);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2369);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2370);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2371);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2372);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2373);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2374);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2375);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2376);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2377);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2378);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2379);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2380);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2381);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2382);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2383);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2384);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2385);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2386);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2387);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2388);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2389);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2390);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2391);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2392);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2393);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2394);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2395);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2396);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2397);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2398);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2399);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2400);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2401);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2402);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2403);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2404);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2405);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2406);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2407);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2408);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2409);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2410);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2411);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2412);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2413);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2414);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2415);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2416);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2417);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2418);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2419);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2420);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2421);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2422);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2423);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2424);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2425);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2426);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2427);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2428);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2429);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2430);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2431);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2432);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2433);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2434);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2435);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2436);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2437);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2438);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2439);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2440);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2441);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2442);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2443);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2444);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2445);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2446);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2447);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2448);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2449);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2450);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2451);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2452);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2453);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2454);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2455);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2456);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2457);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2458);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2459);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2460);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2461);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2462);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2463);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2464);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2465);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2466);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2467);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2468);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2469);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2470);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2471);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2472);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2473);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2474);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2475);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2476);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2477);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2478);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2479);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2480);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2481);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2482);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2483);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2484);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2485);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2486);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2487);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2488);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2489);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2490);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2491);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2492);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2493);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2494);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2495);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2496);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2497);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2498);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2499);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2500);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2501);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2502);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2503);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2504);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2505);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2506);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2507);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2508);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2509);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2510);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2511);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2512);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2513);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2514);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2515);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2516);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2517);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2518);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2519);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2520);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2521);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2522);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2523);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2524);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2525);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2526);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2527);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2528);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2529);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2530);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2531);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2532);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2533);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2534);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2535);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2536);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2537);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2538);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2539);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2540);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2541);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2542);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2543);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2544);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2545);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2546);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2547);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2548);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2549);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2550);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2551);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2552);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2553);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2554);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2555);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2556);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2557);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2558);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2559);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2560);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2561);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2562);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2563);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2564);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2565);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2566);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2567);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2568);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2569);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2570);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2571);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2572);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2573);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2574);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2575);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2576);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2577);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2578);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2579);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2580);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2581);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2582);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2583);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2584);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2585);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2586);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2587);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2588);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2589);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2590);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2591);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2592);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2593);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2594);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2595);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2596);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2597);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2598);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2599);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2600);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2601);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2602);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2603);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2604);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2605);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2606);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2607);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2608);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2609);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2610);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2611);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2612);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2613);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2614);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2615);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2616);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2617);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2618);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2619);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2620);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2621);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2622);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2623);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2624);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2625);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2626);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2627);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2628);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2629);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2630);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2631);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2632);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2633);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2634);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2635);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2636);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2637);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2638);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2639);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2640);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2641);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2642);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2643);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2644);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2645);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2646);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2647);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2648);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2649);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2650);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2651);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2652);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2653);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2654);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2655);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2656);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2657);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2658);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2659);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2660);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2661);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2662);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2663);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2664);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2665);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2666);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2667);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2668);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2669);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2670);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2671);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2672);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2673);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2674);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2675);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2676);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2677);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2678);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2679);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2680);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2681);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2682);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2683);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2684);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2685);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2686);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2687);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2688);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2689);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2690);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2691);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2692);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2693);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2694);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2695);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2696);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2697);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2698);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2699);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2700);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2701);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2702);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2703);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2704);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2705);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2706);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2707);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2708);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2709);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2710);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2711);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2712);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2713);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2714);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2715);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2716);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2717);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2718);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2719);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2720);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2721);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2722);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2723);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2724);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2725);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2726);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2727);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2728);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2729);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2730);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2731);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2732);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2733);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2734);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2735);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2736);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2737);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2738);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2739);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2740);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2741);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2742);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2743);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2744);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2745);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2746);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2747);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2748);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2749);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2750);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2751);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2752);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2753);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2754);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2755);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2756);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2757);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2758);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2759);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2760);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2761);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2762);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2763);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2764);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2765);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2766);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2767);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2768);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2769);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2770);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2771);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2772);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2773);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2774);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2775);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2776);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2777);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2778);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2779);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2780);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2781);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2782);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2783);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2784);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2785);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2786);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2787);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2788);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2789);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2790);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2791);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2792);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2793);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2794);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2795);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2796);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2797);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2798);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2799);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2800);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2801);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2802);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2803);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2804);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2805);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2806);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2807);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2808);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2809);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2810);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2811);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2812);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2813);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2814);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2815);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2816);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2817);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2818);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2819);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2820);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2821);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2822);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2823);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2824);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2825);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2826);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2827);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2828);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2829);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2830);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2831);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2832);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2833);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2834);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2835);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2836);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2837);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2838);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2839);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2840);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2841);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2842);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2843);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2844);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2845);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2846);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2847);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2848);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2849);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2850);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2851);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2852);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2853);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2854);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2855);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2856);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2857);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2858);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2859);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2860);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2861);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2862);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2863);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2864);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2865);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2866);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2867);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2868);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2869);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2870);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2871);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2872);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2873);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2874);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2875);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2876);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2877);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2878);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2879);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2880);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2881);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2882);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2883);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2884);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2885);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2886);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2887);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2888);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2889);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2890);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2891);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2892);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2893);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2894);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2895);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2896);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2897);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2898);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2899);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2900);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2901);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2902);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2903);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2904);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2905);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2906);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2907);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2908);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2909);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2910);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2911);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2912);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2913);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2914);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2915);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2916);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2917);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2918);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2919);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2920);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2921);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2922);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2923);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2924);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2925);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2926);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2927);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2928);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2929);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2930);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2931);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2932);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2933);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2934);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2935);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2936);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2937);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2938);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2939);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2940);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2941);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2942);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2943);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2944);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2945);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2946);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2947);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2948);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2949);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2950);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2951);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2952);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2953);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2954);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2955);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2956);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2957);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2958);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2959);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2960);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2961);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2962);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2963);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2964);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2965);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2966);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2967);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2968);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2969);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2970);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2971);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2972);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2973);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2974);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2975);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2976);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2977);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2978);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2979);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2980);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2981);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2982);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2983);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2984);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2985);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2986);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2987);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2988);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2989);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2990);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2991);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2992);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2993);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2994);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2995);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2996);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2997);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2998);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_2999);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3000);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3001);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3002);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3003);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3004);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3005);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3006);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3007);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3008);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3009);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3010);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3011);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3012);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3013);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3014);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3015);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3016);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3017);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3018);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3019);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3020);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3021);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3022);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3023);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3024);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3025);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3026);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3027);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3028);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3029);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3030);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3031);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3032);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3033);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3034);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3035);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3036);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3037);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3038);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3039);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3040);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3041);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3042);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3043);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3044);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3045);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3046);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3047);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3048);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3049);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3050);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3051);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3052);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3053);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3054);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3055);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3056);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3057);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3058);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3059);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3060);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3061);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3062);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3063);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3064);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3065);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3066);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3067);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3068);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3069);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3070);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3071);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3072);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3073);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3074);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3075);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3076);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3077);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3078);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3079);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3080);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3081);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3082);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3083);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3084);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3085);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3086);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3087);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3088);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3089);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3090);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3091);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3092);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3093);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3094);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3095);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3096);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3097);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3098);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3099);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3100);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3101);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3102);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3103);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3104);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3105);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3106);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3107);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3108);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3109);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3110);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3111);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3112);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3113);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3114);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3115);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3116);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3117);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3118);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3119);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3120);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3121);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3122);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3123);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3124);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3125);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3126);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3127);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3128);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3129);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3130);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3131);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3132);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3133);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3134);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3135);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3136);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3137);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3138);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3139);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3140);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3141);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3142);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3143);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3144);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3145);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3146);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3147);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3148);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3149);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3150);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3151);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3152);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3153);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3154);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3155);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3156);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3157);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3158);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3159);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3160);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3161);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3162);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3163);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3164);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3165);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3166);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3167);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3168);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3169);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3170);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3171);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3172);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3173);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3174);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3175);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3176);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3177);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3178);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3179);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3180);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3181);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3182);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3183);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3184);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3185);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3186);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3187);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3188);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3189);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3190);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3191);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3192);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3193);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3194);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3195);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3196);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3197);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3198);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3199);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3200);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3201);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3202);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3203);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3204);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3205);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3206);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3207);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3208);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3209);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3210);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3211);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3212);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3213);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3214);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3215);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3216);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3217);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3218);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3219);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3220);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3221);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3222);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3223);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3224);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3225);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3226);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3227);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3228);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3229);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3230);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3231);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3232);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3233);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3234);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3235);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3236);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3237);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3238);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3239);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3240);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3241);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3242);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3243);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3244);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3245);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3246);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3247);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3248);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3249);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3250);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3251);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3252);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3253);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3254);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3255);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3256);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3257);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3258);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3259);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3260);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3261);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3262);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3263);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3264);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3265);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3266);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3267);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3268);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3269);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3270);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3271);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3272);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3273);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3274);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3275);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3276);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3277);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3278);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3279);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3280);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3281);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3282);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3283);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3284);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3285);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3286);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3287);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3288);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3289);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3290);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3291);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3292);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3293);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3294);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3295);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3296);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3297);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3298);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3299);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3300);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3301);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3302);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3303);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3304);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3305);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3306);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3307);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3308);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3309);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3310);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3311);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3312);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3313);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3314);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3315);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3316);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3317);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3318);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3319);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3320);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3321);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3322);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3323);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3324);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3325);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3326);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3327);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3328);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3329);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3330);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3331);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3332);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3333);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3334);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3335);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3336);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3337);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3338);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3339);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3340);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3341);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3342);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3343);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3344);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3345);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3346);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3347);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3348);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3349);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3350);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3351);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3352);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3353);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3354);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3355);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3356);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3357);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3358);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3359);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3360);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3361);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3362);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3363);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3364);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3365);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3366);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3367);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3368);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3369);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3370);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3371);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3372);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3373);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3374);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3375);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3376);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3377);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3378);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3379);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3380);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3381);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3382);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3383);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3384);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3385);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3386);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3387);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3388);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3389);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3390);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3391);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3392);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3393);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3394);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3395);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3396);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3397);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3398);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3399);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3400);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3401);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3402);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3403);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3404);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3405);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3406);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3407);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3408);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3409);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3410);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3411);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3412);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3413);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3414);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3415);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3416);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3417);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3418);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3419);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3420);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3421);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3422);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3423);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3424);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3425);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3426);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3427);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3428);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3429);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3430);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3431);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3432);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3433);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3434);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3435);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3436);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3437);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3438);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3439);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3440);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3441);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3442);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3443);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3444);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3445);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3446);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3447);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3448);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3449);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3450);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3451);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3452);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3453);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3454);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3455);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3456);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3457);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3458);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3459);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3460);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3461);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3462);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3463);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3464);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3465);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3466);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3467);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3468);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3469);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3470);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3471);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3472);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3473);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3474);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3475);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3476);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3477);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3478);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3479);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3480);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3481);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3482);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3483);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3484);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3485);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3486);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3487);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3488);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3489);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3490);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3491);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3492);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3493);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3494);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3495);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3496);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3497);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3498);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3499);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3500);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3501);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3502);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3503);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3504);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3505);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3506);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3507);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3508);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3509);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3510);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3511);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3512);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3513);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3514);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3515);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3516);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3517);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3518);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3519);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3520);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3521);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3522);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3523);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3524);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3525);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3526);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3527);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3528);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3529);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3530);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3531);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3532);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3533);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3534);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3535);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3536);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3537);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3538);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3539);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3540);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3541);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3542);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3543);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3544);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3545);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3546);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3547);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3548);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3549);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3550);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3551);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3552);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3553);
        main_exec_generated_fast_labels.push_back(&&main_exec_generated_fast_rom_line_3554);
    }

main_exec_generated_fast_rom_line_0: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSTEP*STEP, where inSTEP=1
    op0 = i;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 2 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_4: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 4 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_5: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_6: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 6 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_7: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_8: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_9: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_10: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 10 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_11: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 11 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_12: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 12 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_13: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 13 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_14: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(8))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 14 << endl;
        exit(-1);
    }
    addrRel += 8;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_15: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 15 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_16: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 16 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_17: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 17 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_18: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 18 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_19: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_20: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 20 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_21: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 21 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_22: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_23: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 23 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_24: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_25: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_26: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_27: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_28: //        ${eventLog(onStartBatch, C)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_29: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_30: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_31: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 31 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_32: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_33: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_34: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 34 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_35: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 35 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_36: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_37: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 37 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_38: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_39: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_40: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_41: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_42: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_43: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_44: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 44 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_45: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_46: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 46 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_47: //        0                                   :MSTORE(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 47 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_48: //        E                                   :MSTORE(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 48 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_49: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 49 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_50: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 50 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_51: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 51 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_52: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 52 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_53: //        A+1 => CTX      :MSTORE(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 53 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_54: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 54 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_55: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 55 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_56: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(107))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 56 << endl;
        exit(-1);
    }
    addrRel += 107;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_57: //                        :JMP(endCheckRLP)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(58))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 57 << endl;
        exit(-1);
    }
    addrRel += 58;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_58: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(59))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 58 << endl;
        exit(-1);
    }
    addrRel += 59;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_59: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 59 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_60: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 60 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_61: //        A               :JMPN(processTxsEnd)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(67))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 61 << endl;
        exit(-1);
    }
    addrRel += 67;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_62: //        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 62 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_63: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 63 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_64: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(844))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 64 << endl;
        exit(-1);
    }
    addrRel += 844;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_65: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_66: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(59))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 66 << endl;
        exit(-1);
    }
    addrRel += 59;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_67: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_68: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_69: //        %LOCAL_EXIT_ROOT_STORAGE_POS => C                         ; Storage position of the local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_70: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_71: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 71 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 71 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_72: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 72 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_73: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 73 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 73 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_74: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_75: //        $ => E                          :MLOAD(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 75 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_76: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_77: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 77 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_78: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_79: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_80: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 80 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_81: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_82: //        20 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_83: //        $ => A                          :MLOAD(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 83 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_84: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_85: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_86: //        $ => A                          :MLOAD(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(8))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 86 << endl;
        exit(-1);
    }
    addrRel += 8;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_87: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_88: //        $ => A                          :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 88 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_89: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_90: //        HASHPOS                         :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_91: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 91 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_92: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 92 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_93: //        $ => HASHPOS                    :MLOAD(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 93 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_94: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_95: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_96: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 96 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_97: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_98: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 98 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_99: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_100: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_101: //        $ => A                          :MLOAD(globalHash)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_102: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 102 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_103: //        ${eventLog(onFinishBatch)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_104: //        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op
    SP = fe2n(fr, op0); // If setSP, SP'=op
    PC = fe2n(fr, op0); // If setPC, PC'=op
    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_105: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(105))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 105 << endl;
        exit(-1);
    }
    addrRel += 105;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_106: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_107: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_108: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 108 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_109: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 109 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_110: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_111: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_112: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 113;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 112 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_113: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 114;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 113 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_114: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(192));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 114 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_115: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(248));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(120))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 115 << endl;
        exit(-1);
    }
    addrRel += 120;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_116: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(247));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_117: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 118;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 117 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_118: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 119;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 118 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_119: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(121))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 119 << endl;
        exit(-1);
    }
    addrRel += 121;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_120: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(192));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_121: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 121 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_122: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_123: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 124;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 123 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_124: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 125;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 124 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_125: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 125 << endl;
        exit(-1);
    }
    addrRel += 136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_126: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(129))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 126 << endl;
        exit(-1);
    }
    addrRel += 129;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_127: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(137));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(132))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 127 << endl;
        exit(-1);
    }
    addrRel += 132;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_128: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 128 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_129: //        ${eventLog(onStartBatch, C)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 129 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_130: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_131: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 131 << endl;
        exit(-1);
    }
    addrRel += 136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_132: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_133: //        

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 133 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_134: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 135;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 134 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_135: //;; Set global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 136;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 135 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_136: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 136 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_137: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_138: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 139;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 138 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_139: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 140;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 139 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_140: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(150))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 140 << endl;
        exit(-1);
    }
    addrRel += 150;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_141: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(144))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 141 << endl;
        exit(-1);
    }
    addrRel += 144;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_142: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(161));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 142 << endl;
        exit(-1);
    }
    addrRel += 146;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_143: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 143 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_144: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_145: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(150))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 145 << endl;
        exit(-1);
    }
    addrRel += 150;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_146: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_147: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(150))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 147 << endl;
        exit(-1);
    }
    addrRel += 150;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_148: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 149;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 148 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_149: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 150;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 149 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_150: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 150 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_151: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_152: //endCheckRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 153;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 152 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_153: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 154;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 153 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_154: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(163))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 154 << endl;
        exit(-1);
    }
    addrRel += 163;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_155: //txLoop:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(158))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 155 << endl;
        exit(-1);
    }
    addrRel += 158;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_156: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(161));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(159))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 156 << endl;
        exit(-1);
    }
    addrRel += 159;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_157: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 157 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_158: //        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(163))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 158 << endl;
        exit(-1);
    }
    addrRel += 163;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_159: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_160: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(163))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 160 << endl;
        exit(-1);
    }
    addrRel += 163;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_161: //processTxEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 162;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 161 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_162: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 163;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 162 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_163: //processTxsEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_164: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_165: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 166;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 165 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_166: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 167;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 166 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_167: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 167 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_168: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(172))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 168 << endl;
        exit(-1);
    }
    addrRel += 172;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_169: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(148));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 169 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_170: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(149));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(174))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 170 << endl;
        exit(-1);
    }
    addrRel += 174;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_171: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 171 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_172: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 172 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_173: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(179))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 173 << endl;
        exit(-1);
    }
    addrRel += 179;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_174: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_175: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 176;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 175 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_176: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 177;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 176 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_177: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 177 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_178: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 178 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_179: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_180: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 181;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 180 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_181: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 182;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 181 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_182: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 182 << endl;
        exit(-1);
    }
    addrRel += 192;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_183: //; Check Global Hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(186))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 183 << endl;
        exit(-1);
    }
    addrRel += 186;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_184: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(161));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(188))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 184 << endl;
        exit(-1);
    }
    addrRel += 188;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_185: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 185 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_186: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_187: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 187 << endl;
        exit(-1);
    }
    addrRel += 192;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_188: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_189: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 189 << endl;
        exit(-1);
    }
    addrRel += 192;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_190: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 191;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 190 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_191: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 192;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 191 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_192: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 192 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_193: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_194: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_195: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 196;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 195 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_196: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 197;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 196 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_197: //INCLUDE "process_tx.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(202))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 197 << endl;
        exit(-1);
    }
    addrRel += 202;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_198: //INCLUDE "opcodes.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 198 << endl;
        exit(-1);
    }
    addrRel += 228;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_199: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(184));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(207))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 199 << endl;
        exit(-1);
    }
    addrRel += 207;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_200: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(192));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 200 << endl;
        exit(-1);
    }
    addrRel += 209;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_201: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 201 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_202: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 202 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_203: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 31;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_204: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 205;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 204 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_205: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_206: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 206 << endl;
        exit(-1);
    }
    addrRel += 228;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_207: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 207 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_208: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(213))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 208 << endl;
        exit(-1);
    }
    addrRel += 213;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_209: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(183));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_210: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 211;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 210 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_211: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 212;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 211 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_212: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 212 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_213: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_214: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(221))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 214 << endl;
        exit(-1);
    }
    addrRel += 221;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_215: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 215 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_216: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 217;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 216 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_217: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 218;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 217 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_218: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_219: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 219 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_220: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(213))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 220 << endl;
        exit(-1);
    }
    addrRel += 213;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_221: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 221 << endl;
        exit(-1);
    }
    addrRel += 228;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_222: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_223: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 224;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 223 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_224: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 225;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 224 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_225: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_226: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 227;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 226 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_227: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_228: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_229: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 230;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 229 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_230: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 231;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 230 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_231: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(241))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 231 << endl;
        exit(-1);
    }
    addrRel += 241;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_232: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(235))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 232 << endl;
        exit(-1);
    }
    addrRel += 235;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_233: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(137));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(237))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 233 << endl;
        exit(-1);
    }
    addrRel += 237;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_234: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 234 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_235: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_236: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(241))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 236 << endl;
        exit(-1);
    }
    addrRel += 241;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_237: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_238: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(241))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 238 << endl;
        exit(-1);
    }
    addrRel += 241;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_239: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 240;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 239 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_240: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 241;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 240 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_241: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(11))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 241 << endl;
        exit(-1);
    }
    addrRel += 11;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_242: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_243: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 244;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 243 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_244: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 245;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 244 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_245: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32896;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_246: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(248))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 246 << endl;
        exit(-1);
    }
    addrRel += 248;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_247: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 247 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_248: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_249: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 249 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_250: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 250 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_251: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 251 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_252: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_253: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_254: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(281))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 254 << endl;
        exit(-1);
    }
    addrRel += 281;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_255: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 255 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_256: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_257: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 258;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 257 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_258: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_259: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 260;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(281))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 259 << endl;
        exit(-1);
    }
    addrRel += 281;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_260: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 260 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_261: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_262: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 263;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 262 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_263: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_264: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 265;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(281))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 264 << endl;
        exit(-1);
    }
    addrRel += 281;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_265: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 265 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_266: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_267: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 268;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 267 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_268: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 268 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_269: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 269 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_270: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 270 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_271: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 271 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_272: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 272 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_273: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(52))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 273 << endl;
        exit(-1);
    }
    addrRel += 52;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_274: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 274 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_275: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 275 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_276: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_277: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 277 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_278: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_279: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 279 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_280: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_281: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 281 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_282: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 282 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_283: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 283 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_284: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_285: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_286: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 286 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_287: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 287 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_288: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 288 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_289: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_290: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_291: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_292: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_293: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 293 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_294: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 294 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_295: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 295 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_296: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 296 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_297: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(303))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 297 << endl;
        exit(-1);
    }
    addrRel += 303;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_298: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_299: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_300: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_301: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_302: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(297))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 302 << endl;
        exit(-1);
    }
    addrRel += 297;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_303: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_304: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 304 << endl;
        exit(-1);
    }
    addrRel += 308;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_305: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_306: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_307: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_308: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 308 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_309: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(67))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 309 << endl;
        exit(-1);
    }
    addrRel += 67;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_310: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1595))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 310 << endl;
        exit(-1);
    }
    addrRel += 1595;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_311: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1608))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 311 << endl;
        exit(-1);
    }
    addrRel += 1608;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_312: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1620))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 312 << endl;
        exit(-1);
    }
    addrRel += 1620;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_313: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1632))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 313 << endl;
        exit(-1);
    }
    addrRel += 1632;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_314: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1644))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 314 << endl;
        exit(-1);
    }
    addrRel += 1644;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_315: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1656))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 315 << endl;
        exit(-1);
    }
    addrRel += 1656;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_316: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1689))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 316 << endl;
        exit(-1);
    }
    addrRel += 1689;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_317: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1701))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 317 << endl;
        exit(-1);
    }
    addrRel += 1701;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_318: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1734))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 318 << endl;
        exit(-1);
    }
    addrRel += 1734;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_319: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1751))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 319 << endl;
        exit(-1);
    }
    addrRel += 1751;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_320: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1768))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 320 << endl;
        exit(-1);
    }
    addrRel += 1768;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_321: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1778))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 321 << endl;
        exit(-1);
    }
    addrRel += 1778;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_322: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 322 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_323: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 323 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_324: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 324 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_325: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 325 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_326: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1823))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 326 << endl;
        exit(-1);
    }
    addrRel += 1823;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_327: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1839))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 327 << endl;
        exit(-1);
    }
    addrRel += 1839;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_328: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1815))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 328 << endl;
        exit(-1);
    }
    addrRel += 1815;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_329: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1831))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 329 << endl;
        exit(-1);
    }
    addrRel += 1831;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_330: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1847))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 330 << endl;
        exit(-1);
    }
    addrRel += 1847;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_331: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1855))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 331 << endl;
        exit(-1);
    }
    addrRel += 1855;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_332: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1862))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 332 << endl;
        exit(-1);
    }
    addrRel += 1862;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_333: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1870))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 333 << endl;
        exit(-1);
    }
    addrRel += 1870;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_334: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1878))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 334 << endl;
        exit(-1);
    }
    addrRel += 1878;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_335: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1886))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 335 << endl;
        exit(-1);
    }
    addrRel += 1886;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_336: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1893))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 336 << endl;
        exit(-1);
    }
    addrRel += 1893;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_337: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1913))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 337 << endl;
        exit(-1);
    }
    addrRel += 1913;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_338: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1904))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 338 << endl;
        exit(-1);
    }
    addrRel += 1904;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_339: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1922))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 339 << endl;
        exit(-1);
    }
    addrRel += 1922;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_340: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 340 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_341: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 341 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_342: //;; Set batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1954))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 342 << endl;
        exit(-1);
    }
    addrRel += 1954;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_343: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 343 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_344: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 344 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_345: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 345 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_346: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 346 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_347: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 347 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_348: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 348 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_349: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 349 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_350: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 350 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_351: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 351 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_352: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 352 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_353: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 353 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_354: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 354 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_355: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 355 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_356: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 356 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_357: //        ${eventLog(onStartBatch, C)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 357 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_358: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1998))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 358 << endl;
        exit(-1);
    }
    addrRel += 1998;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_359: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2007))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 359 << endl;
        exit(-1);
    }
    addrRel += 2007;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_360: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2016))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 360 << endl;
        exit(-1);
    }
    addrRel += 2016;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_361: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2021))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 361 << endl;
        exit(-1);
    }
    addrRel += 2021;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_362: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2026))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 362 << endl;
        exit(-1);
    }
    addrRel += 2026;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_363: //        

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2031))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 363 << endl;
        exit(-1);
    }
    addrRel += 2031;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_364: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2061))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 364 << endl;
        exit(-1);
    }
    addrRel += 2061;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_365: //;; Set global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2066))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 365 << endl;
        exit(-1);
    }
    addrRel += 2066;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_366: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2129))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 366 << endl;
        exit(-1);
    }
    addrRel += 2129;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_367: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2145))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 367 << endl;
        exit(-1);
    }
    addrRel += 2145;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_368: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2176))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 368 << endl;
        exit(-1);
    }
    addrRel += 2176;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_369: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2181))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 369 << endl;
        exit(-1);
    }
    addrRel += 2181;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_370: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 370 << endl;
        exit(-1);
    }
    addrRel += 2192;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_371: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2222))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 371 << endl;
        exit(-1);
    }
    addrRel += 2222;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_372: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 372 << endl;
        exit(-1);
    }
    addrRel += 2227;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_373: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2267))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 373 << endl;
        exit(-1);
    }
    addrRel += 2267;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_374: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 374 << endl;
        exit(-1);
    }
    addrRel += 2293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_375: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2315))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 375 << endl;
        exit(-1);
    }
    addrRel += 2315;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_376: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2320))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 376 << endl;
        exit(-1);
    }
    addrRel += 2320;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_377: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2325))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 377 << endl;
        exit(-1);
    }
    addrRel += 2325;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_378: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2330))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 378 << endl;
        exit(-1);
    }
    addrRel += 2330;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_379: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2335))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 379 << endl;
        exit(-1);
    }
    addrRel += 2335;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_380: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 380 << endl;
        exit(-1);
    }
    addrRel += 2340;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_381: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2345))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 381 << endl;
        exit(-1);
    }
    addrRel += 2345;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_382: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 382 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_383: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 383 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_384: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 384 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_385: //;; Prepare transaction loop

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 385 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_386: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 386 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_387: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 387 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_388: //        0                                   :MSTORE(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 388 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_389: //        E                                   :MSTORE(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 389 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_390: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2352))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 390 << endl;
        exit(-1);
    }
    addrRel += 2352;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_391: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2355))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 391 << endl;
        exit(-1);
    }
    addrRel += 2355;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_392: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2364))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 392 << endl;
        exit(-1);
    }
    addrRel += 2364;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_393: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2376))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 393 << endl;
        exit(-1);
    }
    addrRel += 2376;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_394: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2389))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 394 << endl;
        exit(-1);
    }
    addrRel += 2389;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_395: //        $${var p = 0}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2399))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 395 << endl;
        exit(-1);
    }
    addrRel += 2399;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_396: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2486))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 396 << endl;
        exit(-1);
    }
    addrRel += 2486;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_397: //txLoopRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2491))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 397 << endl;
        exit(-1);
    }
    addrRel += 2491;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_398: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2501))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 398 << endl;
        exit(-1);
    }
    addrRel += 2501;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_399: //        A+1 => CTX      :MSTORE(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2505))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 399 << endl;
        exit(-1);
    }
    addrRel += 2505;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_400: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2510))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 400 << endl;
        exit(-1);
    }
    addrRel += 2510;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_401: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2514))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 401 << endl;
        exit(-1);
    }
    addrRel += 2514;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_402: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 402 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_403: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 403 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_404: //                        :JMP(endCheckRLP)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 404 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_405: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 405 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_406: //endCheckRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2554))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 406 << endl;
        exit(-1);
    }
    addrRel += 2554;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_407: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2558))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 407 << endl;
        exit(-1);
    }
    addrRel += 2558;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_408: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2562))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 408 << endl;
        exit(-1);
    }
    addrRel += 2562;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_409: //txLoop:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2566))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 409 << endl;
        exit(-1);
    }
    addrRel += 2566;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_410: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 410 << endl;
        exit(-1);
    }
    addrRel += 2570;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_411: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2574))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 411 << endl;
        exit(-1);
    }
    addrRel += 2574;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_412: //        A               :JMPN(processTxsEnd)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2578))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 412 << endl;
        exit(-1);
    }
    addrRel += 2578;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_413: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 413 << endl;
        exit(-1);
    }
    addrRel += 2582;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_414: //        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2586))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 414 << endl;
        exit(-1);
    }
    addrRel += 2586;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_415: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2590))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 415 << endl;
        exit(-1);
    }
    addrRel += 2590;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_416: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2594))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 416 << endl;
        exit(-1);
    }
    addrRel += 2594;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_417: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2598))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 417 << endl;
        exit(-1);
    }
    addrRel += 2598;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_418: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2602))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 418 << endl;
        exit(-1);
    }
    addrRel += 2602;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_419: //processTxEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2606))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 419 << endl;
        exit(-1);
    }
    addrRel += 2606;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_420: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2610))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 420 << endl;
        exit(-1);
    }
    addrRel += 2610;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_421: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2614))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 421 << endl;
        exit(-1);
    }
    addrRel += 2614;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_422: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2618))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 422 << endl;
        exit(-1);
    }
    addrRel += 2618;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_423: //processTxsEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2622))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 423 << endl;
        exit(-1);
    }
    addrRel += 2622;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_424: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2626))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 424 << endl;
        exit(-1);
    }
    addrRel += 2626;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_425: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2630))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 425 << endl;
        exit(-1);
    }
    addrRel += 2630;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_426: //;; Assert local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2634))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 426 << endl;
        exit(-1);
    }
    addrRel += 2634;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_427: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2638))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 427 << endl;
        exit(-1);
    }
    addrRel += 2638;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_428: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2642))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 428 << endl;
        exit(-1);
    }
    addrRel += 2642;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_429: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2646))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 429 << endl;
        exit(-1);
    }
    addrRel += 2646;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_430: //        %LOCAL_EXIT_ROOT_STORAGE_POS => C                         ; Storage position of the local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2650))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 430 << endl;
        exit(-1);
    }
    addrRel += 2650;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_431: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2654))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 431 << endl;
        exit(-1);
    }
    addrRel += 2654;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_432: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2658))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 432 << endl;
        exit(-1);
    }
    addrRel += 2658;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_433: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2662))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 433 << endl;
        exit(-1);
    }
    addrRel += 2662;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_434: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2666))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 434 << endl;
        exit(-1);
    }
    addrRel += 2666;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_435: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2670))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 435 << endl;
        exit(-1);
    }
    addrRel += 2670;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_436: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2674))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 436 << endl;
        exit(-1);
    }
    addrRel += 2674;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_437: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2678))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 437 << endl;
        exit(-1);
    }
    addrRel += 2678;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_438: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2682))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 438 << endl;
        exit(-1);
    }
    addrRel += 2682;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_439: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2689))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 439 << endl;
        exit(-1);
    }
    addrRel += 2689;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_440: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2696))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 440 << endl;
        exit(-1);
    }
    addrRel += 2696;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_441: //;; Check batchHashData

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2703))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 441 << endl;
        exit(-1);
    }
    addrRel += 2703;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_442: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2710))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 442 << endl;
        exit(-1);
    }
    addrRel += 2710;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_443: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2717))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 443 << endl;
        exit(-1);
    }
    addrRel += 2717;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_444: //        $ => E                          :MLOAD(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2724))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 444 << endl;
        exit(-1);
    }
    addrRel += 2724;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_445: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2731))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 445 << endl;
        exit(-1);
    }
    addrRel += 2731;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_446: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2738))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 446 << endl;
        exit(-1);
    }
    addrRel += 2738;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_447: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2745))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 447 << endl;
        exit(-1);
    }
    addrRel += 2745;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_448: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2752))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 448 << endl;
        exit(-1);
    }
    addrRel += 2752;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_449: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2759))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 449 << endl;
        exit(-1);
    }
    addrRel += 2759;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_450: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2766))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 450 << endl;
        exit(-1);
    }
    addrRel += 2766;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_451: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2773))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 451 << endl;
        exit(-1);
    }
    addrRel += 2773;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_452: //        20 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2780))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 452 << endl;
        exit(-1);
    }
    addrRel += 2780;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_453: //        $ => A                          :MLOAD(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2787))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 453 << endl;
        exit(-1);
    }
    addrRel += 2787;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_454: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2794))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 454 << endl;
        exit(-1);
    }
    addrRel += 2794;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_455: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2804))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 455 << endl;
        exit(-1);
    }
    addrRel += 2804;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_456: //        $ => A                          :MLOAD(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2815))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 456 << endl;
        exit(-1);
    }
    addrRel += 2815;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_457: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2826))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 457 << endl;
        exit(-1);
    }
    addrRel += 2826;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_458: //        $ => A                          :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2837))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 458 << endl;
        exit(-1);
    }
    addrRel += 2837;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_459: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2848))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 459 << endl;
        exit(-1);
    }
    addrRel += 2848;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_460: //        HASHPOS                         :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2859))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 460 << endl;
        exit(-1);
    }
    addrRel += 2859;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_461: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2870))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 461 << endl;
        exit(-1);
    }
    addrRel += 2870;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_462: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2881))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 462 << endl;
        exit(-1);
    }
    addrRel += 2881;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_463: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2892))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 463 << endl;
        exit(-1);
    }
    addrRel += 2892;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_464: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2903))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 464 << endl;
        exit(-1);
    }
    addrRel += 2903;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_465: //; Check Global Hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2914))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 465 << endl;
        exit(-1);
    }
    addrRel += 2914;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_466: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 466 << endl;
        exit(-1);
    }
    addrRel += 2925;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_467: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2936))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 467 << endl;
        exit(-1);
    }
    addrRel += 2936;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_468: //        ; Get position of the previous hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2947))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 468 << endl;
        exit(-1);
    }
    addrRel += 2947;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_469: //        $ => HASHPOS                    :MLOAD(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2958))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 469 << endl;
        exit(-1);
    }
    addrRel += 2958;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_470: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2969))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 470 << endl;
        exit(-1);
    }
    addrRel += 2969;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_471: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2982))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 471 << endl;
        exit(-1);
    }
    addrRel += 2982;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_472: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2995))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 472 << endl;
        exit(-1);
    }
    addrRel += 2995;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_473: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3008))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 473 << endl;
        exit(-1);
    }
    addrRel += 3008;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_474: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3021))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 474 << endl;
        exit(-1);
    }
    addrRel += 3021;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_475: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 475 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_476: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 476 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_477: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 477 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_478: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 478 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_479: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 479 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_480: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 480 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_481: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 481 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_482: //        $ => A                          :MLOAD(globalHash)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 482 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_483: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 483 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_484: //        ${eventLog(onFinishBatch)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 484 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_485: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 485 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_486: //        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 486 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_487: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 487 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_488: //finalWait:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 488 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_489: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 489 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_490: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 490 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_491: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 491 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_492: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 492 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_493: //INCLUDE "process_tx.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 493 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_494: //INCLUDE "opcodes.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 494 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_495: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 495 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_496: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 496 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_497: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 497 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_498: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 498 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_499: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 499 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_500: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 500 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_501: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 501 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_502: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 502 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_503: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 503 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_504: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 504 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_505: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 505 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_506: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 506 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_507: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 507 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_508: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 508 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_509: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 509 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_510: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 510 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_511: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 511 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_512: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 512 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_513: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 513 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_514: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 514 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_515: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 515 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_516: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 516 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_517: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 517 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_518: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 518 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_519: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 519 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_520: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 520 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_521: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 521 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_522: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 522 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_523: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 523 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_524: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 524 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_525: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 525 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_526: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 526 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_527: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 527 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_528: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 528 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_529: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 529 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_530: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 530 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_531: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 531 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_532: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 532 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_533: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 533 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_534: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 534 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_535: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 535 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_536: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 536 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_537: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 537 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_538: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 538 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_539: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 539 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_540: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 540 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_541: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 541 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_542: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 542 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_543: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 543 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_544: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 544 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_545: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 545 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_546: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 546 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_547: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 547 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_548: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 548 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_549: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 549 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_550: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 550 << endl;
        exit(-1);
    }
    addrRel += 3054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_551: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3103))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 551 << endl;
        exit(-1);
    }
    addrRel += 3103;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_552: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3166))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 552 << endl;
        exit(-1);
    }
    addrRel += 3166;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_553: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 553 << endl;
        exit(-1);
    }
    addrRel += 3227;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_554: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3330))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 554 << endl;
        exit(-1);
    }
    addrRel += 3330;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_555: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3386))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 555 << endl;
        exit(-1);
    }
    addrRel += 3386;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_556: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 556 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_557: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 557 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_558: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 558 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_559: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 559 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_560: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3438))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 560 << endl;
        exit(-1);
    }
    addrRel += 3438;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_561: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 561 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_562: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 562 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_563: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3493))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 563 << endl;
        exit(-1);
    }
    addrRel += 3493;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_564: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 564 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_565: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3509))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 565 << endl;
        exit(-1);
    }
    addrRel += 3509;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_566: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 566 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_567: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_568: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_569: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_570: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 27;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_571: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(588))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 571 << endl;
        exit(-1);
    }
    addrRel += 588;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_572: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_573: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 28;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_574: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(588))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 574 << endl;
        exit(-1);
    }
    addrRel += 588;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_575: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_576: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_577: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_578: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_579: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_580: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_581: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_582: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(588))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 582 << endl;
        exit(-1);
    }
    addrRel += 588;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_583: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 583 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_584: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 584 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_585: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 585 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_586: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 587;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 586 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_587: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 587 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_588: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 588 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_589: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 589 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_590: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 590 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_591: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(60));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 591 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_592: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 592 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_593: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_594: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(604))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 594 << endl;
        exit(-1);
    }
    addrRel += 604;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_595: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(600))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 595 << endl;
        exit(-1);
    }
    addrRel += 600;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_596: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_597: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_598: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_599: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(594))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 599 << endl;
        exit(-1);
    }
    addrRel += 594;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_600: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_601: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_602: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 603;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 602 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_603: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_604: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_605: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_606: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 606 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_607: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 607 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_608: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 608 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_609: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 610;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 609 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_610: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 610 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_611: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 611 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_612: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(600));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 612 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_613: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 613 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_614: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_615: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(625))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 615 << endl;
        exit(-1);
    }
    addrRel += 625;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_616: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(621))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 616 << endl;
        exit(-1);
    }
    addrRel += 621;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_617: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_618: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_619: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_620: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(615))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 620 << endl;
        exit(-1);
    }
    addrRel += 615;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_621: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_622: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_623: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 624;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 623 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_624: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_625: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_626: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_627: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 627 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_628: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 628 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_629: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 629 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_630: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 631;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 630 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_631: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 631 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_632: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 632 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_633: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 633 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_634: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_635: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-3
    op0 = fr.mul(-3, A0);
    op1 = fr.mul(-3, A1);
    op2 = fr.mul(-3, A2);
    op3 = fr.mul(-3, A3);
    op4 = fr.mul(-3, A4);
    op5 = fr.mul(-3, A5);
    op6 = fr.mul(-3, A6);
    op7 = fr.mul(-3, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 635 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_636: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 636 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_637: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 637 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_638: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 638 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_639: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 639 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_640: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 640 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_641: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(651))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 641 << endl;
        exit(-1);
    }
    addrRel += 651;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_642: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 643;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 642 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_643: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_644: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_645: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 645 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_646: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 647;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 646 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_647: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_648: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_649: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_650: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(640))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 650 << endl;
        exit(-1);
    }
    addrRel += 640;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_651: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 652;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 651 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_652: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_653: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 653 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_654: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 655;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 654 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_655: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 655 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_656: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 656 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_657: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 657 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_658: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 658 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_659: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 659 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_660: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 661;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 660 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_661: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 661 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_662: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 663;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 662 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_663: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 663 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_664: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 665;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 664 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_665: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 665 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_666: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 666 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_667: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 668;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 667 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_668: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_669: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 669 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_670: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 671;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 670 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_671: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 671 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_672: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_673: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 673 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_674: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 675;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 674 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_675: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_676: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_677: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_678: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 678 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_679: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 679 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_680: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_681: //;; Set batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 682;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 681 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_682: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 682 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_683: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(686))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 683 << endl;
        exit(-1);
    }
    addrRel += 686;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_684: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 685;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 684 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_685: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(687))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 685 << endl;
        exit(-1);
    }
    addrRel += 687;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_686: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 687;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 686 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_687: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 687 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_688: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 688 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_689: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_690: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(692))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 690 << endl;
        exit(-1);
    }
    addrRel += 692;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_691: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_692: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_693: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_694: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_695: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 695 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_696: //        

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 696 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_697: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 697 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_698: //;; Set global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(700))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 698 << endl;
        exit(-1);
    }
    addrRel += 700;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_699: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(703))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 699 << endl;
        exit(-1);
    }
    addrRel += 703;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_700: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_701: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(703))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 701 << endl;
        exit(-1);
    }
    addrRel += 703;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_702: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=8
    op0 = fr.mul(8, C0);
    op1 = fr.mul(8, C1);
    op2 = fr.mul(8, C2);
    op3 = fr.mul(8, C3);
    op4 = fr.mul(8, C4);
    op5 = fr.mul(8, C5);
    op6 = fr.mul(8, C6);
    op7 = fr.mul(8, C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_703: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_704: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_705: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_706: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(708))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 706 << endl;
        exit(-1);
    }
    addrRel += 708;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_707: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_708: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 708 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_709: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_710: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 200;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_711: //;; Prepare transaction loop

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_712: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(714))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 712 << endl;
        exit(-1);
    }
    addrRel += 714;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_713: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 200;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_714: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 714 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_715: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 715 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_716: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 716 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_717: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 717 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_718: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 128;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_719: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_720: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(743))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 720 << endl;
        exit(-1);
    }
    addrRel += 743;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_721: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 721 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_722: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 64;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_723: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_724: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(743))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 724 << endl;
        exit(-1);
    }
    addrRel += 743;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_725: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 725 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_726: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 727;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 726 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_727: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_728: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 729;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 728 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_729: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_730: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 731;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 730 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_731: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_732: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 733;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 732 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_733: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 733 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_734: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_735: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_736: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 736 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_737: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 738;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 737 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_738: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_739: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 739 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_740: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 741;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 740 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_741: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(150));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 741 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_742: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 742 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_743: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(828))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 743 << endl;
        exit(-1);
    }
    addrRel += 828;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_744: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 744 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_745: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 745 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_746: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 96;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_747: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_748: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(769))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 748 << endl;
        exit(-1);
    }
    addrRel += 769;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_749: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 749 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_750: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 64;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_751: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_752: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(769))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 752 << endl;
        exit(-1);
    }
    addrRel += 769;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_753: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 753 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_754: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 755;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 754 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_755: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_756: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 757;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 756 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_757: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_758: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 759;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 758 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_759: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 759 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_760: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_761: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_762: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 762 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_763: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 764;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 763 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_764: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_765: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 765 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_766: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 767;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 766 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_767: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 767 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_768: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 768 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_769: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(828))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 769 << endl;
        exit(-1);
    }
    addrRel += 828;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_770: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 770 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_771: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 771 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_772: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_773: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_774: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_775: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(790))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 775 << endl;
        exit(-1);
    }
    addrRel += 790;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_776: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 776 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_777: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(782))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 777 << endl;
        exit(-1);
    }
    addrRel += 782;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_778: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 779;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 778 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_779: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_780: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_781: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(777))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 781 << endl;
        exit(-1);
    }
    addrRel += 777;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_782: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_783: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 783 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_784: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 784 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_785: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 786;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 785 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_786: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 786 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_787: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_788: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-34000
    op0 = fr.mul(-34000, A0);
    op1 = fr.mul(-34000, A1);
    op2 = fr.mul(-34000, A2);
    op3 = fr.mul(-34000, A3);
    op4 = fr.mul(-34000, A4);
    op5 = fr.mul(-34000, A5);
    op6 = fr.mul(-34000, A6);
    op7 = fr.mul(-34000, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(45000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 788 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_789: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 789 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_790: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(828))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 790 << endl;
        exit(-1);
    }
    addrRel += 828;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_791: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_792: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 792 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_793: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 213;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_794: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_795: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(819))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 795 << endl;
        exit(-1);
    }
    addrRel += 819;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_796: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_797: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(797))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 797 << endl;
        exit(-1);
    }
    addrRel += 797;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_798: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(803))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 798 << endl;
        exit(-1);
    }
    addrRel += 803;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_799: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_800: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_801: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_802: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(797))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 802 << endl;
        exit(-1);
    }
    addrRel += 797;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_803: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_804: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_805: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 806;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 805 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_806: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_807: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_808: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 808 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_809: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_810: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_811: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_812: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 812 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_813: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 813 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_814: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 814 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_815: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 816;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 815 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_816: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 816 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_817: //;; Set batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 818;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 817 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_818: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 818 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_819: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 819 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_820: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(828))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 820 << endl;
        exit(-1);
    }
    addrRel += 828;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_821: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 821 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_822: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_823: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(834))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 823 << endl;
        exit(-1);
    }
    addrRel += 834;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_824: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 824 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_825: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 825 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_826: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_827: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 827 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_828: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 828 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_829: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(834))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 829 << endl;
        exit(-1);
    }
    addrRel += 834;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_830: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 830 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_831: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 831 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_832: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_833: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 833 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_834: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 834 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_835: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(566))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 835 << endl;
        exit(-1);
    }
    addrRel += 566;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_836: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 836 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_837: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 837 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_838: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(632))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 838 << endl;
        exit(-1);
    }
    addrRel += 632;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_839: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(656))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 839 << endl;
        exit(-1);
    }
    addrRel += 656;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_840: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 840 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_841: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 841 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_842: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 842 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_843: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 843 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_844: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 844 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_845: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 845 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_846: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 846 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_847: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_848: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 848 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_849: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 849 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_850: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 850 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_851: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_852: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_853: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 853 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_854: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 854 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_855: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 855 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_856: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_857: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 857 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_858: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 858 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_859: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(11))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 859 << endl;
        exit(-1);
    }
    addrRel += 11;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_860: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(8))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 860 << endl;
        exit(-1);
    }
    addrRel += 8;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_861: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(865))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 861 << endl;
        exit(-1);
    }
    addrRel += 865;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_862: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_863: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(865))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 863 << endl;
        exit(-1);
    }
    addrRel += 865;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_864: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 864 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_865: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 865 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_866: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_867: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 867 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_868: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_869: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_870: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_871: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 871 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_872: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_873: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 873 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_874: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 874 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_875: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_876: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_877: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_878: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_879: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_880: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_881: //        0                                   :MSTORE(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 881 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_882: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 882 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_883: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 883 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_884: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 885;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 884 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_885: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 885 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_886: //        $${var p = 0}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 886 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_887: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_888: //txLoopRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_889: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_890: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 890 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_891: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_892: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_893: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 893 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_894: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 894 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_895: //endCheckRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 895 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_896: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_897: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_898: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 898 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_899: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_900: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(21000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 900 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_901: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 901 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_902: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_903: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 903 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_904: //        %LOCAL_EXIT_ROOT_STORAGE_POS => C                         ; Storage position of the local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_905: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = fr.neg(1);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_906: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_907: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_908: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_909: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(910))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 909 << endl;
        exit(-1);
    }
    addrRel += 910;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_910: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 910 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_911: //;; Check batchHashData

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 911 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_912: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 913;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 912 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_913: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 913 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_914: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 914 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_915: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(906))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 915 << endl;
        exit(-1);
    }
    addrRel += 906;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_916: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_917: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_918: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_919: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(921))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 919 << endl;
        exit(-1);
    }
    addrRel += 921;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_920: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(923))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 920 << endl;
        exit(-1);
    }
    addrRel += 923;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_921: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 921 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_922: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(910))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 922 << endl;
        exit(-1);
    }
    addrRel += 910;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_923: //        $ => A                          :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 923 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_924: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(910))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 924 << endl;
        exit(-1);
    }
    addrRel += 910;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_925: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 925 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_926: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 926 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_927: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(938))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 927 << endl;
        exit(-1);
    }
    addrRel += 938;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_928: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 928 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_929: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_930: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 10;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_931: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(835))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 931 << endl;
        exit(-1);
    }
    addrRel += 835;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_932: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_933: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_934: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_935: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_936: //        $ => A                          :MLOAD(globalHash)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 936 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_937: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1040))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 937 << endl;
        exit(-1);
    }
    addrRel += 1040;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_938: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_939: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 939 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_940: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 940 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_941: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 941 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_942: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(974))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 942 << endl;
        exit(-1);
    }
    addrRel += 974;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_943: //INCLUDE "process_tx.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 943 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_944: //INCLUDE "opcodes.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 944 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_945: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(957))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 945 << endl;
        exit(-1);
    }
    addrRel += 957;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_946: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 946 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_947: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_948: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 214);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_949: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 148;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_950: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_951: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_952: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_953: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 128);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_954: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_955: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_956: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(967))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 956 << endl;
        exit(-1);
    }
    addrRel += 967;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_957: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_958: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 214;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_959: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 148;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_960: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_961: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_962: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_963: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(966))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 963 << endl;
        exit(-1);
    }
    addrRel += 966;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_964: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_965: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(967))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 965 << endl;
        exit(-1);
    }
    addrRel += 967;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_966: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 128;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_967: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_968: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_969: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 12;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_970: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 971;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 970 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_971: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 972;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 971 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_972: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 972 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_973: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1016))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 973 << endl;
        exit(-1);
    }
    addrRel += 1016;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_974: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 974 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_975: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_976: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 976 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_977: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 977 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_978: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 979;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 978 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_979: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 979 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_980: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-6
    op0 = fr.mul(-6, A0);
    op1 = fr.mul(-6, A1);
    op2 = fr.mul(-6, A2);
    op3 = fr.mul(-6, A3);
    op4 = fr.mul(-6, A4);
    op5 = fr.mul(-6, A5);
    op6 = fr.mul(-6, A6);
    op7 = fr.mul(-6, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 980 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_981: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_982: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(983))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 982 << endl;
        exit(-1);
    }
    addrRel += 983;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_983: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(995))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 983 << endl;
        exit(-1);
    }
    addrRel += 995;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_984: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(990))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 984 << endl;
        exit(-1);
    }
    addrRel += 990;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_985: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_986: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_987: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_988: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_989: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(983))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 989 << endl;
        exit(-1);
    }
    addrRel += 983;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_990: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_991: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_992: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 993;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 992 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_993: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_994: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_995: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_996: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_997: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_998: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 998 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_999: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 999 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1000: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1001: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1002: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1003: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1003 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1004: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1005: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(36))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1005 << endl;
        exit(-1);
    }
    addrRel += 36;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1006: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1007: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1008: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1009: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1010: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1011: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1012: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 12;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1013: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1014;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1013 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1014: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1015;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1014 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1015: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1015 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1016: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1016 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1017: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1017 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1018: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1019: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1020: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1020 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1021: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1021 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1022: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1022 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1023: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1023 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1024: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1024 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1025: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1025 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1026: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1026 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1027: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1027 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1028: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1029;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1028 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1029: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1029 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1030: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1030 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1031: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = fr.add(op0, SP);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1032: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1032 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1033: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inPC*PC, where inPC=-1
    op0 = fr.add(op0, fr.neg(PC));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1060))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1033 << endl;
        exit(-1);
    }
    addrRel += 1060;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1034: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1035: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1035 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1036: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1037: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1038: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1039: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(310))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1039 << endl;
        exit(-1);
    }
    addrRel += 310;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1040: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1041: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1042: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1042 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1043: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1043 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1044: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1045: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1046: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1047: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1048: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inPC*PC, where inPC=-1
    op0 = fr.add(op0, fr.neg(PC));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1048 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1049: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1050: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1051: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1052: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1053: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(310))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1053 << endl;
        exit(-1);
    }
    addrRel += 310;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1054: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1054 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1055: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1024))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1055 << endl;
        exit(-1);
    }
    addrRel += 1024;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1056: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1043))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1056 << endl;
        exit(-1);
    }
    addrRel += 1043;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1057: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1057 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1058: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1060))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1058 << endl;
        exit(-1);
    }
    addrRel += 1060;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1059: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1059 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1060: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1060 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1061: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1062: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1063: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1064: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1065: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1065 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1066: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1067: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1068: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1069: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1070: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1070 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1071: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1072: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1073: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1073 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1074: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1074 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1075: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1076: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1076 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1077: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1078: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1079: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1079 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1080: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1081: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1082: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1082 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1083: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1083 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1084: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1084 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1085: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1086;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1085 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1086: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1086 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1087: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1087 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1088: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1089: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1090: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1091: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1091 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1092: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1101))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1092 << endl;
        exit(-1);
    }
    addrRel += 1101;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1093: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1094: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inGAS*GAS, where inGAS=-1
    op0 = fr.add(op0, fr.neg(GAS));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1095: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1095 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1096: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1096 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1097: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1098;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1097 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1098: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1098 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1099: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1101))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1099 << endl;
        exit(-1);
    }
    addrRel += 1101;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1100: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1101: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1102: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1103: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1103 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1104: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1104 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1105: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1105 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1106: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1107;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1106 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1107: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1107 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1108: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1108 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1109: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1110: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1111: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1111 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1112: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1112 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1113: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1114;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1113 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1114: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1114 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1115: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1115 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1116: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1117: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1118: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1119: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inGAS*GAS, where inGAS=-1
    op0 = fr.add(op0, fr.neg(GAS));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1120: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1120 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1121: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1121 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1122: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1122 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1123: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1124;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1123 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1124: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1124 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1125: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1125 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1126: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1127: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1128: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1128 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1129: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1129 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1130: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1131;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1130 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1131: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1131 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1132: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1132 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1133: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1134: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1135: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(65))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1135 << endl;
        exit(-1);
    }
    addrRel += 65;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1136: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1136 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1137: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(65))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1137 << endl;
        exit(-1);
    }
    addrRel += 65;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1138: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1139: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1141))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1139 << endl;
        exit(-1);
    }
    addrRel += 1141;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1140: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1141: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1142: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1143: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1144: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1145: //;; Set batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1146: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1146 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1147: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1147 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1148: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1149: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1149 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1150: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1150 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1151: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1151 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1152: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1169))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1152 << endl;
        exit(-1);
    }
    addrRel += 1169;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1153: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1153 << endl;
        exit(-1);
    }
    addrRel += 1209;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1154: //        ${eventLog(onStartBatch, C)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1162))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1154 << endl;
        exit(-1);
    }
    addrRel += 1162;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1155: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1156: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1157: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1157 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1158: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1159: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1159 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1160: //        

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1161: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1153))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1161 << endl;
        exit(-1);
    }
    addrRel += 1153;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1162: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1163: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1164: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1165;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1164 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1165: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1166;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1165 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1166: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1166 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1167: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1168: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1168 << endl;
        exit(-1);
    }
    addrRel += 1209;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1169: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1169 << endl;
        exit(-1);
    }
    addrRel += 1209;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1170: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1185))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1170 << endl;
        exit(-1);
    }
    addrRel += 1185;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1171: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1172: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1173: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1174: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1175;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1174 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1175: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1176: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1177: //;; Prepare transaction loop

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1178: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1179: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1180;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1179 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1180: //        0                                   :MSTORE(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1180 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1181: //        E                                   :MSTORE(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1182: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1182 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1183: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1184: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1169))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1184 << endl;
        exit(-1);
    }
    addrRel += 1169;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1185: //        $${var p = 0}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1195))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1185 << endl;
        exit(-1);
    }
    addrRel += 1195;
    addr = addrRel;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1186: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1187: //txLoopRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1188: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1189: //        A+1 => CTX      :MSTORE(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1190: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1191;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1190 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1191: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1192;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1191 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1192: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1192 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1193: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1194: //                        :JMP(endCheckRLP)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1194 << endl;
        exit(-1);
    }
    addrRel += 1209;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1195: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1196: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1197: //txLoop:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1198: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1199;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1198 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1199: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1200: //        A               :JMPN(processTxsEnd)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1201: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1202: //        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1203: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1204: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1205;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1204 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1205: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1206: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1207;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1206 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1207: //processTxEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1207 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1208: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1209: //processTxsEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1209 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1210: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1210 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1211: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1212: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1212 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1213: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1213 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1214: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1214 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1215: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1216: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1217: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1218: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1223))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1218 << endl;
        exit(-1);
    }
    addrRel += 1223;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1219: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1220: //;; Check batchHashData

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1221;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1220 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1221: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1222: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1217))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1222 << endl;
        exit(-1);
    }
    addrRel += 1217;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1223: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1224: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1224 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1225: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1225 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1226: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1226 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1227: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1228: //        HASHPOS                         :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1228 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1229: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1229 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1230: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1230 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1231: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1231 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1232: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1232 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1233: //; Check Global Hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1233 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1234: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = fr.neg(1);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1259))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1234 << endl;
        exit(-1);
    }
    addrRel += 1259;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1235: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1236: //        ; Get position of the previous hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1237: //        $ => HASHPOS                    :MLOAD(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1238: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1239: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1240;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1239 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1240: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1241;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1240 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1241: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1242: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1242 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1243: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1244: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1245;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1244 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1245: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1246: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1247: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1248: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1249: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1250;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1249 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1250: //        ${eventLog(onFinishBatch)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1251;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1250 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1251: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1252: //        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1252 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1253: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1254: //finalWait:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1254 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1255: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1256: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1256 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1257: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1258: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1303))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1258 << endl;
        exit(-1);
    }
    addrRel += 1303;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1259: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1259 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1260: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1261: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1262: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1303))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1262 << endl;
        exit(-1);
    }
    addrRel += 1303;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1263: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1263 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1264: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1264 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1265: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1265 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1266: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1266 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1267: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1267 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1268: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1268 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1269: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1283))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1269 << endl;
        exit(-1);
    }
    addrRel += 1283;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1270: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1271: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1272: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1272 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1273: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1274;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1273 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1274: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1275: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1276: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1277: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1278;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1277 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1278: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1279;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1278 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1279: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1280: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1280 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1281: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1282: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1303))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1282 << endl;
        exit(-1);
    }
    addrRel += 1303;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1283: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1284: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1285: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1285 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1286: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1287;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1286 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1287: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1288: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1289: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1290: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1291;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1290 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1291: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1292;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1291 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1292: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1293: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1294: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1294 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1295: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1296;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1295 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1296: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1297: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1298: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1299: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1300;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1299 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1300: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1301: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1301 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1302: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1303: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1303 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1304: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1304 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1305: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1305 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1306: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1306 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1307: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1307 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1308: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1309: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1309 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1310: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1310 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1311: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1311 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1312: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1312 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1313: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1314: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1315: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1316: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1317: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1318: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1338))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1318 << endl;
        exit(-1);
    }
    addrRel += 1338;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1319: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1320: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1321: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1322: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1323: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1323 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1324: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1325: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1326: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1326 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1327: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1328: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1329: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1330;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1329 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1330: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1331: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1332: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1333: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1334: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1335;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1334 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1335: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1336: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1337: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1372))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1337 << endl;
        exit(-1);
    }
    addrRel += 1372;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1338: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1339: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1340: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1372))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1340 << endl;
        exit(-1);
    }
    addrRel += 1372;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1341: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1341 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1342: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1342 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1343: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1343 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1344: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1344 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1345: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1345 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1346: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1357))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1346 << endl;
        exit(-1);
    }
    addrRel += 1357;
    addr = addrRel;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1347: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1348: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1349: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1350: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1351: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1352;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1351 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1352: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1353: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1354;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1353 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1354: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1355;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1354 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1355: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1356: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1372))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1356 << endl;
        exit(-1);
    }
    addrRel += 1372;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1357: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1358: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1359: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1360: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1361;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1360 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1361: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1362: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1363: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

main_exec_generated_fast_rom_line_1364: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1365: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1366: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1367;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1366 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1367: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1368: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1369;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1368 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1369: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1370: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1370 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1371: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1372: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1372 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1373: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1373 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1374: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1374 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1375: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1375 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1376: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1377: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1377 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1378: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1378 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1379: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1379 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1380: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1380 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1381: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1382: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1383: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1384: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1385: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1400))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1385 << endl;
        exit(-1);
    }
    addrRel += 1400;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1386: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1387: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1388: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1389: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1390: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1391: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1400))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1391 << endl;
        exit(-1);
    }
    addrRel += 1400;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1392: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1393: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1394: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1395: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1396: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1397: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1400))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1397 << endl;
        exit(-1);
    }
    addrRel += 1400;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1398: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1399: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1402))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1399 << endl;
        exit(-1);
    }
    addrRel += 1402;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1400: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1401: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1402))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1401 << endl;
        exit(-1);
    }
    addrRel += 1402;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1402: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1402 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1403: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1403 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1404: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1404 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1405: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1405 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1406: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1407: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1407 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1408: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1408 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1409: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1409 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1410: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1410 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1411: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1412: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1412 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1413: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1415))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1413 << endl;
        exit(-1);
    }
    addrRel += 1415;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1414: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1415: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1415 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1416: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1416 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1417: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1417 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1418: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1418 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1419: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1420: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1420 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1421: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1421 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1422: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1422 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1423: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1424: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1425: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-3
    op0 = fr.mul(-3, A0);
    op1 = fr.mul(-3, A1);
    op2 = fr.mul(-3, A2);
    op3 = fr.mul(-3, A3);
    op4 = fr.mul(-3, A4);
    op5 = fr.mul(-3, A5);
    op6 = fr.mul(-3, A6);
    op7 = fr.mul(-3, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1425 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1426: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=3
    op0 = fr.mul(3, B0);
    op1 = fr.mul(3, B1);
    op2 = fr.mul(3, B2);
    op3 = fr.mul(3, B3);
    op4 = fr.mul(3, B4);
    op5 = fr.mul(3, B5);
    op6 = fr.mul(3, B6);
    op7 = fr.mul(3, B7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1426 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1427: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1427 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1428: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1428 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1429: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1430: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1430 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1431: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1432;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1478))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1431 << endl;
        exit(-1);
    }
    addrRel += 1478;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1432: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1432 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1433: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1433 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1434: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1435: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1435 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1436: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1437;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1472))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1436 << endl;
        exit(-1);
    }
    addrRel += 1472;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1437: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1437 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1438: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1439: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1439 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1440: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1441;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1478))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1440 << endl;
        exit(-1);
    }
    addrRel += 1478;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1441: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1441 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1442: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1442 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1443: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1444: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1444 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1445: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1446;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1472))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1445 << endl;
        exit(-1);
    }
    addrRel += 1472;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1446: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1446 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1447: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1448: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1448 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1449: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1450;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1478))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1449 << endl;
        exit(-1);
    }
    addrRel += 1478;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1450: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1450 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1451: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1451 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1452: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1453: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1454: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1455: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1455 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1456: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1457;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1472))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1456 << endl;
        exit(-1);
    }
    addrRel += 1472;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1457: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1457 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1458: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1459: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1459 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1460: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1461;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1478))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1460 << endl;
        exit(-1);
    }
    addrRel += 1478;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1461: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1461 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1462: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1462 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1463: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1464: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1465: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1466: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1467: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1467 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1468: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1468 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1469: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1470;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1472))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1469 << endl;
        exit(-1);
    }
    addrRel += 1472;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1470: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1470 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1471: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1472: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1472 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1473: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1473 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1474: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1474 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1475: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1475 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1476: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1476 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1477: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1478: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1478 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1479: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1479 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1480: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1480 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1481: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1481 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1482: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1482 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1483: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1484: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1484 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1485: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1485 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1486: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1486 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1487: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1487 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1488: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1489: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1490: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1491: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1492: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1493: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1494: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1495: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1500))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1495 << endl;
        exit(-1);
    }
    addrRel += 1500;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1496: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1496 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1497: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1497 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1498: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1498 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1499: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1499 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1500: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1501: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1501 << endl;
        exit(-1);
    }
    addrRel += 1516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1502: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1503: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1504: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1505: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1505 << endl;
        exit(-1);
    }
    addrRel += 1515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1506: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1507: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1508: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1509: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1510: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1511: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1512: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1513: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1514: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1514 << endl;
        exit(-1);
    }
    addrRel += 1516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1515: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1516: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1516 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1517: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1517 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1518: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1518 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1519: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1519 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1520: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1521: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1521 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1522: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1522 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1523: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1523 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1524: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1524 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1525: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1526: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1527: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1528: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1529: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1530: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1531: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1532: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1537))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1532 << endl;
        exit(-1);
    }
    addrRel += 1537;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1533: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1533 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1534: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1534 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1535: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1535 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1536: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1536 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1537: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1538: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1539: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1540: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1565))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1540 << endl;
        exit(-1);
    }
    addrRel += 1565;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1541: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1542: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1543: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1544: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 256);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1558))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1544 << endl;
        exit(-1);
    }
    addrRel += 1558;
    addr = addrRel;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1545: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1546: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1547: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1548: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1549: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1550: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1551: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1552: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 256);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1553: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1554: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1560))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1554 << endl;
        exit(-1);
    }
    addrRel += 1560;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1555: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1556: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1557: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1565))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1557 << endl;
        exit(-1);
    }
    addrRel += 1565;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1558: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1559: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1565))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1559 << endl;
        exit(-1);
    }
    addrRel += 1565;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1560: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 256);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1561: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1562: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1563: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1564: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1565: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1566: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1566 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1567: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1567 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1568: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1568 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1569: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1569 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1570: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1571: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1571 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1572: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1572 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1573: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1574: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1581))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1574 << endl;
        exit(-1);
    }
    addrRel += 1581;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1575: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1576: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1576 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1577: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1577 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1578: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1578 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1579: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1580: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1580 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1581: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1582: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1118))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1582 << endl;
        exit(-1);
    }
    addrRel += 1118;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1583: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1583 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1584: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1584 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1585: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1586: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1593))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1586 << endl;
        exit(-1);
    }
    addrRel += 1593;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1587: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1588: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1588 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1589: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1589 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1590: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1590 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1591: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1592: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1592 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1593: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1594: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1118))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1594 << endl;
        exit(-1);
    }
    addrRel += 1118;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1595: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1595 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1596: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1607))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1596 << endl;
        exit(-1);
    }
    addrRel += 1607;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1597: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1597 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1598: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1599: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1599 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1600: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1600 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1601: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1602: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1602 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1603: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1603 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1604: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1605: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1605 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1606: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1606 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1607: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1607 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1608: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1608 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1609: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1610: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1611: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1612: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1612 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1613: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1613 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1614: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1615;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1614 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1615: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1615 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1616: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1617: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1617 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1618: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1618 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1619: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1619 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1620: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1620 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1621: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1622: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1623: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1624: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1624 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1625: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1625 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1626: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1627;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1626 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1627: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1627 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1628: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1629: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1629 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1630: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1630 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1631: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1631 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1632: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1632 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1633: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1634: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1635: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1636: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1636 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1637: //;; Set global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1637 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1638: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1639;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1439))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1638 << endl;
        exit(-1);
    }
    addrRel += 1439;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1639: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1639 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1640: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1641: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1641 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1642: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1642 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1643: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1643 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1644: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1644 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1645: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1646: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1647: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1648: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1648 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1649: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1649 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1650: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1651;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1650 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1651: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1651 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1652: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1653: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1653 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1654: //;; Prepare transaction loop

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1654 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1655: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1655 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1656: //        E                                   :MSTORE(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1656 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1657: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1658: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1659: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1660;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1659 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1660: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1661: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1662: //        $${var p = 0}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1663: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1664;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1663 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1664: //txLoopRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1664 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1665: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1666: //        A+1 => CTX      :MSTORE(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1667: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1668: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1669: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1669 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1670: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1679))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1670 << endl;
        exit(-1);
    }
    addrRel += 1679;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1671: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1671 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1672: //endCheckRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1672 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1673: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1674;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1673 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1674: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1674 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1675: //txLoop:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1676: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1676 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1677: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1677 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1678: //        A               :JMPN(processTxsEnd)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1678 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1679: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1680: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1681: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1682: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1683: //processTxEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1684: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1685: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1686: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1686 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1687: //processTxsEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1687 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1688: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1688 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1689: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1689 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1690: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1691: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1692: //        %LOCAL_EXIT_ROOT_STORAGE_POS => C                         ; Storage position of the local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1693: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1693 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1694: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1694 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1695: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1696;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1695 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1696: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1696 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1697: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1698: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1698 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1699: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1699 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1700: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1700 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1701: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1701 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1702: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1703: //        $ => E                          :MLOAD(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1704: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1705;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1704 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1705: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1706: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1707: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1708: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1709;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1708 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1709: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1709 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1710: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1711: //        20 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1712: //        $ => A                          :MLOAD(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1713: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1713 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1714: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1723))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1714 << endl;
        exit(-1);
    }
    addrRel += 1723;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1715: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1715 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1716: //        $ => A                          :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1716 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1717: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1718;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1717 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1718: //        HASHPOS                         :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1718 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1719: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1720: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1720 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1721: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1721 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1722: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1722 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1723: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1724: //        ; Get position of the previous hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1725: //        $ => HASHPOS                    :MLOAD(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1726: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1727: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1728: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1729: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1730: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1731: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1731 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1732: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1732 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1733: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1733 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1734: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1734 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1735: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1736: //        $ => A                          :MLOAD(globalHash)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1737: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1738: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1738 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1739: //        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1739 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1740: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1741;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1740 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1741: //finalWait:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1741 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1742: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1743: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1743 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1744: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1744 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1745: //INCLUDE "process_tx.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1746;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1745 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1746: //INCLUDE "opcodes.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1746 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1747: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1748: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1748 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1749: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1749 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1750: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1750 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1751: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1751 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1752: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1753: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1754: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1755: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1755 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1756: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1756 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1757: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1758;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1757 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1758: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1758 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1759: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1760: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1760 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1761: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1761 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1762: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1763;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1762 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1763: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1763 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1764: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1765: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1765 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1766: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1766 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1767: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1767 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1768: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1768 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1769: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1770: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1771: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1772: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1773: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1774: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1774 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1775: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1776;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1212))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1775 << endl;
        exit(-1);
    }
    addrRel += 1212;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1776: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-50
    op0 = fr.mul(-50, A0);
    op1 = fr.mul(-50, A1);
    op2 = fr.mul(-50, A2);
    op3 = fr.mul(-50, A3);
    op4 = fr.mul(-50, A4);
    op5 = fr.mul(-50, A5);
    op6 = fr.mul(-50, A6);
    op7 = fr.mul(-50, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1776 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1777: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1777 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1778: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1778 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1779: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1780: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1781: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1782: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 31;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1783: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1784: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1805))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1784 << endl;
        exit(-1);
    }
    addrRel += 1805;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1785: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1786: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1786 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1787: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 7;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1787 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1788: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1789;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1788 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1789: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1789 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1790: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1791: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1792: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1793: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1794: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1795: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1802))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1795 << endl;
        exit(-1);
    }
    addrRel += 1802;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1796: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1797: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1798: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1799: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1800: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1801: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1805))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1801 << endl;
        exit(-1);
    }
    addrRel += 1805;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1802: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1803: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1804: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1805: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1806: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1806 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1807: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1807 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1808: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1808 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1809: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1810: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1810 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1811: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1811 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1812: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1813: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1813 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1814: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1814 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1815: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1815 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1816: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1817: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1818: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1819: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1819 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1820: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1821: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1821 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1822: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1822 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1823: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1823 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1824: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1825: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1826: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1827: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1827 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1828: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1829: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1829 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1830: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1830 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1831: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1831 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1832: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1833: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1834: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1835: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1835 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1836: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1837: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1837 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1838: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1838 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1839: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1839 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1840: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1841: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1842: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1843: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1843 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1844: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1845: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1845 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1846: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1846 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1847: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1847 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1848: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1849: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1850: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1851: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1851 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1852: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1853: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1853 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1854: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1854 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1855: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1855 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1856: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1857: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1857 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1858: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1859: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1860: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1860 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1861: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1861 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1862: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1862 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1863: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1864: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1865: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1866: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1866 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1867: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1868: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1868 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1869: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1869 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1870: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1870 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1871: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1872: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1873: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1874: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1874 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1875: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1876: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1876 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1877: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1877 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1878: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1878 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1879: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1880: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1881: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1882: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1882 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1883: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1884: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1884 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1885: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1885 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1886: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1886 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1887: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1888: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1888 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1889: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1890: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1891: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1891 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1892: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1892 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1893: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1893 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1894: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1895: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1896: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1897: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1898: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1899;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1898 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1899: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1899 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1900: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1901: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1902: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1902 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1903: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1903 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1904: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1904 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1905: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1906: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1907: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1908: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1909;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1496))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1908 << endl;
        exit(-1);
    }
    addrRel += 1496;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1909: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1910: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1910 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1911: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1911 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1912: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1912 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1913: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1913 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1914: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1915: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1916: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1917: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1918;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1533))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1917 << endl;
        exit(-1);
    }
    addrRel += 1533;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1918: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1919: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1919 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1920: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1920 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1921: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1921 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1922: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1922 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1923: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1924: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1925: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1926: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1927: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1928: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1929: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1930: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1931: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1932: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1933: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1934;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1933 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1934: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1935;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1934 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1935: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1936: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1937: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1938: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1939: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1944))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1939 << endl;
        exit(-1);
    }
    addrRel += 1944;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1940: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1941: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1941 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1942: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1942 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1943: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1943 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1944: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1945: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1946: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1947: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1948: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1949: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1950: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1951: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1951 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1952: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1952 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1953: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1953 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1954: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1954 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1955: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1956: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1957: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1958: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1958 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1959: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(30));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1959 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1960: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1961: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1961 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1962: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1962 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1963: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1964;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1963 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1964: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1964 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1965: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 6;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1965 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1966: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1966 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1967: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1968;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1967 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1968: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1968 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1969: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1969 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_1970: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1970 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1971: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1971 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1972: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1973: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_1974: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1989))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1974 << endl;
        exit(-1);
    }
    addrRel += 1989;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1975: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1983))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1975 << endl;
        exit(-1);
    }
    addrRel += 1983;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1976: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1977;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1976 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1977: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1978: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1978 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1979: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1980: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1981: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1982: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1974))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1982 << endl;
        exit(-1);
    }
    addrRel += 1974;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1983: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1984;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1983 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1984: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1985: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1986;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1985 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1986: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1986 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1987: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1988: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1989: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1989 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1990: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1991: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1992: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1993: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1993 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1994: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1994 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1995: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1995 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1996: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1996 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1997: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1997 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1998: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1998 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_1999: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2002))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1999 << endl;
        exit(-1);
    }
    addrRel += 2002;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2000: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2000 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2001: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2003))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2001 << endl;
        exit(-1);
    }
    addrRel += 2003;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2002: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2002 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2003: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2004: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2004 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2005: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2005 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2006: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2006 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2007: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2007 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2008: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2009: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2010: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2011: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2012: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2012 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2013: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2014: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2014 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2015: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2015 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2016: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2016 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2017: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2018: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2018 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2019: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2019 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2020: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2020 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2021: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2021 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2022: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2023: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2023 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2024: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2024 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2025: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2025 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2026: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2026 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2027: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2028: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2028 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2029: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2029 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2030: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2030 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2031: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2031 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2032: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2033: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2033 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2034: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2034 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2035: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2036;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2035 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2036: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2036 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2037: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2037 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2038: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2047))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2038 << endl;
        exit(-1);
    }
    addrRel += 2047;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2039: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2040: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2041: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2042: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2043: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2044: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2044 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2045: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2045 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2046: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2046 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2047: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2048: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2049: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2050: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2051: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2052;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2051 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2052: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2053: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2054: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2055: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2056;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2055 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2056: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2057: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2058: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2058 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2059: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2059 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2060: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2060 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2061: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2061 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2062: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2063: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2063 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2064: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2064 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2065: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2065 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2066: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2066 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2067: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2068: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2069: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2070: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2071: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2071 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2072: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2072 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2073: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2073 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2074: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2074 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2075: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2076))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2075 << endl;
        exit(-1);
    }
    addrRel += 2076;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2076: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2124))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2076 << endl;
        exit(-1);
    }
    addrRel += 2124;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2077: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2100))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2077 << endl;
        exit(-1);
    }
    addrRel += 2100;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2078: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2078 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2079: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2079 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2080: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2081;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2080 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2081: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2081 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2082: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2082 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2083: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2084: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2085: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2086;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2085 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2086: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2087: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2087 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2088: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1025);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2089: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2090: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2091: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2092;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2091 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2092: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2092 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2093: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2094;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2093 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2094: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2094 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2095: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2096: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2097: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2098: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2099: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2076))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2099 << endl;
        exit(-1);
    }
    addrRel += 2076;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2100: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2101: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2102: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2103: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2104;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2103 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2104: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2104 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2105: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2106: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1025;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2107: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2108: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2119))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2108 << endl;
        exit(-1);
    }
    addrRel += 2119;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2109: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2110: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2111: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2112: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2113;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2112 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2113: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2114: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2115;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2114 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2115: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2116: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2116 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2117: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2118;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2117 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2118: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2124))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2118 << endl;
        exit(-1);
    }
    addrRel += 2124;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2119: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2120: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2121;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2120 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2121: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2122;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2121 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2122: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2122 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2123: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2124;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2123 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2124: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2124 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2125: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2125 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2126: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2126 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2127: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2127 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2128: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2128 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2129: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2129 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2130: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2140))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2130 << endl;
        exit(-1);
    }
    addrRel += 2140;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2131: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2131 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2132: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2133: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2134: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2135: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2136: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2137: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2137 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2138: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2138 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2139: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2139 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2140: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2140 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2141: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2142: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2142 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2143: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2143 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2144: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2144 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2145: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2145 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2146: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2146 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2147: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2066))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2147 << endl;
        exit(-1);
    }
    addrRel += 2066;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2148: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2148 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2149: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2150: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2151: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2152: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2153: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2154: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2155: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2156: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2156 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2157: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2157 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2158: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2158 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2159: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2172))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2159 << endl;
        exit(-1);
    }
    addrRel += 2172;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2160: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2167))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2160 << endl;
        exit(-1);
    }
    addrRel += 2167;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2161: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2162: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2162 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2163: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2164;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2163 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2164: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2165: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2166: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2159))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2166 << endl;
        exit(-1);
    }
    addrRel += 2159;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2167: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2168: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2169: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2170;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2169 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2170: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2170 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2171: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2172;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2171 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2172: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2172 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2173: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2173 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2174: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2174 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2175: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2175 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2176: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2176 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2177: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2178: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2178 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2179: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2179 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2180: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2180 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2181: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2181 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2182: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2183: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2184: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2185: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2186: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2187: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2188: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2189: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2189 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2190: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2190 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2191: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2191 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2192: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2192 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2193: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2194: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2195: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2196: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2197: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2198: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2199: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2200: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2201: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2202: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2202 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2203: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2203 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2204: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2204 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2205: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2218))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2205 << endl;
        exit(-1);
    }
    addrRel += 2218;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2206: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2213))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2206 << endl;
        exit(-1);
    }
    addrRel += 2213;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2207: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2208: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2208 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2209: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2210;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2209 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2210: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2211: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2212: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2205))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2212 << endl;
        exit(-1);
    }
    addrRel += 2205;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2213: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2214: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2215: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2216;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2215 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2216: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2216 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2217: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2218;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2217 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2218: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2218 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2219: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2219 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2220: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2220 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2221: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2221 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2222: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2222 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2223: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2224: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2224 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2225: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2225 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2226: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2226 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2227: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2227 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2228: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2229: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2230: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2231: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2231 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2232: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2233: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2234: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2234 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2235: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2236: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2236 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2237: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2237 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2238: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2239;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2238 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2239: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2239 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2240: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2240 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2241: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2241 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2242: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2243;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2242 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2243: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2243 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2244: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2244 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2245: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2245 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2246: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2246 << endl;
        exit(-1);
    }
    addrRel += 2263;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2247: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2257))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2247 << endl;
        exit(-1);
    }
    addrRel += 2257;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2248: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2249: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2250;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2249 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2250: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2251: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2252: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2252 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2253: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2254;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2253 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2254: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2255: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2256: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2246))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2256 << endl;
        exit(-1);
    }
    addrRel += 2246;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2257: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2258: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2259;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2258 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2259: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2260: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2261: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2261 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2262: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2263;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2262 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2263: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2263 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2264: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2264 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2265: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2265 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2266: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2266 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2267: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2267 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2268: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2269: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2270: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2270 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2271: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2272: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2273: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2274: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2275: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2275 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2276: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2276 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2277: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_2278: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2279: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2288))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2279 << endl;
        exit(-1);
    }
    addrRel += 2288;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2280: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2280 << endl;
        exit(-1);
    }
    addrRel += 2285;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2281: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2282: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2283: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2284: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2278))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2284 << endl;
        exit(-1);
    }
    addrRel += 2278;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2285: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2286: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2287: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2288: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2289: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2290: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2291: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2291 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2292: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2292 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2293: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2293 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2294: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(20));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2294 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2295: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2296: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2296 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2297: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2312))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2297 << endl;
        exit(-1);
    }
    addrRel += 2312;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2298: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2298 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2299: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2299 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2300: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

main_exec_generated_fast_rom_line_2301: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2302: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2303: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2304: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2305: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2306: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2307: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2308: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2309: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2310: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2310 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2311: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2311 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2312: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2313: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2313 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2314: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2314 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2315: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2315 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2316: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2317: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2317 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2318: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2318 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2319: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2319 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2320: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2320 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2321: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2322: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2322 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2323: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2323 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2324: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2324 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2325: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2325 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2326: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2327: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2327 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2328: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2328 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2329: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2329 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2330: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2331: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2332: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2332 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2333: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2333 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2334: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2334 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2335: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 30000000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2336: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2337: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2337 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2338: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2338 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2339: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2339 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2340: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2341: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2342: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2342 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2343: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2343 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2344: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2344 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2345: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2345 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2346: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2347: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2348: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2349: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2349 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2350: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2350 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2351: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2351 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2352: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2352 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2353: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2353 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2354: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2354 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2355: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2355 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2356: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2357: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2358;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2357 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2358: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2359: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2359 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2360: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2360 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2361: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2361 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2362: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2362 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2363: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2363 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2364: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2364 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2365: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2366: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2367: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2368: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2368 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2369: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2370;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2369 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2370: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2370 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2371: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2371 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2372: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2372 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2373: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2373 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2374: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2375;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2374 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2375: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2375 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2376: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2376 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2377: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2378: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2379: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2380: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2381: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2382: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2383;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2382 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2383: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2383 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2384: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2385;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2384 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2385: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2385 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2386: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2386 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2387: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2387 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2388: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2388 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2389: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2389 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2390: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2391: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2391 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2392: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2393: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2394: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2395: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2395 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2396: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2397: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-2000
    op0 = fr.mul(-2000, A0);
    op1 = fr.mul(-2000, A1);
    op2 = fr.mul(-2000, A2);
    op3 = fr.mul(-2000, A3);
    op4 = fr.mul(-2000, A4);
    op5 = fr.mul(-2000, A5);
    op6 = fr.mul(-2000, A6);
    op7 = fr.mul(-2000, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2397 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2398: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2398 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2399: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2399 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2400: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2400 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2401: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2401 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2402: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2403: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2404: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2404 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2405: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2406: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2406 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2407: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2410))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2407 << endl;
        exit(-1);
    }
    addrRel += 2410;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2408: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2408 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2409: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2411))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2409 << endl;
        exit(-1);
    }
    addrRel += 2411;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2410: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2410 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2411: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2412: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2413: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2413 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2414: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2414 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2415: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2416: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2416 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2417: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2418: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2419: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-2100
    op0 = fr.mul(-2100, A0);
    op1 = fr.mul(-2100, A1);
    op2 = fr.mul(-2100, A2);
    op3 = fr.mul(-2100, A3);
    op4 = fr.mul(-2100, A4);
    op5 = fr.mul(-2100, A5);
    op6 = fr.mul(-2100, A6);
    op7 = fr.mul(-2100, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2419 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2420: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2421: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2422: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2423: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2426))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2423 << endl;
        exit(-1);
    }
    addrRel += 2426;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2424: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2424 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2425: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2425 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2426: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2427: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2428: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2429: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2436))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2429 << endl;
        exit(-1);
    }
    addrRel += 2436;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2430: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2431: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2432: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2433: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2468))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2433 << endl;
        exit(-1);
    }
    addrRel += 2468;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2434: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(20000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2434 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2435: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2435 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2436: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2436 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2437: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2438: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2439: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2440: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2451))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2440 << endl;
        exit(-1);
    }
    addrRel += 2451;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2441: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2442: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2443: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2444: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2444 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2445: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2446: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2447: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2465))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2447 << endl;
        exit(-1);
    }
    addrRel += 2465;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2448: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2448 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2449: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 19900);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2449 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2450: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2450 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2451: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2452: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2453: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2454: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2454 << endl;
        exit(-1);
    }
    addrRel += 2458;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2455: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2455 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2456: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2456 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2457: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2441))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2457 << endl;
        exit(-1);
    }
    addrRel += 2441;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2458: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2459: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2460: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2461: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2441))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2461 << endl;
        exit(-1);
    }
    addrRel += 2441;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2462: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2462 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2463: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15000);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2463 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2464: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2441))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2464 << endl;
        exit(-1);
    }
    addrRel += 2441;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2465: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2465 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2466: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 2800);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2466 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2467: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2467 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2468: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2900));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2468 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2469: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2470: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2471: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2472: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2472 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2473: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2473 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2474: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15000);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2474 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2475: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2475 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2476: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2476 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2477: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2480))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2477 << endl;
        exit(-1);
    }
    addrRel += 2480;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2478: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2478 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2479: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2481))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2479 << endl;
        exit(-1);
    }
    addrRel += 2481;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2480: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2480 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2481: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2482: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2482 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2483: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2484: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2485: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2485 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2486: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2486 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2487: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2488: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2489: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2489 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2490: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2490 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2491: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2491 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2492: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2493: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2493 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2494: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2495: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2496: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2496 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2497: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2498: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2499: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2500: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2500 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2501: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2501 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2502: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2503: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2503 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2504: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2504 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2505: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2505 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2506: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2506 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2507: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2508: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2508 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2509: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2509 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2510: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2510 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2511: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2512: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2512 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2513: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2513 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2514: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2514 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2515: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2515 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2516: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2517: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2518: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2518 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2519: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = fr.add(op0, PC);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2520: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2520 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2521: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2521 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2522: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2522 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2523: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2523 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2524: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2524 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2525: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2525 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2526: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2527;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2526 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2527: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2527 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2528: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2528 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2529: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = fr.add(op0, SP);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2530: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2530 << endl;
        exit(-1);
    }
    addrRel += 2539;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2531: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2532: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2532 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2533: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2534: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2535: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2535 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2536: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = fr.add(op0, PC);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2537: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2537 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2538: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2538 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2539: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2540: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2541: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2542: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2543: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2544: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = fr.add(op0, PC);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2545: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2546: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2547: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2548: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2549;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2548 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2549: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2549 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2550: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2551: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2551 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2552: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2552 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2553: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2553 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2554: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2555: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2555 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2556: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2556 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2557: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2557 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2558: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2559: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2559 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2560: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2560 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2561: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2561 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2562: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2563: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2563 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2564: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2564 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2565: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2565 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2566: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 4;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2567: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2567 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2568: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2568 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2569: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2569 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2570: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 5;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2571: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2571 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2572: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2572 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2573: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2573 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2574: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 6;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2575: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2575 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2576: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2576 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2577: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2577 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2578: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 7;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2579: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2579 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2580: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2580 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2581: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2581 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2582: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2583: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2583 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2584: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2584 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2585: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2585 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2586: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 9;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2587: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2587 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2588: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2588 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2589: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2589 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2590: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 10;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2591: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2591 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2592: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2592 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2593: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2593 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2594: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 11;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2595: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2595 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2596: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2596 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2597: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2597 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2598: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 12;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2599: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2599 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2600: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2600 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2601: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2601 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2602: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 13;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2603: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2603 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2604: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2604 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2605: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2605 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2606: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 14;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2607: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2607 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2608: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2608 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2609: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2609 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2610: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 15;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2611: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2611 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2612: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2612 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2613: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2613 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2614: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 16;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2615: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2615 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2616: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2616 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2617: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2617 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2618: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 17;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2619: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2619 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2620: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2620 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2621: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2621 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2622: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 18;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2623: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2623 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2624: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2624 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2625: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2625 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2626: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 19;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2627: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2627 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2628: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2628 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2629: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2629 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2630: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2631: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2631 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2632: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2632 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2633: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2633 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2634: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 21;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2635: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2635 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2636: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2636 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2637: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2637 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2638: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 22;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2639: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2639 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2640: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2640 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2641: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2641 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2642: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 23;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2643: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2643 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2644: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2644 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2645: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2645 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2646: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 24;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2647: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2647 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2648: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2648 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2649: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2649 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2650: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 25;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2651: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2651 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2652: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2652 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2653: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2653 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2654: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 26;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2655: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2655 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2656: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2656 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2657: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2657 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2658: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 27;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2659: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2659 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2660: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2660 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2661: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2661 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2662: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 28;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2663: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2663 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2664: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2664 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2665: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2665 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2666: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 29;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2667: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2667 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2668: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2668 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2669: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2669 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2670: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 30;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2671: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2671 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2672: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2672 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2673: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2673 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2674: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 31;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2675: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2675 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2676: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2676 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2677: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2677 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2678: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2679: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2679 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2680: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2680 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2681: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2681 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2682: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2682 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2683: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2684: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2684 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2685: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2686: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2686 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2687: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2687 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2688: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2688 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2689: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2689 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2690: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2691: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 2);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2692: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2693: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2693 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2694: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2694 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2695: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2695 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2696: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2696 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2697: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2698: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 3);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2699: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2700: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2700 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2701: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2701 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2702: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2702 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2703: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2703 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2704: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2705: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 4);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2706: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2707: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2707 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2708: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2708 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2709: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2709 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2710: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2710 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2711: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2712: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 5);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2713: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2714: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2714 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2715: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2715 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2716: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2716 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2717: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2717 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2718: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2719: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 6);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2720: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2721: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2721 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2722: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2722 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2723: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2723 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2724: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2724 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2725: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2726: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 7);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2727: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2728: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2728 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2729: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2729 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2730: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2730 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2731: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2731 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2732: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2733: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 8);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2734: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2735: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2735 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2736: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2736 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2737: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2737 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2738: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2738 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2739: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2740: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 9);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2741: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2742: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2742 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2743: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2743 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2744: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2744 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2745: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2745 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2746: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2747: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 10);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2748: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2749: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2749 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2750: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2750 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2751: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2751 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2752: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(11));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2752 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2753: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2754: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 11);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2755: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2756: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2756 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2757: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2757 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2758: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2758 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2759: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(12));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2759 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2760: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2761: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 12);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2762: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2763: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2763 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2764: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2764 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2765: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2765 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2766: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(13));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2766 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2767: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2768: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 13);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2769: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2770: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2770 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2771: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2771 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2772: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2772 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2773: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(14));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2773 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2774: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2775: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 14);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2776: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2777: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2777 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2778: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2778 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2779: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2779 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2780: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2780 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2781: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2782: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2783: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2784: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2784 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2785: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2785 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2786: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2786 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2787: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2787 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2788: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2789: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 16);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2790: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2791: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2791 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2792: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2792 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2793: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2793 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2794: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2794 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2795: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2796: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2797: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2798: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2799: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2799 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2800: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2801: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2801 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2802: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2802 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2803: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2803 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2804: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2804 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2805: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2806: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2807: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2808: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2809: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2810: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 2);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2811: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2812: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2812 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2813: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2813 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2814: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2814 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2815: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2815 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2816: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2817: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2818: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2819: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2820: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2821: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 3);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2822: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2823: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2823 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2824: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2824 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2825: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2825 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2826: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2826 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2827: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2828: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2829: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2830: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2831: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2832: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 4);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2833: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2834: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2834 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2835: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2835 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2836: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2836 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2837: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2837 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2838: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2839: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2840: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2841: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2842: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2843: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 5);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2844: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2845: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2845 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2846: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2846 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2847: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2847 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2848: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2848 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2849: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2850: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2851: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2852: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2853: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2854: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 6);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2855: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2856: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2856 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2857: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2857 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2858: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2858 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2859: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2859 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2860: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2861: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2862: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2863: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2864: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2865: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 7);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2866: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2867: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2867 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2868: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2868 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2869: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2869 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2870: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2870 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2871: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2872: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2873: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2874: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2875: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2876: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 8);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2877: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2878: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2878 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2879: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2879 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2880: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2880 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2881: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2881 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2882: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2883: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2884: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2885: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2886: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2887: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 9);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2888: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2889: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2889 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2890: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2890 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2891: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2891 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2892: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(11));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2892 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2893: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2894: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2895: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2896: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2897: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2898: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 10);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2899: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2900: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2900 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2901: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2901 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2902: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2902 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2903: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(12));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2903 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2904: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2905: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2906: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(11));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2907: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2908: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2909: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 11);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2910: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2911: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2911 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2912: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2912 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2913: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2913 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2914: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(13));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2914 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2915: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2916: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2917: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(12));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2918: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2919: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2920: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 12);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2921: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2922: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2922 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2923: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2923 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2924: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2924 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2925: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(14));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2925 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2926: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2927: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2928: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(13));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2929: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2930: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2931: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 13);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2932: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2933: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2933 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2934: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2934 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2935: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2935 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2936: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2936 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2937: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2938: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2939: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(14));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2940: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2941: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2942: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 14);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2943: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2944: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2944 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2945: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2945 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2946: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2946 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2947: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2947 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2948: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2949: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2950: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2951: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2952: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2953: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2954: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2955: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2955 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2956: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2956 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2957: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2957 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2958: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(17));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2958 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2959: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2960: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2961: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2962: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2963: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2964: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 16);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2965: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2966: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2966 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2967: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2967 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2968: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2968 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2969: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2969 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2970: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2970 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2971: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2971 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2972: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2973: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2974: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2975: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2975 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2976: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2976 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2977: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2977 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2978: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2978 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2979: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2979 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2980: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2980 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2981: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2981 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2982: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2982 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2983: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2983 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2984: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2984 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2985: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2986: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2987: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2988: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2988 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2989: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2989 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2990: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2990 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2991: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2991 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_2992: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2992 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2993: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2993 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2994: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2994 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2995: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2995 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2996: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2996 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2997: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2997 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2998: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_2999: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3000: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3001: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3001 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3002: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3002 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3003: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3003 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3004: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3004 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3005: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3005 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3006: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3006 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3007: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3007 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3008: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3008 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3009: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3009 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3010: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3010 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3011: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3012: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3013: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3014: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3014 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3015: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3015 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3016: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3016 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3017: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3017 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3018: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3018 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3019: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3019 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3020: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3020 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3021: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3021 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3022: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3022 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3023: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3023 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3024: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3025: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3026: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3027: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3027 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3028: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 4;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3028 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3029: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3029 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3030: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3030 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3031: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3031 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3032: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3032 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3033: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3033 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3034: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3042))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3034 << endl;
        exit(-1);
    }
    addrRel += 3042;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3035: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3040))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3035 << endl;
        exit(-1);
    }
    addrRel += 3040;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3036: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3037;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3036 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3037: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3038: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3039: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3039 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3040: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3041;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3040 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3041: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3042: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3042 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3043: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3050))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3043 << endl;
        exit(-1);
    }
    addrRel += 3050;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3044: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3044 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3045: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3045 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3046: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3047: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3048: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3049: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3043))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3049 << endl;
        exit(-1);
    }
    addrRel += 3043;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3050: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3050 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3051: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3051 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3052: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3052 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3053: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3053 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3054: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3054 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3055: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3055 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3056: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3056 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3057: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3058: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3059: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3059 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3060: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3061: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3061 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3062: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3063: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3063 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3064: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3064 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3065: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3065 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3066: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3066 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3067: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3067 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3068: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3068 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3069: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3069 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3070: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3070 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3071: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3071 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3072: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3072 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3073: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3073 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3074: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3074 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3075: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3075 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3076: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3076 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3077: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3078: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3079;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3078 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3079: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3079 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3080: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3080 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3081: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3081 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3082: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3083: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3083 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3084: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3084 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3085: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3086;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3085 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3086: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3087: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3088: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3089: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3090: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3090 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3091: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3092: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3093: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3094: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3095: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3095 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3096: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3097;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1212))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3096 << endl;
        exit(-1);
    }
    addrRel += 1212;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3097: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3097 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3098: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3098 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3099: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3099 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3100: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3100 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3101: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3101 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3102: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3102 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3103: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3103 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3104: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3105: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3105 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3106: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3107: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3107 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3108: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3109: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3109 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3110: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3111: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3111 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3112: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3112 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3113: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3115))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3113 << endl;
        exit(-1);
    }
    addrRel += 3115;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3114: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3114 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3115: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3116: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3116 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3117: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3118: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3118 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3119: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3120: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3121: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3121 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3122: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3123: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3123 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3124: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3125: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3126: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3128))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3126 << endl;
        exit(-1);
    }
    addrRel += 3128;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3127: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3128: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3129: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3129 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3130: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3132))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3130 << endl;
        exit(-1);
    }
    addrRel += 3132;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3131: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3132;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3131 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3132: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3132 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3133: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3133 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3134: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3134 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3135: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3135 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3136: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3136 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3137: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3137 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3138: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3138 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3139: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3139 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3140: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3140 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3141: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3141 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3142: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3142 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3143: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3143 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3144: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3145: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3145 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3146: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3146 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3147: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3147 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3148: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3149: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3149 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3150: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3150 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3151: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3151 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3152: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3153: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3155))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3153 << endl;
        exit(-1);
    }
    addrRel += 3155;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3154: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3154 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3155: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3156;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3155 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3156: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3156 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3157: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3157 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3158: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3158 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3159: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3160: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3160 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3161: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3161 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3162: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3162 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3163: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3163 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3164: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3165;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3164 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3165: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3165 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3166: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3166 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3167: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3168: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3168 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3169: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3170: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3170 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3171: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3172: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3172 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3173: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3174: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3174 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3175: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3176: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3176 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3177: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3178: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3178 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3179: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3180: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3181: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3181 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3182: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3183: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3183 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3184: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3185: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3186: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3188))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3186 << endl;
        exit(-1);
    }
    addrRel += 3188;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3187: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3188: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3189: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3189 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3190: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3190 << endl;
        exit(-1);
    }
    addrRel += 3192;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3191: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3192;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3191 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3192: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3192 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3193: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3193 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3194: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3194 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3195: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3195 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3196: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3196 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3197: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3197 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3198: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3198 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3199: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3199 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3200: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3200 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3201: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3201 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3202: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3202 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3203: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3203 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3204: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3204 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3205: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3205 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3206: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3206 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3207: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3208: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3208 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3209: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3209 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3210: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3211: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3211 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3212: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3212 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3213: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3213 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3214: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3216))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3214 << endl;
        exit(-1);
    }
    addrRel += 3216;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3215: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3215 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3216: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3217;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3216 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3217: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3217 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3218: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3218 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3219: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3219 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3220: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3221: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3221 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3222: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3222 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3223: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3223 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3224: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3224 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3225: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3226;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3225 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3226: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3226 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3227: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3227 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3228: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3229: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3230: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3231: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3231 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3232: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3232 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3233: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3276))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3233 << endl;
        exit(-1);
    }
    addrRel += 3276;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3234: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3234 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3235: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3272))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3235 << endl;
        exit(-1);
    }
    addrRel += 3272;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3236: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3236 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3237: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3237 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3238: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3238 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3239: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3239 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3240: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3240 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3241: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3241 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3242: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3242 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3243: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3243 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3244: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3244 << endl;
        exit(-1);
    }
    addrRel += 3263;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3245: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3257))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3245 << endl;
        exit(-1);
    }
    addrRel += 3257;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3246: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3247;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3246 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3247: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3248: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3248 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3249: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3250: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3250 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3251: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3252;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3251 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3252: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3253: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3254: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3255: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3255 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3256: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3244))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3256 << endl;
        exit(-1);
    }
    addrRel += 3244;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3257: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3258;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3257 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3258: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3258 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3259: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3260: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3260 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3261: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3262;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3261 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3262: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3262 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3263: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3263 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3264: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3264 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3265: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3265 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3266: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3267: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3267 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3268: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3268 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3269: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3269 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3270: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3270 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3271: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3271 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3272: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3272 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3273: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3273 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3274: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3274 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3275: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3275 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3276: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-200
    op0 = fr.mul(-200, C0);
    op1 = fr.mul(-200, C1);
    op2 = fr.mul(-200, C2);
    op3 = fr.mul(-200, C3);
    op4 = fr.mul(-200, C4);
    op5 = fr.mul(-200, C5);
    op6 = fr.mul(-200, C6);
    op7 = fr.mul(-200, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3276 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3277: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3277 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3278: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3280))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3278 << endl;
        exit(-1);
    }
    addrRel += 3280;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3279: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3279 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3280: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3280 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3281: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3281 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3282: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3282 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3283: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3283 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3284: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3284 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3285: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3285 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3286: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3286 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3287: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3287 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3288: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3288 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3289: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3289 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3290: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3290 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3291: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3292: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3293: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3294: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3295: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3296: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3297: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3298: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3299: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3299 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3300: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3301: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3322))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3301 << endl;
        exit(-1);
    }
    addrRel += 3322;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3302: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3302 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3303: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3304: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3305: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3305 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3306: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3306 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3307: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3308: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3308 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3309: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3310: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3311: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3311 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3312: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3313: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3314: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3314 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3315: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3315 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3316: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3316 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3317: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3318;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3317 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3318: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3318 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3319: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3319 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3320: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3321: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3322: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3322 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3323: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3323 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3324: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3325: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3325 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3326: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3326 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3327: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3328: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3328 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3329: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3329 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3330: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3330 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3331: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3332: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3332 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3333: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3334: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3334 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3335: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3336: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3336 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3337: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3338: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3338 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3339: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3340: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3340 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3341: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3342: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3343: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3343 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3344: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3345: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3345 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3346: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3347: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3348: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3350))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3348 << endl;
        exit(-1);
    }
    addrRel += 3350;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3349: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3350: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3351: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3351 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3352: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3354))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3352 << endl;
        exit(-1);
    }
    addrRel += 3354;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3353: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3354;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3353 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3354: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3354 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3355: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3355 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3356: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3356 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3357: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3357 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3358: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3358 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3359: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3359 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3360: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3360 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3361: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3361 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3362: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3362 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3363: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3363 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3364: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3364 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3365: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3365 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3366: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3366 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3367: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3367 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3368: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3368 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3369: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3370: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3370 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3371: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3371 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3372: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3372 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3373: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3374: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3374 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3375: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3376;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3375 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3376: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3376 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3377: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3377 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3378: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3378 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3379: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3380: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3380 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3381: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3381 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3382: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3382 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3383: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3383 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3384: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3385;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3384 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3385: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3385 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3386: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3386 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3387: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3387 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3388: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3388 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3389: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3390: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3391: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3391 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3392: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3393: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3393 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3394: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3395: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3395 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3396: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3397: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3397 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3398: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3398 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3399: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3399 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3400: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3400 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3401: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3401 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3402: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3402 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3403: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3403 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3404: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3404 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3405: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3405 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3406: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3406 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3407: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3407 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3408: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3408 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3409: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(36))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3409 << endl;
        exit(-1);
    }
    addrRel += 36;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3410: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3410 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3411: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3411 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3412: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3413: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3414;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3413 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3414: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3414 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3415: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3415 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3416: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3416 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3417: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3418: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3418 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3419: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3419 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3420: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3421;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3420 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3421: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3422: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3423: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3424: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3425: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3425 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3426: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3427: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3428: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3429: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3430: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3430 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3431: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3432;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1212))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3431 << endl;
        exit(-1);
    }
    addrRel += 1212;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3432: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3432 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3433: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3433 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3434: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3434 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3435: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3435 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3436: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3436 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3437: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3437 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3438: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3438 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3439: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3440: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3440 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3441: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3442: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3442 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3443: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3444: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3444 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3445: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3446: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3446 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3447: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3448: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3448 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3449: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3450: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3451: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3451 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3452: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3453: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3453 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3454: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3455: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3456: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3456 << endl;
        exit(-1);
    }
    addrRel += 3458;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3457: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3458: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3459: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3459 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3460: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3462))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3460 << endl;
        exit(-1);
    }
    addrRel += 3462;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3461: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3462;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3461 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3462: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3462 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3463: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3463 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3464: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3464 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3465: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3465 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3466: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3466 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3467: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3467 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3468: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3468 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3469: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3469 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3470: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3470 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3471: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3471 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3472: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3472 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3473: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3473 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3474: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3474 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3475: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3475 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3476: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3477: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3477 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3478: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3478 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3479: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3479 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3480: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3481: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3481 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3482: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3483;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3482 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3483: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3483 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3484: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3484 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3485: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3485 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3486: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3487: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3487 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3488: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3488 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3489: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3489 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3490: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3490 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3491: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3492;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3491 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3492: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3492 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3493: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3493 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3494: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3494 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3495: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3496: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3497: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3498: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3498 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3499: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3508))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3499 << endl;
        exit(-1);
    }
    addrRel += 3508;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3500: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3501: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3501 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3502: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3502 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3503: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3503 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3504: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3504 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3505: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3506: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3506 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3507: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3507 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3508: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3508 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3509: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3509 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3510: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3510 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3511: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 24000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3511 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3512: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3512 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3513: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3513 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3514: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3515: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3516: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3517: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3518: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3519: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3520: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3521: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3522: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3522 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3523: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3524: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3525: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3526;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1377))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3525 << endl;
        exit(-1);
    }
    addrRel += 1377;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3526: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=-25000
    op0 = fr.mul(-25000, E0);
    op1 = fr.mul(-25000, E1);
    op2 = fr.mul(-25000, E2);
    op3 = fr.mul(-25000, E3);
    op4 = fr.mul(-25000, E4);
    op5 = fr.mul(-25000, E5);
    op6 = fr.mul(-25000, E6);
    op7 = fr.mul(-25000, E7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3526 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3527: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3528: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=-2600
    op0 = fr.mul(-2600, E0);
    op1 = fr.mul(-2600, E1);
    op2 = fr.mul(-2600, E2);
    op3 = fr.mul(-2600, E3);
    op4 = fr.mul(-2600, E4);
    op5 = fr.mul(-2600, E5);
    op6 = fr.mul(-2600, E6);
    op7 = fr.mul(-2600, E7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3528 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3529: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3530: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3531: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3531 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3532: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3532 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3533: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3534;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3533 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3534: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3534 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3535: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3536: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3537: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3538: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3538 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3539: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3540: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3540 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3541: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3541 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3542: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3543: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3543 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3544: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3544 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3545: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3545 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3546: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3546 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3547: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3547 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3548: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3548 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3549: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

main_exec_generated_fast_rom_line_3550: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3550 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3551: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3551 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3552: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3553: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3553 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

main_exec_generated_fast_rom_line_3554: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3554 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

}
