#include "main_exec_generated_fast.hpp"

#define MEM_OFFSET 0x30000
#define STACK_OFFSET 0x20000
#define CODE_OFFSET 0x10000
#define CTX_OFFSET 0x40000

vector<void *> main_exec_generated_fast_labels;
void main_exec_generated_fast (FiniteField &fr, const Input &input, Database &db, Counters &counters)
{
    // opN are local, uncommitted polynomials
    FieldElement op0, op1, op2, op3, op4, op5, op6, op7;
    FieldElement A0, A1, A2, A3, A4, A5, A6, A7;
    A7 = A6 = A5 = A4 = A3 = A2 = A1 = A0 = fr.zero();
    FieldElement B0, B1, B2, B3, B4, B5, B6, B7;
    B7 = B6 = B5 = B4 = B3 = B2 = B1 = B0 = fr.zero();
    FieldElement C0, C1, C2, C3, C4, C5, C6, C7;
    C7 = C6 = C5 = C4 = C3 = C2 = C1 = C0 = fr.zero();
    FieldElement D0, D1, D2, D3, D4, D5, D6, D7;
    D7 = D6 = D5 = D4 = D3 = D2 = D1 = D0 = fr.zero();
    FieldElement E0, E1, E2, E3, E4, E5, E6, E7;
    E7 = E6 = E5 = E4 = E3 = E2 = E1 = E0 = fr.zero();
    FieldElement SR0, SR1, SR2, SR3, SR4, SR5, SR6, SR7;
    SR7 = SR6 = SR5 = SR4 = SR3 = SR2 = SR1 = SR0 = fr.zero();
    FieldElement HASHPOS, GAS, CTX, PC, SP, RR, carry, MAXMEM;
    HASHPOS = GAS = CTX = PC = SP = RR = carry = MAXMEM = fr.zero();
     uint32_t addrRel = 0; // Relative and absolute address auxiliary variables
     uint64_t addr = 0;
     int64_t i=-1; // Number of this evaluation
    int64_t N=1<<23;
    int64_t o;
    int64_t maxMemCalculated;
    int64_t mm;
    int64_t incHashPos = 0;

   if (main_exec_generated_fast_labels.size()==0)
    {
        main_exec_generated_fast_labels.push_back(&&RomLine0);
        main_exec_generated_fast_labels.push_back(&&RomLine1);
        main_exec_generated_fast_labels.push_back(&&RomLine2);
        main_exec_generated_fast_labels.push_back(&&RomLine3);
        main_exec_generated_fast_labels.push_back(&&RomLine4);
        main_exec_generated_fast_labels.push_back(&&RomLine5);
        main_exec_generated_fast_labels.push_back(&&RomLine6);
        main_exec_generated_fast_labels.push_back(&&RomLine7);
        main_exec_generated_fast_labels.push_back(&&RomLine8);
        main_exec_generated_fast_labels.push_back(&&RomLine9);
        main_exec_generated_fast_labels.push_back(&&RomLine10);
        main_exec_generated_fast_labels.push_back(&&RomLine11);
        main_exec_generated_fast_labels.push_back(&&RomLine12);
        main_exec_generated_fast_labels.push_back(&&RomLine13);
        main_exec_generated_fast_labels.push_back(&&RomLine14);
        main_exec_generated_fast_labels.push_back(&&RomLine15);
        main_exec_generated_fast_labels.push_back(&&RomLine16);
        main_exec_generated_fast_labels.push_back(&&RomLine17);
        main_exec_generated_fast_labels.push_back(&&RomLine18);
        main_exec_generated_fast_labels.push_back(&&RomLine19);
        main_exec_generated_fast_labels.push_back(&&RomLine20);
        main_exec_generated_fast_labels.push_back(&&RomLine21);
        main_exec_generated_fast_labels.push_back(&&RomLine22);
        main_exec_generated_fast_labels.push_back(&&RomLine23);
        main_exec_generated_fast_labels.push_back(&&RomLine24);
        main_exec_generated_fast_labels.push_back(&&RomLine25);
        main_exec_generated_fast_labels.push_back(&&RomLine26);
        main_exec_generated_fast_labels.push_back(&&RomLine27);
        main_exec_generated_fast_labels.push_back(&&RomLine28);
        main_exec_generated_fast_labels.push_back(&&RomLine29);
        main_exec_generated_fast_labels.push_back(&&RomLine30);
        main_exec_generated_fast_labels.push_back(&&RomLine31);
        main_exec_generated_fast_labels.push_back(&&RomLine32);
        main_exec_generated_fast_labels.push_back(&&RomLine33);
        main_exec_generated_fast_labels.push_back(&&RomLine34);
        main_exec_generated_fast_labels.push_back(&&RomLine35);
        main_exec_generated_fast_labels.push_back(&&RomLine36);
        main_exec_generated_fast_labels.push_back(&&RomLine37);
        main_exec_generated_fast_labels.push_back(&&RomLine38);
        main_exec_generated_fast_labels.push_back(&&RomLine39);
        main_exec_generated_fast_labels.push_back(&&RomLine40);
        main_exec_generated_fast_labels.push_back(&&RomLine41);
        main_exec_generated_fast_labels.push_back(&&RomLine42);
        main_exec_generated_fast_labels.push_back(&&RomLine43);
        main_exec_generated_fast_labels.push_back(&&RomLine44);
        main_exec_generated_fast_labels.push_back(&&RomLine45);
        main_exec_generated_fast_labels.push_back(&&RomLine46);
        main_exec_generated_fast_labels.push_back(&&RomLine47);
        main_exec_generated_fast_labels.push_back(&&RomLine48);
        main_exec_generated_fast_labels.push_back(&&RomLine49);
        main_exec_generated_fast_labels.push_back(&&RomLine50);
        main_exec_generated_fast_labels.push_back(&&RomLine51);
        main_exec_generated_fast_labels.push_back(&&RomLine52);
        main_exec_generated_fast_labels.push_back(&&RomLine53);
        main_exec_generated_fast_labels.push_back(&&RomLine54);
        main_exec_generated_fast_labels.push_back(&&RomLine55);
        main_exec_generated_fast_labels.push_back(&&RomLine56);
        main_exec_generated_fast_labels.push_back(&&RomLine57);
        main_exec_generated_fast_labels.push_back(&&RomLine58);
        main_exec_generated_fast_labels.push_back(&&RomLine59);
        main_exec_generated_fast_labels.push_back(&&RomLine60);
        main_exec_generated_fast_labels.push_back(&&RomLine61);
        main_exec_generated_fast_labels.push_back(&&RomLine62);
        main_exec_generated_fast_labels.push_back(&&RomLine63);
        main_exec_generated_fast_labels.push_back(&&RomLine64);
        main_exec_generated_fast_labels.push_back(&&RomLine65);
        main_exec_generated_fast_labels.push_back(&&RomLine66);
        main_exec_generated_fast_labels.push_back(&&RomLine67);
        main_exec_generated_fast_labels.push_back(&&RomLine68);
        main_exec_generated_fast_labels.push_back(&&RomLine69);
        main_exec_generated_fast_labels.push_back(&&RomLine70);
        main_exec_generated_fast_labels.push_back(&&RomLine71);
        main_exec_generated_fast_labels.push_back(&&RomLine72);
        main_exec_generated_fast_labels.push_back(&&RomLine73);
        main_exec_generated_fast_labels.push_back(&&RomLine74);
        main_exec_generated_fast_labels.push_back(&&RomLine75);
        main_exec_generated_fast_labels.push_back(&&RomLine76);
        main_exec_generated_fast_labels.push_back(&&RomLine77);
        main_exec_generated_fast_labels.push_back(&&RomLine78);
        main_exec_generated_fast_labels.push_back(&&RomLine79);
        main_exec_generated_fast_labels.push_back(&&RomLine80);
        main_exec_generated_fast_labels.push_back(&&RomLine81);
        main_exec_generated_fast_labels.push_back(&&RomLine82);
        main_exec_generated_fast_labels.push_back(&&RomLine83);
        main_exec_generated_fast_labels.push_back(&&RomLine84);
        main_exec_generated_fast_labels.push_back(&&RomLine85);
        main_exec_generated_fast_labels.push_back(&&RomLine86);
        main_exec_generated_fast_labels.push_back(&&RomLine87);
        main_exec_generated_fast_labels.push_back(&&RomLine88);
        main_exec_generated_fast_labels.push_back(&&RomLine89);
        main_exec_generated_fast_labels.push_back(&&RomLine90);
        main_exec_generated_fast_labels.push_back(&&RomLine91);
        main_exec_generated_fast_labels.push_back(&&RomLine92);
        main_exec_generated_fast_labels.push_back(&&RomLine93);
        main_exec_generated_fast_labels.push_back(&&RomLine94);
        main_exec_generated_fast_labels.push_back(&&RomLine95);
        main_exec_generated_fast_labels.push_back(&&RomLine96);
        main_exec_generated_fast_labels.push_back(&&RomLine97);
        main_exec_generated_fast_labels.push_back(&&RomLine98);
        main_exec_generated_fast_labels.push_back(&&RomLine99);
        main_exec_generated_fast_labels.push_back(&&RomLine100);
        main_exec_generated_fast_labels.push_back(&&RomLine101);
        main_exec_generated_fast_labels.push_back(&&RomLine102);
        main_exec_generated_fast_labels.push_back(&&RomLine103);
        main_exec_generated_fast_labels.push_back(&&RomLine104);
        main_exec_generated_fast_labels.push_back(&&RomLine105);
        main_exec_generated_fast_labels.push_back(&&RomLine106);
        main_exec_generated_fast_labels.push_back(&&RomLine107);
        main_exec_generated_fast_labels.push_back(&&RomLine108);
        main_exec_generated_fast_labels.push_back(&&RomLine109);
        main_exec_generated_fast_labels.push_back(&&RomLine110);
        main_exec_generated_fast_labels.push_back(&&RomLine111);
        main_exec_generated_fast_labels.push_back(&&RomLine112);
        main_exec_generated_fast_labels.push_back(&&RomLine113);
        main_exec_generated_fast_labels.push_back(&&RomLine114);
        main_exec_generated_fast_labels.push_back(&&RomLine115);
        main_exec_generated_fast_labels.push_back(&&RomLine116);
        main_exec_generated_fast_labels.push_back(&&RomLine117);
        main_exec_generated_fast_labels.push_back(&&RomLine118);
        main_exec_generated_fast_labels.push_back(&&RomLine119);
        main_exec_generated_fast_labels.push_back(&&RomLine120);
        main_exec_generated_fast_labels.push_back(&&RomLine121);
        main_exec_generated_fast_labels.push_back(&&RomLine122);
        main_exec_generated_fast_labels.push_back(&&RomLine123);
        main_exec_generated_fast_labels.push_back(&&RomLine124);
        main_exec_generated_fast_labels.push_back(&&RomLine125);
        main_exec_generated_fast_labels.push_back(&&RomLine126);
        main_exec_generated_fast_labels.push_back(&&RomLine127);
        main_exec_generated_fast_labels.push_back(&&RomLine128);
        main_exec_generated_fast_labels.push_back(&&RomLine129);
        main_exec_generated_fast_labels.push_back(&&RomLine130);
        main_exec_generated_fast_labels.push_back(&&RomLine131);
        main_exec_generated_fast_labels.push_back(&&RomLine132);
        main_exec_generated_fast_labels.push_back(&&RomLine133);
        main_exec_generated_fast_labels.push_back(&&RomLine134);
        main_exec_generated_fast_labels.push_back(&&RomLine135);
        main_exec_generated_fast_labels.push_back(&&RomLine136);
        main_exec_generated_fast_labels.push_back(&&RomLine137);
        main_exec_generated_fast_labels.push_back(&&RomLine138);
        main_exec_generated_fast_labels.push_back(&&RomLine139);
        main_exec_generated_fast_labels.push_back(&&RomLine140);
        main_exec_generated_fast_labels.push_back(&&RomLine141);
        main_exec_generated_fast_labels.push_back(&&RomLine142);
        main_exec_generated_fast_labels.push_back(&&RomLine143);
        main_exec_generated_fast_labels.push_back(&&RomLine144);
        main_exec_generated_fast_labels.push_back(&&RomLine145);
        main_exec_generated_fast_labels.push_back(&&RomLine146);
        main_exec_generated_fast_labels.push_back(&&RomLine147);
        main_exec_generated_fast_labels.push_back(&&RomLine148);
        main_exec_generated_fast_labels.push_back(&&RomLine149);
        main_exec_generated_fast_labels.push_back(&&RomLine150);
        main_exec_generated_fast_labels.push_back(&&RomLine151);
        main_exec_generated_fast_labels.push_back(&&RomLine152);
        main_exec_generated_fast_labels.push_back(&&RomLine153);
        main_exec_generated_fast_labels.push_back(&&RomLine154);
        main_exec_generated_fast_labels.push_back(&&RomLine155);
        main_exec_generated_fast_labels.push_back(&&RomLine156);
        main_exec_generated_fast_labels.push_back(&&RomLine157);
        main_exec_generated_fast_labels.push_back(&&RomLine158);
        main_exec_generated_fast_labels.push_back(&&RomLine159);
        main_exec_generated_fast_labels.push_back(&&RomLine160);
        main_exec_generated_fast_labels.push_back(&&RomLine161);
        main_exec_generated_fast_labels.push_back(&&RomLine162);
        main_exec_generated_fast_labels.push_back(&&RomLine163);
        main_exec_generated_fast_labels.push_back(&&RomLine164);
        main_exec_generated_fast_labels.push_back(&&RomLine165);
        main_exec_generated_fast_labels.push_back(&&RomLine166);
        main_exec_generated_fast_labels.push_back(&&RomLine167);
        main_exec_generated_fast_labels.push_back(&&RomLine168);
        main_exec_generated_fast_labels.push_back(&&RomLine169);
        main_exec_generated_fast_labels.push_back(&&RomLine170);
        main_exec_generated_fast_labels.push_back(&&RomLine171);
        main_exec_generated_fast_labels.push_back(&&RomLine172);
        main_exec_generated_fast_labels.push_back(&&RomLine173);
        main_exec_generated_fast_labels.push_back(&&RomLine174);
        main_exec_generated_fast_labels.push_back(&&RomLine175);
        main_exec_generated_fast_labels.push_back(&&RomLine176);
        main_exec_generated_fast_labels.push_back(&&RomLine177);
        main_exec_generated_fast_labels.push_back(&&RomLine178);
        main_exec_generated_fast_labels.push_back(&&RomLine179);
        main_exec_generated_fast_labels.push_back(&&RomLine180);
        main_exec_generated_fast_labels.push_back(&&RomLine181);
        main_exec_generated_fast_labels.push_back(&&RomLine182);
        main_exec_generated_fast_labels.push_back(&&RomLine183);
        main_exec_generated_fast_labels.push_back(&&RomLine184);
        main_exec_generated_fast_labels.push_back(&&RomLine185);
        main_exec_generated_fast_labels.push_back(&&RomLine186);
        main_exec_generated_fast_labels.push_back(&&RomLine187);
        main_exec_generated_fast_labels.push_back(&&RomLine188);
        main_exec_generated_fast_labels.push_back(&&RomLine189);
        main_exec_generated_fast_labels.push_back(&&RomLine190);
        main_exec_generated_fast_labels.push_back(&&RomLine191);
        main_exec_generated_fast_labels.push_back(&&RomLine192);
        main_exec_generated_fast_labels.push_back(&&RomLine193);
        main_exec_generated_fast_labels.push_back(&&RomLine194);
        main_exec_generated_fast_labels.push_back(&&RomLine195);
        main_exec_generated_fast_labels.push_back(&&RomLine196);
        main_exec_generated_fast_labels.push_back(&&RomLine197);
        main_exec_generated_fast_labels.push_back(&&RomLine198);
        main_exec_generated_fast_labels.push_back(&&RomLine199);
        main_exec_generated_fast_labels.push_back(&&RomLine200);
        main_exec_generated_fast_labels.push_back(&&RomLine201);
        main_exec_generated_fast_labels.push_back(&&RomLine202);
        main_exec_generated_fast_labels.push_back(&&RomLine203);
        main_exec_generated_fast_labels.push_back(&&RomLine204);
        main_exec_generated_fast_labels.push_back(&&RomLine205);
        main_exec_generated_fast_labels.push_back(&&RomLine206);
        main_exec_generated_fast_labels.push_back(&&RomLine207);
        main_exec_generated_fast_labels.push_back(&&RomLine208);
        main_exec_generated_fast_labels.push_back(&&RomLine209);
        main_exec_generated_fast_labels.push_back(&&RomLine210);
        main_exec_generated_fast_labels.push_back(&&RomLine211);
        main_exec_generated_fast_labels.push_back(&&RomLine212);
        main_exec_generated_fast_labels.push_back(&&RomLine213);
        main_exec_generated_fast_labels.push_back(&&RomLine214);
        main_exec_generated_fast_labels.push_back(&&RomLine215);
        main_exec_generated_fast_labels.push_back(&&RomLine216);
        main_exec_generated_fast_labels.push_back(&&RomLine217);
        main_exec_generated_fast_labels.push_back(&&RomLine218);
        main_exec_generated_fast_labels.push_back(&&RomLine219);
        main_exec_generated_fast_labels.push_back(&&RomLine220);
        main_exec_generated_fast_labels.push_back(&&RomLine221);
        main_exec_generated_fast_labels.push_back(&&RomLine222);
        main_exec_generated_fast_labels.push_back(&&RomLine223);
        main_exec_generated_fast_labels.push_back(&&RomLine224);
        main_exec_generated_fast_labels.push_back(&&RomLine225);
        main_exec_generated_fast_labels.push_back(&&RomLine226);
        main_exec_generated_fast_labels.push_back(&&RomLine227);
        main_exec_generated_fast_labels.push_back(&&RomLine228);
        main_exec_generated_fast_labels.push_back(&&RomLine229);
        main_exec_generated_fast_labels.push_back(&&RomLine230);
        main_exec_generated_fast_labels.push_back(&&RomLine231);
        main_exec_generated_fast_labels.push_back(&&RomLine232);
        main_exec_generated_fast_labels.push_back(&&RomLine233);
        main_exec_generated_fast_labels.push_back(&&RomLine234);
        main_exec_generated_fast_labels.push_back(&&RomLine235);
        main_exec_generated_fast_labels.push_back(&&RomLine236);
        main_exec_generated_fast_labels.push_back(&&RomLine237);
        main_exec_generated_fast_labels.push_back(&&RomLine238);
        main_exec_generated_fast_labels.push_back(&&RomLine239);
        main_exec_generated_fast_labels.push_back(&&RomLine240);
        main_exec_generated_fast_labels.push_back(&&RomLine241);
        main_exec_generated_fast_labels.push_back(&&RomLine242);
        main_exec_generated_fast_labels.push_back(&&RomLine243);
        main_exec_generated_fast_labels.push_back(&&RomLine244);
        main_exec_generated_fast_labels.push_back(&&RomLine245);
        main_exec_generated_fast_labels.push_back(&&RomLine246);
        main_exec_generated_fast_labels.push_back(&&RomLine247);
        main_exec_generated_fast_labels.push_back(&&RomLine248);
        main_exec_generated_fast_labels.push_back(&&RomLine249);
        main_exec_generated_fast_labels.push_back(&&RomLine250);
        main_exec_generated_fast_labels.push_back(&&RomLine251);
        main_exec_generated_fast_labels.push_back(&&RomLine252);
        main_exec_generated_fast_labels.push_back(&&RomLine253);
        main_exec_generated_fast_labels.push_back(&&RomLine254);
        main_exec_generated_fast_labels.push_back(&&RomLine255);
        main_exec_generated_fast_labels.push_back(&&RomLine256);
        main_exec_generated_fast_labels.push_back(&&RomLine257);
        main_exec_generated_fast_labels.push_back(&&RomLine258);
        main_exec_generated_fast_labels.push_back(&&RomLine259);
        main_exec_generated_fast_labels.push_back(&&RomLine260);
        main_exec_generated_fast_labels.push_back(&&RomLine261);
        main_exec_generated_fast_labels.push_back(&&RomLine262);
        main_exec_generated_fast_labels.push_back(&&RomLine263);
        main_exec_generated_fast_labels.push_back(&&RomLine264);
        main_exec_generated_fast_labels.push_back(&&RomLine265);
        main_exec_generated_fast_labels.push_back(&&RomLine266);
        main_exec_generated_fast_labels.push_back(&&RomLine267);
        main_exec_generated_fast_labels.push_back(&&RomLine268);
        main_exec_generated_fast_labels.push_back(&&RomLine269);
        main_exec_generated_fast_labels.push_back(&&RomLine270);
        main_exec_generated_fast_labels.push_back(&&RomLine271);
        main_exec_generated_fast_labels.push_back(&&RomLine272);
        main_exec_generated_fast_labels.push_back(&&RomLine273);
        main_exec_generated_fast_labels.push_back(&&RomLine274);
        main_exec_generated_fast_labels.push_back(&&RomLine275);
        main_exec_generated_fast_labels.push_back(&&RomLine276);
        main_exec_generated_fast_labels.push_back(&&RomLine277);
        main_exec_generated_fast_labels.push_back(&&RomLine278);
        main_exec_generated_fast_labels.push_back(&&RomLine279);
        main_exec_generated_fast_labels.push_back(&&RomLine280);
        main_exec_generated_fast_labels.push_back(&&RomLine281);
        main_exec_generated_fast_labels.push_back(&&RomLine282);
        main_exec_generated_fast_labels.push_back(&&RomLine283);
        main_exec_generated_fast_labels.push_back(&&RomLine284);
        main_exec_generated_fast_labels.push_back(&&RomLine285);
        main_exec_generated_fast_labels.push_back(&&RomLine286);
        main_exec_generated_fast_labels.push_back(&&RomLine287);
        main_exec_generated_fast_labels.push_back(&&RomLine288);
        main_exec_generated_fast_labels.push_back(&&RomLine289);
        main_exec_generated_fast_labels.push_back(&&RomLine290);
        main_exec_generated_fast_labels.push_back(&&RomLine291);
        main_exec_generated_fast_labels.push_back(&&RomLine292);
        main_exec_generated_fast_labels.push_back(&&RomLine293);
        main_exec_generated_fast_labels.push_back(&&RomLine294);
        main_exec_generated_fast_labels.push_back(&&RomLine295);
        main_exec_generated_fast_labels.push_back(&&RomLine296);
        main_exec_generated_fast_labels.push_back(&&RomLine297);
        main_exec_generated_fast_labels.push_back(&&RomLine298);
        main_exec_generated_fast_labels.push_back(&&RomLine299);
        main_exec_generated_fast_labels.push_back(&&RomLine300);
        main_exec_generated_fast_labels.push_back(&&RomLine301);
        main_exec_generated_fast_labels.push_back(&&RomLine302);
        main_exec_generated_fast_labels.push_back(&&RomLine303);
        main_exec_generated_fast_labels.push_back(&&RomLine304);
        main_exec_generated_fast_labels.push_back(&&RomLine305);
        main_exec_generated_fast_labels.push_back(&&RomLine306);
        main_exec_generated_fast_labels.push_back(&&RomLine307);
        main_exec_generated_fast_labels.push_back(&&RomLine308);
        main_exec_generated_fast_labels.push_back(&&RomLine309);
        main_exec_generated_fast_labels.push_back(&&RomLine310);
        main_exec_generated_fast_labels.push_back(&&RomLine311);
        main_exec_generated_fast_labels.push_back(&&RomLine312);
        main_exec_generated_fast_labels.push_back(&&RomLine313);
        main_exec_generated_fast_labels.push_back(&&RomLine314);
        main_exec_generated_fast_labels.push_back(&&RomLine315);
        main_exec_generated_fast_labels.push_back(&&RomLine316);
        main_exec_generated_fast_labels.push_back(&&RomLine317);
        main_exec_generated_fast_labels.push_back(&&RomLine318);
        main_exec_generated_fast_labels.push_back(&&RomLine319);
        main_exec_generated_fast_labels.push_back(&&RomLine320);
        main_exec_generated_fast_labels.push_back(&&RomLine321);
        main_exec_generated_fast_labels.push_back(&&RomLine322);
        main_exec_generated_fast_labels.push_back(&&RomLine323);
        main_exec_generated_fast_labels.push_back(&&RomLine324);
        main_exec_generated_fast_labels.push_back(&&RomLine325);
        main_exec_generated_fast_labels.push_back(&&RomLine326);
        main_exec_generated_fast_labels.push_back(&&RomLine327);
        main_exec_generated_fast_labels.push_back(&&RomLine328);
        main_exec_generated_fast_labels.push_back(&&RomLine329);
        main_exec_generated_fast_labels.push_back(&&RomLine330);
        main_exec_generated_fast_labels.push_back(&&RomLine331);
        main_exec_generated_fast_labels.push_back(&&RomLine332);
        main_exec_generated_fast_labels.push_back(&&RomLine333);
        main_exec_generated_fast_labels.push_back(&&RomLine334);
        main_exec_generated_fast_labels.push_back(&&RomLine335);
        main_exec_generated_fast_labels.push_back(&&RomLine336);
        main_exec_generated_fast_labels.push_back(&&RomLine337);
        main_exec_generated_fast_labels.push_back(&&RomLine338);
        main_exec_generated_fast_labels.push_back(&&RomLine339);
        main_exec_generated_fast_labels.push_back(&&RomLine340);
        main_exec_generated_fast_labels.push_back(&&RomLine341);
        main_exec_generated_fast_labels.push_back(&&RomLine342);
        main_exec_generated_fast_labels.push_back(&&RomLine343);
        main_exec_generated_fast_labels.push_back(&&RomLine344);
        main_exec_generated_fast_labels.push_back(&&RomLine345);
        main_exec_generated_fast_labels.push_back(&&RomLine346);
        main_exec_generated_fast_labels.push_back(&&RomLine347);
        main_exec_generated_fast_labels.push_back(&&RomLine348);
        main_exec_generated_fast_labels.push_back(&&RomLine349);
        main_exec_generated_fast_labels.push_back(&&RomLine350);
        main_exec_generated_fast_labels.push_back(&&RomLine351);
        main_exec_generated_fast_labels.push_back(&&RomLine352);
        main_exec_generated_fast_labels.push_back(&&RomLine353);
        main_exec_generated_fast_labels.push_back(&&RomLine354);
        main_exec_generated_fast_labels.push_back(&&RomLine355);
        main_exec_generated_fast_labels.push_back(&&RomLine356);
        main_exec_generated_fast_labels.push_back(&&RomLine357);
        main_exec_generated_fast_labels.push_back(&&RomLine358);
        main_exec_generated_fast_labels.push_back(&&RomLine359);
        main_exec_generated_fast_labels.push_back(&&RomLine360);
        main_exec_generated_fast_labels.push_back(&&RomLine361);
        main_exec_generated_fast_labels.push_back(&&RomLine362);
        main_exec_generated_fast_labels.push_back(&&RomLine363);
        main_exec_generated_fast_labels.push_back(&&RomLine364);
        main_exec_generated_fast_labels.push_back(&&RomLine365);
        main_exec_generated_fast_labels.push_back(&&RomLine366);
        main_exec_generated_fast_labels.push_back(&&RomLine367);
        main_exec_generated_fast_labels.push_back(&&RomLine368);
        main_exec_generated_fast_labels.push_back(&&RomLine369);
        main_exec_generated_fast_labels.push_back(&&RomLine370);
        main_exec_generated_fast_labels.push_back(&&RomLine371);
        main_exec_generated_fast_labels.push_back(&&RomLine372);
        main_exec_generated_fast_labels.push_back(&&RomLine373);
        main_exec_generated_fast_labels.push_back(&&RomLine374);
        main_exec_generated_fast_labels.push_back(&&RomLine375);
        main_exec_generated_fast_labels.push_back(&&RomLine376);
        main_exec_generated_fast_labels.push_back(&&RomLine377);
        main_exec_generated_fast_labels.push_back(&&RomLine378);
        main_exec_generated_fast_labels.push_back(&&RomLine379);
        main_exec_generated_fast_labels.push_back(&&RomLine380);
        main_exec_generated_fast_labels.push_back(&&RomLine381);
        main_exec_generated_fast_labels.push_back(&&RomLine382);
        main_exec_generated_fast_labels.push_back(&&RomLine383);
        main_exec_generated_fast_labels.push_back(&&RomLine384);
        main_exec_generated_fast_labels.push_back(&&RomLine385);
        main_exec_generated_fast_labels.push_back(&&RomLine386);
        main_exec_generated_fast_labels.push_back(&&RomLine387);
        main_exec_generated_fast_labels.push_back(&&RomLine388);
        main_exec_generated_fast_labels.push_back(&&RomLine389);
        main_exec_generated_fast_labels.push_back(&&RomLine390);
        main_exec_generated_fast_labels.push_back(&&RomLine391);
        main_exec_generated_fast_labels.push_back(&&RomLine392);
        main_exec_generated_fast_labels.push_back(&&RomLine393);
        main_exec_generated_fast_labels.push_back(&&RomLine394);
        main_exec_generated_fast_labels.push_back(&&RomLine395);
        main_exec_generated_fast_labels.push_back(&&RomLine396);
        main_exec_generated_fast_labels.push_back(&&RomLine397);
        main_exec_generated_fast_labels.push_back(&&RomLine398);
        main_exec_generated_fast_labels.push_back(&&RomLine399);
        main_exec_generated_fast_labels.push_back(&&RomLine400);
        main_exec_generated_fast_labels.push_back(&&RomLine401);
        main_exec_generated_fast_labels.push_back(&&RomLine402);
        main_exec_generated_fast_labels.push_back(&&RomLine403);
        main_exec_generated_fast_labels.push_back(&&RomLine404);
        main_exec_generated_fast_labels.push_back(&&RomLine405);
        main_exec_generated_fast_labels.push_back(&&RomLine406);
        main_exec_generated_fast_labels.push_back(&&RomLine407);
        main_exec_generated_fast_labels.push_back(&&RomLine408);
        main_exec_generated_fast_labels.push_back(&&RomLine409);
        main_exec_generated_fast_labels.push_back(&&RomLine410);
        main_exec_generated_fast_labels.push_back(&&RomLine411);
        main_exec_generated_fast_labels.push_back(&&RomLine412);
        main_exec_generated_fast_labels.push_back(&&RomLine413);
        main_exec_generated_fast_labels.push_back(&&RomLine414);
        main_exec_generated_fast_labels.push_back(&&RomLine415);
        main_exec_generated_fast_labels.push_back(&&RomLine416);
        main_exec_generated_fast_labels.push_back(&&RomLine417);
        main_exec_generated_fast_labels.push_back(&&RomLine418);
        main_exec_generated_fast_labels.push_back(&&RomLine419);
        main_exec_generated_fast_labels.push_back(&&RomLine420);
        main_exec_generated_fast_labels.push_back(&&RomLine421);
        main_exec_generated_fast_labels.push_back(&&RomLine422);
        main_exec_generated_fast_labels.push_back(&&RomLine423);
        main_exec_generated_fast_labels.push_back(&&RomLine424);
        main_exec_generated_fast_labels.push_back(&&RomLine425);
        main_exec_generated_fast_labels.push_back(&&RomLine426);
        main_exec_generated_fast_labels.push_back(&&RomLine427);
        main_exec_generated_fast_labels.push_back(&&RomLine428);
        main_exec_generated_fast_labels.push_back(&&RomLine429);
        main_exec_generated_fast_labels.push_back(&&RomLine430);
        main_exec_generated_fast_labels.push_back(&&RomLine431);
        main_exec_generated_fast_labels.push_back(&&RomLine432);
        main_exec_generated_fast_labels.push_back(&&RomLine433);
        main_exec_generated_fast_labels.push_back(&&RomLine434);
        main_exec_generated_fast_labels.push_back(&&RomLine435);
        main_exec_generated_fast_labels.push_back(&&RomLine436);
        main_exec_generated_fast_labels.push_back(&&RomLine437);
        main_exec_generated_fast_labels.push_back(&&RomLine438);
        main_exec_generated_fast_labels.push_back(&&RomLine439);
        main_exec_generated_fast_labels.push_back(&&RomLine440);
        main_exec_generated_fast_labels.push_back(&&RomLine441);
        main_exec_generated_fast_labels.push_back(&&RomLine442);
        main_exec_generated_fast_labels.push_back(&&RomLine443);
        main_exec_generated_fast_labels.push_back(&&RomLine444);
        main_exec_generated_fast_labels.push_back(&&RomLine445);
        main_exec_generated_fast_labels.push_back(&&RomLine446);
        main_exec_generated_fast_labels.push_back(&&RomLine447);
        main_exec_generated_fast_labels.push_back(&&RomLine448);
        main_exec_generated_fast_labels.push_back(&&RomLine449);
        main_exec_generated_fast_labels.push_back(&&RomLine450);
        main_exec_generated_fast_labels.push_back(&&RomLine451);
        main_exec_generated_fast_labels.push_back(&&RomLine452);
        main_exec_generated_fast_labels.push_back(&&RomLine453);
        main_exec_generated_fast_labels.push_back(&&RomLine454);
        main_exec_generated_fast_labels.push_back(&&RomLine455);
        main_exec_generated_fast_labels.push_back(&&RomLine456);
        main_exec_generated_fast_labels.push_back(&&RomLine457);
        main_exec_generated_fast_labels.push_back(&&RomLine458);
        main_exec_generated_fast_labels.push_back(&&RomLine459);
        main_exec_generated_fast_labels.push_back(&&RomLine460);
        main_exec_generated_fast_labels.push_back(&&RomLine461);
        main_exec_generated_fast_labels.push_back(&&RomLine462);
        main_exec_generated_fast_labels.push_back(&&RomLine463);
        main_exec_generated_fast_labels.push_back(&&RomLine464);
        main_exec_generated_fast_labels.push_back(&&RomLine465);
        main_exec_generated_fast_labels.push_back(&&RomLine466);
        main_exec_generated_fast_labels.push_back(&&RomLine467);
        main_exec_generated_fast_labels.push_back(&&RomLine468);
        main_exec_generated_fast_labels.push_back(&&RomLine469);
        main_exec_generated_fast_labels.push_back(&&RomLine470);
        main_exec_generated_fast_labels.push_back(&&RomLine471);
        main_exec_generated_fast_labels.push_back(&&RomLine472);
        main_exec_generated_fast_labels.push_back(&&RomLine473);
        main_exec_generated_fast_labels.push_back(&&RomLine474);
        main_exec_generated_fast_labels.push_back(&&RomLine475);
        main_exec_generated_fast_labels.push_back(&&RomLine476);
        main_exec_generated_fast_labels.push_back(&&RomLine477);
        main_exec_generated_fast_labels.push_back(&&RomLine478);
        main_exec_generated_fast_labels.push_back(&&RomLine479);
        main_exec_generated_fast_labels.push_back(&&RomLine480);
        main_exec_generated_fast_labels.push_back(&&RomLine481);
        main_exec_generated_fast_labels.push_back(&&RomLine482);
        main_exec_generated_fast_labels.push_back(&&RomLine483);
        main_exec_generated_fast_labels.push_back(&&RomLine484);
        main_exec_generated_fast_labels.push_back(&&RomLine485);
        main_exec_generated_fast_labels.push_back(&&RomLine486);
        main_exec_generated_fast_labels.push_back(&&RomLine487);
        main_exec_generated_fast_labels.push_back(&&RomLine488);
        main_exec_generated_fast_labels.push_back(&&RomLine489);
        main_exec_generated_fast_labels.push_back(&&RomLine490);
        main_exec_generated_fast_labels.push_back(&&RomLine491);
        main_exec_generated_fast_labels.push_back(&&RomLine492);
        main_exec_generated_fast_labels.push_back(&&RomLine493);
        main_exec_generated_fast_labels.push_back(&&RomLine494);
        main_exec_generated_fast_labels.push_back(&&RomLine495);
        main_exec_generated_fast_labels.push_back(&&RomLine496);
        main_exec_generated_fast_labels.push_back(&&RomLine497);
        main_exec_generated_fast_labels.push_back(&&RomLine498);
        main_exec_generated_fast_labels.push_back(&&RomLine499);
        main_exec_generated_fast_labels.push_back(&&RomLine500);
        main_exec_generated_fast_labels.push_back(&&RomLine501);
        main_exec_generated_fast_labels.push_back(&&RomLine502);
        main_exec_generated_fast_labels.push_back(&&RomLine503);
        main_exec_generated_fast_labels.push_back(&&RomLine504);
        main_exec_generated_fast_labels.push_back(&&RomLine505);
        main_exec_generated_fast_labels.push_back(&&RomLine506);
        main_exec_generated_fast_labels.push_back(&&RomLine507);
        main_exec_generated_fast_labels.push_back(&&RomLine508);
        main_exec_generated_fast_labels.push_back(&&RomLine509);
        main_exec_generated_fast_labels.push_back(&&RomLine510);
        main_exec_generated_fast_labels.push_back(&&RomLine511);
        main_exec_generated_fast_labels.push_back(&&RomLine512);
        main_exec_generated_fast_labels.push_back(&&RomLine513);
        main_exec_generated_fast_labels.push_back(&&RomLine514);
        main_exec_generated_fast_labels.push_back(&&RomLine515);
        main_exec_generated_fast_labels.push_back(&&RomLine516);
        main_exec_generated_fast_labels.push_back(&&RomLine517);
        main_exec_generated_fast_labels.push_back(&&RomLine518);
        main_exec_generated_fast_labels.push_back(&&RomLine519);
        main_exec_generated_fast_labels.push_back(&&RomLine520);
        main_exec_generated_fast_labels.push_back(&&RomLine521);
        main_exec_generated_fast_labels.push_back(&&RomLine522);
        main_exec_generated_fast_labels.push_back(&&RomLine523);
        main_exec_generated_fast_labels.push_back(&&RomLine524);
        main_exec_generated_fast_labels.push_back(&&RomLine525);
        main_exec_generated_fast_labels.push_back(&&RomLine526);
        main_exec_generated_fast_labels.push_back(&&RomLine527);
        main_exec_generated_fast_labels.push_back(&&RomLine528);
        main_exec_generated_fast_labels.push_back(&&RomLine529);
        main_exec_generated_fast_labels.push_back(&&RomLine530);
        main_exec_generated_fast_labels.push_back(&&RomLine531);
        main_exec_generated_fast_labels.push_back(&&RomLine532);
        main_exec_generated_fast_labels.push_back(&&RomLine533);
        main_exec_generated_fast_labels.push_back(&&RomLine534);
        main_exec_generated_fast_labels.push_back(&&RomLine535);
        main_exec_generated_fast_labels.push_back(&&RomLine536);
        main_exec_generated_fast_labels.push_back(&&RomLine537);
        main_exec_generated_fast_labels.push_back(&&RomLine538);
        main_exec_generated_fast_labels.push_back(&&RomLine539);
        main_exec_generated_fast_labels.push_back(&&RomLine540);
        main_exec_generated_fast_labels.push_back(&&RomLine541);
        main_exec_generated_fast_labels.push_back(&&RomLine542);
        main_exec_generated_fast_labels.push_back(&&RomLine543);
        main_exec_generated_fast_labels.push_back(&&RomLine544);
        main_exec_generated_fast_labels.push_back(&&RomLine545);
        main_exec_generated_fast_labels.push_back(&&RomLine546);
        main_exec_generated_fast_labels.push_back(&&RomLine547);
        main_exec_generated_fast_labels.push_back(&&RomLine548);
        main_exec_generated_fast_labels.push_back(&&RomLine549);
        main_exec_generated_fast_labels.push_back(&&RomLine550);
        main_exec_generated_fast_labels.push_back(&&RomLine551);
        main_exec_generated_fast_labels.push_back(&&RomLine552);
        main_exec_generated_fast_labels.push_back(&&RomLine553);
        main_exec_generated_fast_labels.push_back(&&RomLine554);
        main_exec_generated_fast_labels.push_back(&&RomLine555);
        main_exec_generated_fast_labels.push_back(&&RomLine556);
        main_exec_generated_fast_labels.push_back(&&RomLine557);
        main_exec_generated_fast_labels.push_back(&&RomLine558);
        main_exec_generated_fast_labels.push_back(&&RomLine559);
        main_exec_generated_fast_labels.push_back(&&RomLine560);
        main_exec_generated_fast_labels.push_back(&&RomLine561);
        main_exec_generated_fast_labels.push_back(&&RomLine562);
        main_exec_generated_fast_labels.push_back(&&RomLine563);
        main_exec_generated_fast_labels.push_back(&&RomLine564);
        main_exec_generated_fast_labels.push_back(&&RomLine565);
        main_exec_generated_fast_labels.push_back(&&RomLine566);
        main_exec_generated_fast_labels.push_back(&&RomLine567);
        main_exec_generated_fast_labels.push_back(&&RomLine568);
        main_exec_generated_fast_labels.push_back(&&RomLine569);
        main_exec_generated_fast_labels.push_back(&&RomLine570);
        main_exec_generated_fast_labels.push_back(&&RomLine571);
        main_exec_generated_fast_labels.push_back(&&RomLine572);
        main_exec_generated_fast_labels.push_back(&&RomLine573);
        main_exec_generated_fast_labels.push_back(&&RomLine574);
        main_exec_generated_fast_labels.push_back(&&RomLine575);
        main_exec_generated_fast_labels.push_back(&&RomLine576);
        main_exec_generated_fast_labels.push_back(&&RomLine577);
        main_exec_generated_fast_labels.push_back(&&RomLine578);
        main_exec_generated_fast_labels.push_back(&&RomLine579);
        main_exec_generated_fast_labels.push_back(&&RomLine580);
        main_exec_generated_fast_labels.push_back(&&RomLine581);
        main_exec_generated_fast_labels.push_back(&&RomLine582);
        main_exec_generated_fast_labels.push_back(&&RomLine583);
        main_exec_generated_fast_labels.push_back(&&RomLine584);
        main_exec_generated_fast_labels.push_back(&&RomLine585);
        main_exec_generated_fast_labels.push_back(&&RomLine586);
        main_exec_generated_fast_labels.push_back(&&RomLine587);
        main_exec_generated_fast_labels.push_back(&&RomLine588);
        main_exec_generated_fast_labels.push_back(&&RomLine589);
        main_exec_generated_fast_labels.push_back(&&RomLine590);
        main_exec_generated_fast_labels.push_back(&&RomLine591);
        main_exec_generated_fast_labels.push_back(&&RomLine592);
        main_exec_generated_fast_labels.push_back(&&RomLine593);
        main_exec_generated_fast_labels.push_back(&&RomLine594);
        main_exec_generated_fast_labels.push_back(&&RomLine595);
        main_exec_generated_fast_labels.push_back(&&RomLine596);
        main_exec_generated_fast_labels.push_back(&&RomLine597);
        main_exec_generated_fast_labels.push_back(&&RomLine598);
        main_exec_generated_fast_labels.push_back(&&RomLine599);
        main_exec_generated_fast_labels.push_back(&&RomLine600);
        main_exec_generated_fast_labels.push_back(&&RomLine601);
        main_exec_generated_fast_labels.push_back(&&RomLine602);
        main_exec_generated_fast_labels.push_back(&&RomLine603);
        main_exec_generated_fast_labels.push_back(&&RomLine604);
        main_exec_generated_fast_labels.push_back(&&RomLine605);
        main_exec_generated_fast_labels.push_back(&&RomLine606);
        main_exec_generated_fast_labels.push_back(&&RomLine607);
        main_exec_generated_fast_labels.push_back(&&RomLine608);
        main_exec_generated_fast_labels.push_back(&&RomLine609);
        main_exec_generated_fast_labels.push_back(&&RomLine610);
        main_exec_generated_fast_labels.push_back(&&RomLine611);
        main_exec_generated_fast_labels.push_back(&&RomLine612);
        main_exec_generated_fast_labels.push_back(&&RomLine613);
        main_exec_generated_fast_labels.push_back(&&RomLine614);
        main_exec_generated_fast_labels.push_back(&&RomLine615);
        main_exec_generated_fast_labels.push_back(&&RomLine616);
        main_exec_generated_fast_labels.push_back(&&RomLine617);
        main_exec_generated_fast_labels.push_back(&&RomLine618);
        main_exec_generated_fast_labels.push_back(&&RomLine619);
        main_exec_generated_fast_labels.push_back(&&RomLine620);
        main_exec_generated_fast_labels.push_back(&&RomLine621);
        main_exec_generated_fast_labels.push_back(&&RomLine622);
        main_exec_generated_fast_labels.push_back(&&RomLine623);
        main_exec_generated_fast_labels.push_back(&&RomLine624);
        main_exec_generated_fast_labels.push_back(&&RomLine625);
        main_exec_generated_fast_labels.push_back(&&RomLine626);
        main_exec_generated_fast_labels.push_back(&&RomLine627);
        main_exec_generated_fast_labels.push_back(&&RomLine628);
        main_exec_generated_fast_labels.push_back(&&RomLine629);
        main_exec_generated_fast_labels.push_back(&&RomLine630);
        main_exec_generated_fast_labels.push_back(&&RomLine631);
        main_exec_generated_fast_labels.push_back(&&RomLine632);
        main_exec_generated_fast_labels.push_back(&&RomLine633);
        main_exec_generated_fast_labels.push_back(&&RomLine634);
        main_exec_generated_fast_labels.push_back(&&RomLine635);
        main_exec_generated_fast_labels.push_back(&&RomLine636);
        main_exec_generated_fast_labels.push_back(&&RomLine637);
        main_exec_generated_fast_labels.push_back(&&RomLine638);
        main_exec_generated_fast_labels.push_back(&&RomLine639);
        main_exec_generated_fast_labels.push_back(&&RomLine640);
        main_exec_generated_fast_labels.push_back(&&RomLine641);
        main_exec_generated_fast_labels.push_back(&&RomLine642);
        main_exec_generated_fast_labels.push_back(&&RomLine643);
        main_exec_generated_fast_labels.push_back(&&RomLine644);
        main_exec_generated_fast_labels.push_back(&&RomLine645);
        main_exec_generated_fast_labels.push_back(&&RomLine646);
        main_exec_generated_fast_labels.push_back(&&RomLine647);
        main_exec_generated_fast_labels.push_back(&&RomLine648);
        main_exec_generated_fast_labels.push_back(&&RomLine649);
        main_exec_generated_fast_labels.push_back(&&RomLine650);
        main_exec_generated_fast_labels.push_back(&&RomLine651);
        main_exec_generated_fast_labels.push_back(&&RomLine652);
        main_exec_generated_fast_labels.push_back(&&RomLine653);
        main_exec_generated_fast_labels.push_back(&&RomLine654);
        main_exec_generated_fast_labels.push_back(&&RomLine655);
        main_exec_generated_fast_labels.push_back(&&RomLine656);
        main_exec_generated_fast_labels.push_back(&&RomLine657);
        main_exec_generated_fast_labels.push_back(&&RomLine658);
        main_exec_generated_fast_labels.push_back(&&RomLine659);
        main_exec_generated_fast_labels.push_back(&&RomLine660);
        main_exec_generated_fast_labels.push_back(&&RomLine661);
        main_exec_generated_fast_labels.push_back(&&RomLine662);
        main_exec_generated_fast_labels.push_back(&&RomLine663);
        main_exec_generated_fast_labels.push_back(&&RomLine664);
        main_exec_generated_fast_labels.push_back(&&RomLine665);
        main_exec_generated_fast_labels.push_back(&&RomLine666);
        main_exec_generated_fast_labels.push_back(&&RomLine667);
        main_exec_generated_fast_labels.push_back(&&RomLine668);
        main_exec_generated_fast_labels.push_back(&&RomLine669);
        main_exec_generated_fast_labels.push_back(&&RomLine670);
        main_exec_generated_fast_labels.push_back(&&RomLine671);
        main_exec_generated_fast_labels.push_back(&&RomLine672);
        main_exec_generated_fast_labels.push_back(&&RomLine673);
        main_exec_generated_fast_labels.push_back(&&RomLine674);
        main_exec_generated_fast_labels.push_back(&&RomLine675);
        main_exec_generated_fast_labels.push_back(&&RomLine676);
        main_exec_generated_fast_labels.push_back(&&RomLine677);
        main_exec_generated_fast_labels.push_back(&&RomLine678);
        main_exec_generated_fast_labels.push_back(&&RomLine679);
        main_exec_generated_fast_labels.push_back(&&RomLine680);
        main_exec_generated_fast_labels.push_back(&&RomLine681);
        main_exec_generated_fast_labels.push_back(&&RomLine682);
        main_exec_generated_fast_labels.push_back(&&RomLine683);
        main_exec_generated_fast_labels.push_back(&&RomLine684);
        main_exec_generated_fast_labels.push_back(&&RomLine685);
        main_exec_generated_fast_labels.push_back(&&RomLine686);
        main_exec_generated_fast_labels.push_back(&&RomLine687);
        main_exec_generated_fast_labels.push_back(&&RomLine688);
        main_exec_generated_fast_labels.push_back(&&RomLine689);
        main_exec_generated_fast_labels.push_back(&&RomLine690);
        main_exec_generated_fast_labels.push_back(&&RomLine691);
        main_exec_generated_fast_labels.push_back(&&RomLine692);
        main_exec_generated_fast_labels.push_back(&&RomLine693);
        main_exec_generated_fast_labels.push_back(&&RomLine694);
        main_exec_generated_fast_labels.push_back(&&RomLine695);
        main_exec_generated_fast_labels.push_back(&&RomLine696);
        main_exec_generated_fast_labels.push_back(&&RomLine697);
        main_exec_generated_fast_labels.push_back(&&RomLine698);
        main_exec_generated_fast_labels.push_back(&&RomLine699);
        main_exec_generated_fast_labels.push_back(&&RomLine700);
        main_exec_generated_fast_labels.push_back(&&RomLine701);
        main_exec_generated_fast_labels.push_back(&&RomLine702);
        main_exec_generated_fast_labels.push_back(&&RomLine703);
        main_exec_generated_fast_labels.push_back(&&RomLine704);
        main_exec_generated_fast_labels.push_back(&&RomLine705);
        main_exec_generated_fast_labels.push_back(&&RomLine706);
        main_exec_generated_fast_labels.push_back(&&RomLine707);
        main_exec_generated_fast_labels.push_back(&&RomLine708);
        main_exec_generated_fast_labels.push_back(&&RomLine709);
        main_exec_generated_fast_labels.push_back(&&RomLine710);
        main_exec_generated_fast_labels.push_back(&&RomLine711);
        main_exec_generated_fast_labels.push_back(&&RomLine712);
        main_exec_generated_fast_labels.push_back(&&RomLine713);
        main_exec_generated_fast_labels.push_back(&&RomLine714);
        main_exec_generated_fast_labels.push_back(&&RomLine715);
        main_exec_generated_fast_labels.push_back(&&RomLine716);
        main_exec_generated_fast_labels.push_back(&&RomLine717);
        main_exec_generated_fast_labels.push_back(&&RomLine718);
        main_exec_generated_fast_labels.push_back(&&RomLine719);
        main_exec_generated_fast_labels.push_back(&&RomLine720);
        main_exec_generated_fast_labels.push_back(&&RomLine721);
        main_exec_generated_fast_labels.push_back(&&RomLine722);
        main_exec_generated_fast_labels.push_back(&&RomLine723);
        main_exec_generated_fast_labels.push_back(&&RomLine724);
        main_exec_generated_fast_labels.push_back(&&RomLine725);
        main_exec_generated_fast_labels.push_back(&&RomLine726);
        main_exec_generated_fast_labels.push_back(&&RomLine727);
        main_exec_generated_fast_labels.push_back(&&RomLine728);
        main_exec_generated_fast_labels.push_back(&&RomLine729);
        main_exec_generated_fast_labels.push_back(&&RomLine730);
        main_exec_generated_fast_labels.push_back(&&RomLine731);
        main_exec_generated_fast_labels.push_back(&&RomLine732);
        main_exec_generated_fast_labels.push_back(&&RomLine733);
        main_exec_generated_fast_labels.push_back(&&RomLine734);
        main_exec_generated_fast_labels.push_back(&&RomLine735);
        main_exec_generated_fast_labels.push_back(&&RomLine736);
        main_exec_generated_fast_labels.push_back(&&RomLine737);
        main_exec_generated_fast_labels.push_back(&&RomLine738);
        main_exec_generated_fast_labels.push_back(&&RomLine739);
        main_exec_generated_fast_labels.push_back(&&RomLine740);
        main_exec_generated_fast_labels.push_back(&&RomLine741);
        main_exec_generated_fast_labels.push_back(&&RomLine742);
        main_exec_generated_fast_labels.push_back(&&RomLine743);
        main_exec_generated_fast_labels.push_back(&&RomLine744);
        main_exec_generated_fast_labels.push_back(&&RomLine745);
        main_exec_generated_fast_labels.push_back(&&RomLine746);
        main_exec_generated_fast_labels.push_back(&&RomLine747);
        main_exec_generated_fast_labels.push_back(&&RomLine748);
        main_exec_generated_fast_labels.push_back(&&RomLine749);
        main_exec_generated_fast_labels.push_back(&&RomLine750);
        main_exec_generated_fast_labels.push_back(&&RomLine751);
        main_exec_generated_fast_labels.push_back(&&RomLine752);
        main_exec_generated_fast_labels.push_back(&&RomLine753);
        main_exec_generated_fast_labels.push_back(&&RomLine754);
        main_exec_generated_fast_labels.push_back(&&RomLine755);
        main_exec_generated_fast_labels.push_back(&&RomLine756);
        main_exec_generated_fast_labels.push_back(&&RomLine757);
        main_exec_generated_fast_labels.push_back(&&RomLine758);
        main_exec_generated_fast_labels.push_back(&&RomLine759);
        main_exec_generated_fast_labels.push_back(&&RomLine760);
        main_exec_generated_fast_labels.push_back(&&RomLine761);
        main_exec_generated_fast_labels.push_back(&&RomLine762);
        main_exec_generated_fast_labels.push_back(&&RomLine763);
        main_exec_generated_fast_labels.push_back(&&RomLine764);
        main_exec_generated_fast_labels.push_back(&&RomLine765);
        main_exec_generated_fast_labels.push_back(&&RomLine766);
        main_exec_generated_fast_labels.push_back(&&RomLine767);
        main_exec_generated_fast_labels.push_back(&&RomLine768);
        main_exec_generated_fast_labels.push_back(&&RomLine769);
        main_exec_generated_fast_labels.push_back(&&RomLine770);
        main_exec_generated_fast_labels.push_back(&&RomLine771);
        main_exec_generated_fast_labels.push_back(&&RomLine772);
        main_exec_generated_fast_labels.push_back(&&RomLine773);
        main_exec_generated_fast_labels.push_back(&&RomLine774);
        main_exec_generated_fast_labels.push_back(&&RomLine775);
        main_exec_generated_fast_labels.push_back(&&RomLine776);
        main_exec_generated_fast_labels.push_back(&&RomLine777);
        main_exec_generated_fast_labels.push_back(&&RomLine778);
        main_exec_generated_fast_labels.push_back(&&RomLine779);
        main_exec_generated_fast_labels.push_back(&&RomLine780);
        main_exec_generated_fast_labels.push_back(&&RomLine781);
        main_exec_generated_fast_labels.push_back(&&RomLine782);
        main_exec_generated_fast_labels.push_back(&&RomLine783);
        main_exec_generated_fast_labels.push_back(&&RomLine784);
        main_exec_generated_fast_labels.push_back(&&RomLine785);
        main_exec_generated_fast_labels.push_back(&&RomLine786);
        main_exec_generated_fast_labels.push_back(&&RomLine787);
        main_exec_generated_fast_labels.push_back(&&RomLine788);
        main_exec_generated_fast_labels.push_back(&&RomLine789);
        main_exec_generated_fast_labels.push_back(&&RomLine790);
        main_exec_generated_fast_labels.push_back(&&RomLine791);
        main_exec_generated_fast_labels.push_back(&&RomLine792);
        main_exec_generated_fast_labels.push_back(&&RomLine793);
        main_exec_generated_fast_labels.push_back(&&RomLine794);
        main_exec_generated_fast_labels.push_back(&&RomLine795);
        main_exec_generated_fast_labels.push_back(&&RomLine796);
        main_exec_generated_fast_labels.push_back(&&RomLine797);
        main_exec_generated_fast_labels.push_back(&&RomLine798);
        main_exec_generated_fast_labels.push_back(&&RomLine799);
        main_exec_generated_fast_labels.push_back(&&RomLine800);
        main_exec_generated_fast_labels.push_back(&&RomLine801);
        main_exec_generated_fast_labels.push_back(&&RomLine802);
        main_exec_generated_fast_labels.push_back(&&RomLine803);
        main_exec_generated_fast_labels.push_back(&&RomLine804);
        main_exec_generated_fast_labels.push_back(&&RomLine805);
        main_exec_generated_fast_labels.push_back(&&RomLine806);
        main_exec_generated_fast_labels.push_back(&&RomLine807);
        main_exec_generated_fast_labels.push_back(&&RomLine808);
        main_exec_generated_fast_labels.push_back(&&RomLine809);
        main_exec_generated_fast_labels.push_back(&&RomLine810);
        main_exec_generated_fast_labels.push_back(&&RomLine811);
        main_exec_generated_fast_labels.push_back(&&RomLine812);
        main_exec_generated_fast_labels.push_back(&&RomLine813);
        main_exec_generated_fast_labels.push_back(&&RomLine814);
        main_exec_generated_fast_labels.push_back(&&RomLine815);
        main_exec_generated_fast_labels.push_back(&&RomLine816);
        main_exec_generated_fast_labels.push_back(&&RomLine817);
        main_exec_generated_fast_labels.push_back(&&RomLine818);
        main_exec_generated_fast_labels.push_back(&&RomLine819);
        main_exec_generated_fast_labels.push_back(&&RomLine820);
        main_exec_generated_fast_labels.push_back(&&RomLine821);
        main_exec_generated_fast_labels.push_back(&&RomLine822);
        main_exec_generated_fast_labels.push_back(&&RomLine823);
        main_exec_generated_fast_labels.push_back(&&RomLine824);
        main_exec_generated_fast_labels.push_back(&&RomLine825);
        main_exec_generated_fast_labels.push_back(&&RomLine826);
        main_exec_generated_fast_labels.push_back(&&RomLine827);
        main_exec_generated_fast_labels.push_back(&&RomLine828);
        main_exec_generated_fast_labels.push_back(&&RomLine829);
        main_exec_generated_fast_labels.push_back(&&RomLine830);
        main_exec_generated_fast_labels.push_back(&&RomLine831);
        main_exec_generated_fast_labels.push_back(&&RomLine832);
        main_exec_generated_fast_labels.push_back(&&RomLine833);
        main_exec_generated_fast_labels.push_back(&&RomLine834);
        main_exec_generated_fast_labels.push_back(&&RomLine835);
        main_exec_generated_fast_labels.push_back(&&RomLine836);
        main_exec_generated_fast_labels.push_back(&&RomLine837);
        main_exec_generated_fast_labels.push_back(&&RomLine838);
        main_exec_generated_fast_labels.push_back(&&RomLine839);
        main_exec_generated_fast_labels.push_back(&&RomLine840);
        main_exec_generated_fast_labels.push_back(&&RomLine841);
        main_exec_generated_fast_labels.push_back(&&RomLine842);
        main_exec_generated_fast_labels.push_back(&&RomLine843);
        main_exec_generated_fast_labels.push_back(&&RomLine844);
        main_exec_generated_fast_labels.push_back(&&RomLine845);
        main_exec_generated_fast_labels.push_back(&&RomLine846);
        main_exec_generated_fast_labels.push_back(&&RomLine847);
        main_exec_generated_fast_labels.push_back(&&RomLine848);
        main_exec_generated_fast_labels.push_back(&&RomLine849);
        main_exec_generated_fast_labels.push_back(&&RomLine850);
        main_exec_generated_fast_labels.push_back(&&RomLine851);
        main_exec_generated_fast_labels.push_back(&&RomLine852);
        main_exec_generated_fast_labels.push_back(&&RomLine853);
        main_exec_generated_fast_labels.push_back(&&RomLine854);
        main_exec_generated_fast_labels.push_back(&&RomLine855);
        main_exec_generated_fast_labels.push_back(&&RomLine856);
        main_exec_generated_fast_labels.push_back(&&RomLine857);
        main_exec_generated_fast_labels.push_back(&&RomLine858);
        main_exec_generated_fast_labels.push_back(&&RomLine859);
        main_exec_generated_fast_labels.push_back(&&RomLine860);
        main_exec_generated_fast_labels.push_back(&&RomLine861);
        main_exec_generated_fast_labels.push_back(&&RomLine862);
        main_exec_generated_fast_labels.push_back(&&RomLine863);
        main_exec_generated_fast_labels.push_back(&&RomLine864);
        main_exec_generated_fast_labels.push_back(&&RomLine865);
        main_exec_generated_fast_labels.push_back(&&RomLine866);
        main_exec_generated_fast_labels.push_back(&&RomLine867);
        main_exec_generated_fast_labels.push_back(&&RomLine868);
        main_exec_generated_fast_labels.push_back(&&RomLine869);
        main_exec_generated_fast_labels.push_back(&&RomLine870);
        main_exec_generated_fast_labels.push_back(&&RomLine871);
        main_exec_generated_fast_labels.push_back(&&RomLine872);
        main_exec_generated_fast_labels.push_back(&&RomLine873);
        main_exec_generated_fast_labels.push_back(&&RomLine874);
        main_exec_generated_fast_labels.push_back(&&RomLine875);
        main_exec_generated_fast_labels.push_back(&&RomLine876);
        main_exec_generated_fast_labels.push_back(&&RomLine877);
        main_exec_generated_fast_labels.push_back(&&RomLine878);
        main_exec_generated_fast_labels.push_back(&&RomLine879);
        main_exec_generated_fast_labels.push_back(&&RomLine880);
        main_exec_generated_fast_labels.push_back(&&RomLine881);
        main_exec_generated_fast_labels.push_back(&&RomLine882);
        main_exec_generated_fast_labels.push_back(&&RomLine883);
        main_exec_generated_fast_labels.push_back(&&RomLine884);
        main_exec_generated_fast_labels.push_back(&&RomLine885);
        main_exec_generated_fast_labels.push_back(&&RomLine886);
        main_exec_generated_fast_labels.push_back(&&RomLine887);
        main_exec_generated_fast_labels.push_back(&&RomLine888);
        main_exec_generated_fast_labels.push_back(&&RomLine889);
        main_exec_generated_fast_labels.push_back(&&RomLine890);
        main_exec_generated_fast_labels.push_back(&&RomLine891);
        main_exec_generated_fast_labels.push_back(&&RomLine892);
        main_exec_generated_fast_labels.push_back(&&RomLine893);
        main_exec_generated_fast_labels.push_back(&&RomLine894);
        main_exec_generated_fast_labels.push_back(&&RomLine895);
        main_exec_generated_fast_labels.push_back(&&RomLine896);
        main_exec_generated_fast_labels.push_back(&&RomLine897);
        main_exec_generated_fast_labels.push_back(&&RomLine898);
        main_exec_generated_fast_labels.push_back(&&RomLine899);
        main_exec_generated_fast_labels.push_back(&&RomLine900);
        main_exec_generated_fast_labels.push_back(&&RomLine901);
        main_exec_generated_fast_labels.push_back(&&RomLine902);
        main_exec_generated_fast_labels.push_back(&&RomLine903);
        main_exec_generated_fast_labels.push_back(&&RomLine904);
        main_exec_generated_fast_labels.push_back(&&RomLine905);
        main_exec_generated_fast_labels.push_back(&&RomLine906);
        main_exec_generated_fast_labels.push_back(&&RomLine907);
        main_exec_generated_fast_labels.push_back(&&RomLine908);
        main_exec_generated_fast_labels.push_back(&&RomLine909);
        main_exec_generated_fast_labels.push_back(&&RomLine910);
        main_exec_generated_fast_labels.push_back(&&RomLine911);
        main_exec_generated_fast_labels.push_back(&&RomLine912);
        main_exec_generated_fast_labels.push_back(&&RomLine913);
        main_exec_generated_fast_labels.push_back(&&RomLine914);
        main_exec_generated_fast_labels.push_back(&&RomLine915);
        main_exec_generated_fast_labels.push_back(&&RomLine916);
        main_exec_generated_fast_labels.push_back(&&RomLine917);
        main_exec_generated_fast_labels.push_back(&&RomLine918);
        main_exec_generated_fast_labels.push_back(&&RomLine919);
        main_exec_generated_fast_labels.push_back(&&RomLine920);
        main_exec_generated_fast_labels.push_back(&&RomLine921);
        main_exec_generated_fast_labels.push_back(&&RomLine922);
        main_exec_generated_fast_labels.push_back(&&RomLine923);
        main_exec_generated_fast_labels.push_back(&&RomLine924);
        main_exec_generated_fast_labels.push_back(&&RomLine925);
        main_exec_generated_fast_labels.push_back(&&RomLine926);
        main_exec_generated_fast_labels.push_back(&&RomLine927);
        main_exec_generated_fast_labels.push_back(&&RomLine928);
        main_exec_generated_fast_labels.push_back(&&RomLine929);
        main_exec_generated_fast_labels.push_back(&&RomLine930);
        main_exec_generated_fast_labels.push_back(&&RomLine931);
        main_exec_generated_fast_labels.push_back(&&RomLine932);
        main_exec_generated_fast_labels.push_back(&&RomLine933);
        main_exec_generated_fast_labels.push_back(&&RomLine934);
        main_exec_generated_fast_labels.push_back(&&RomLine935);
        main_exec_generated_fast_labels.push_back(&&RomLine936);
        main_exec_generated_fast_labels.push_back(&&RomLine937);
        main_exec_generated_fast_labels.push_back(&&RomLine938);
        main_exec_generated_fast_labels.push_back(&&RomLine939);
        main_exec_generated_fast_labels.push_back(&&RomLine940);
        main_exec_generated_fast_labels.push_back(&&RomLine941);
        main_exec_generated_fast_labels.push_back(&&RomLine942);
        main_exec_generated_fast_labels.push_back(&&RomLine943);
        main_exec_generated_fast_labels.push_back(&&RomLine944);
        main_exec_generated_fast_labels.push_back(&&RomLine945);
        main_exec_generated_fast_labels.push_back(&&RomLine946);
        main_exec_generated_fast_labels.push_back(&&RomLine947);
        main_exec_generated_fast_labels.push_back(&&RomLine948);
        main_exec_generated_fast_labels.push_back(&&RomLine949);
        main_exec_generated_fast_labels.push_back(&&RomLine950);
        main_exec_generated_fast_labels.push_back(&&RomLine951);
        main_exec_generated_fast_labels.push_back(&&RomLine952);
        main_exec_generated_fast_labels.push_back(&&RomLine953);
        main_exec_generated_fast_labels.push_back(&&RomLine954);
        main_exec_generated_fast_labels.push_back(&&RomLine955);
        main_exec_generated_fast_labels.push_back(&&RomLine956);
        main_exec_generated_fast_labels.push_back(&&RomLine957);
        main_exec_generated_fast_labels.push_back(&&RomLine958);
        main_exec_generated_fast_labels.push_back(&&RomLine959);
        main_exec_generated_fast_labels.push_back(&&RomLine960);
        main_exec_generated_fast_labels.push_back(&&RomLine961);
        main_exec_generated_fast_labels.push_back(&&RomLine962);
        main_exec_generated_fast_labels.push_back(&&RomLine963);
        main_exec_generated_fast_labels.push_back(&&RomLine964);
        main_exec_generated_fast_labels.push_back(&&RomLine965);
        main_exec_generated_fast_labels.push_back(&&RomLine966);
        main_exec_generated_fast_labels.push_back(&&RomLine967);
        main_exec_generated_fast_labels.push_back(&&RomLine968);
        main_exec_generated_fast_labels.push_back(&&RomLine969);
        main_exec_generated_fast_labels.push_back(&&RomLine970);
        main_exec_generated_fast_labels.push_back(&&RomLine971);
        main_exec_generated_fast_labels.push_back(&&RomLine972);
        main_exec_generated_fast_labels.push_back(&&RomLine973);
        main_exec_generated_fast_labels.push_back(&&RomLine974);
        main_exec_generated_fast_labels.push_back(&&RomLine975);
        main_exec_generated_fast_labels.push_back(&&RomLine976);
        main_exec_generated_fast_labels.push_back(&&RomLine977);
        main_exec_generated_fast_labels.push_back(&&RomLine978);
        main_exec_generated_fast_labels.push_back(&&RomLine979);
        main_exec_generated_fast_labels.push_back(&&RomLine980);
        main_exec_generated_fast_labels.push_back(&&RomLine981);
        main_exec_generated_fast_labels.push_back(&&RomLine982);
        main_exec_generated_fast_labels.push_back(&&RomLine983);
        main_exec_generated_fast_labels.push_back(&&RomLine984);
        main_exec_generated_fast_labels.push_back(&&RomLine985);
        main_exec_generated_fast_labels.push_back(&&RomLine986);
        main_exec_generated_fast_labels.push_back(&&RomLine987);
        main_exec_generated_fast_labels.push_back(&&RomLine988);
        main_exec_generated_fast_labels.push_back(&&RomLine989);
        main_exec_generated_fast_labels.push_back(&&RomLine990);
        main_exec_generated_fast_labels.push_back(&&RomLine991);
        main_exec_generated_fast_labels.push_back(&&RomLine992);
        main_exec_generated_fast_labels.push_back(&&RomLine993);
        main_exec_generated_fast_labels.push_back(&&RomLine994);
        main_exec_generated_fast_labels.push_back(&&RomLine995);
        main_exec_generated_fast_labels.push_back(&&RomLine996);
        main_exec_generated_fast_labels.push_back(&&RomLine997);
        main_exec_generated_fast_labels.push_back(&&RomLine998);
        main_exec_generated_fast_labels.push_back(&&RomLine999);
        main_exec_generated_fast_labels.push_back(&&RomLine1000);
        main_exec_generated_fast_labels.push_back(&&RomLine1001);
        main_exec_generated_fast_labels.push_back(&&RomLine1002);
        main_exec_generated_fast_labels.push_back(&&RomLine1003);
        main_exec_generated_fast_labels.push_back(&&RomLine1004);
        main_exec_generated_fast_labels.push_back(&&RomLine1005);
        main_exec_generated_fast_labels.push_back(&&RomLine1006);
        main_exec_generated_fast_labels.push_back(&&RomLine1007);
        main_exec_generated_fast_labels.push_back(&&RomLine1008);
        main_exec_generated_fast_labels.push_back(&&RomLine1009);
        main_exec_generated_fast_labels.push_back(&&RomLine1010);
        main_exec_generated_fast_labels.push_back(&&RomLine1011);
        main_exec_generated_fast_labels.push_back(&&RomLine1012);
        main_exec_generated_fast_labels.push_back(&&RomLine1013);
        main_exec_generated_fast_labels.push_back(&&RomLine1014);
        main_exec_generated_fast_labels.push_back(&&RomLine1015);
        main_exec_generated_fast_labels.push_back(&&RomLine1016);
        main_exec_generated_fast_labels.push_back(&&RomLine1017);
        main_exec_generated_fast_labels.push_back(&&RomLine1018);
        main_exec_generated_fast_labels.push_back(&&RomLine1019);
        main_exec_generated_fast_labels.push_back(&&RomLine1020);
        main_exec_generated_fast_labels.push_back(&&RomLine1021);
        main_exec_generated_fast_labels.push_back(&&RomLine1022);
        main_exec_generated_fast_labels.push_back(&&RomLine1023);
        main_exec_generated_fast_labels.push_back(&&RomLine1024);
        main_exec_generated_fast_labels.push_back(&&RomLine1025);
        main_exec_generated_fast_labels.push_back(&&RomLine1026);
        main_exec_generated_fast_labels.push_back(&&RomLine1027);
        main_exec_generated_fast_labels.push_back(&&RomLine1028);
        main_exec_generated_fast_labels.push_back(&&RomLine1029);
        main_exec_generated_fast_labels.push_back(&&RomLine1030);
        main_exec_generated_fast_labels.push_back(&&RomLine1031);
        main_exec_generated_fast_labels.push_back(&&RomLine1032);
        main_exec_generated_fast_labels.push_back(&&RomLine1033);
        main_exec_generated_fast_labels.push_back(&&RomLine1034);
        main_exec_generated_fast_labels.push_back(&&RomLine1035);
        main_exec_generated_fast_labels.push_back(&&RomLine1036);
        main_exec_generated_fast_labels.push_back(&&RomLine1037);
        main_exec_generated_fast_labels.push_back(&&RomLine1038);
        main_exec_generated_fast_labels.push_back(&&RomLine1039);
        main_exec_generated_fast_labels.push_back(&&RomLine1040);
        main_exec_generated_fast_labels.push_back(&&RomLine1041);
        main_exec_generated_fast_labels.push_back(&&RomLine1042);
        main_exec_generated_fast_labels.push_back(&&RomLine1043);
        main_exec_generated_fast_labels.push_back(&&RomLine1044);
        main_exec_generated_fast_labels.push_back(&&RomLine1045);
        main_exec_generated_fast_labels.push_back(&&RomLine1046);
        main_exec_generated_fast_labels.push_back(&&RomLine1047);
        main_exec_generated_fast_labels.push_back(&&RomLine1048);
        main_exec_generated_fast_labels.push_back(&&RomLine1049);
        main_exec_generated_fast_labels.push_back(&&RomLine1050);
        main_exec_generated_fast_labels.push_back(&&RomLine1051);
        main_exec_generated_fast_labels.push_back(&&RomLine1052);
        main_exec_generated_fast_labels.push_back(&&RomLine1053);
        main_exec_generated_fast_labels.push_back(&&RomLine1054);
        main_exec_generated_fast_labels.push_back(&&RomLine1055);
        main_exec_generated_fast_labels.push_back(&&RomLine1056);
        main_exec_generated_fast_labels.push_back(&&RomLine1057);
        main_exec_generated_fast_labels.push_back(&&RomLine1058);
        main_exec_generated_fast_labels.push_back(&&RomLine1059);
        main_exec_generated_fast_labels.push_back(&&RomLine1060);
        main_exec_generated_fast_labels.push_back(&&RomLine1061);
        main_exec_generated_fast_labels.push_back(&&RomLine1062);
        main_exec_generated_fast_labels.push_back(&&RomLine1063);
        main_exec_generated_fast_labels.push_back(&&RomLine1064);
        main_exec_generated_fast_labels.push_back(&&RomLine1065);
        main_exec_generated_fast_labels.push_back(&&RomLine1066);
        main_exec_generated_fast_labels.push_back(&&RomLine1067);
        main_exec_generated_fast_labels.push_back(&&RomLine1068);
        main_exec_generated_fast_labels.push_back(&&RomLine1069);
        main_exec_generated_fast_labels.push_back(&&RomLine1070);
        main_exec_generated_fast_labels.push_back(&&RomLine1071);
        main_exec_generated_fast_labels.push_back(&&RomLine1072);
        main_exec_generated_fast_labels.push_back(&&RomLine1073);
        main_exec_generated_fast_labels.push_back(&&RomLine1074);
        main_exec_generated_fast_labels.push_back(&&RomLine1075);
        main_exec_generated_fast_labels.push_back(&&RomLine1076);
        main_exec_generated_fast_labels.push_back(&&RomLine1077);
        main_exec_generated_fast_labels.push_back(&&RomLine1078);
        main_exec_generated_fast_labels.push_back(&&RomLine1079);
        main_exec_generated_fast_labels.push_back(&&RomLine1080);
        main_exec_generated_fast_labels.push_back(&&RomLine1081);
        main_exec_generated_fast_labels.push_back(&&RomLine1082);
        main_exec_generated_fast_labels.push_back(&&RomLine1083);
        main_exec_generated_fast_labels.push_back(&&RomLine1084);
        main_exec_generated_fast_labels.push_back(&&RomLine1085);
        main_exec_generated_fast_labels.push_back(&&RomLine1086);
        main_exec_generated_fast_labels.push_back(&&RomLine1087);
        main_exec_generated_fast_labels.push_back(&&RomLine1088);
        main_exec_generated_fast_labels.push_back(&&RomLine1089);
        main_exec_generated_fast_labels.push_back(&&RomLine1090);
        main_exec_generated_fast_labels.push_back(&&RomLine1091);
        main_exec_generated_fast_labels.push_back(&&RomLine1092);
        main_exec_generated_fast_labels.push_back(&&RomLine1093);
        main_exec_generated_fast_labels.push_back(&&RomLine1094);
        main_exec_generated_fast_labels.push_back(&&RomLine1095);
        main_exec_generated_fast_labels.push_back(&&RomLine1096);
        main_exec_generated_fast_labels.push_back(&&RomLine1097);
        main_exec_generated_fast_labels.push_back(&&RomLine1098);
        main_exec_generated_fast_labels.push_back(&&RomLine1099);
        main_exec_generated_fast_labels.push_back(&&RomLine1100);
        main_exec_generated_fast_labels.push_back(&&RomLine1101);
        main_exec_generated_fast_labels.push_back(&&RomLine1102);
        main_exec_generated_fast_labels.push_back(&&RomLine1103);
        main_exec_generated_fast_labels.push_back(&&RomLine1104);
        main_exec_generated_fast_labels.push_back(&&RomLine1105);
        main_exec_generated_fast_labels.push_back(&&RomLine1106);
        main_exec_generated_fast_labels.push_back(&&RomLine1107);
        main_exec_generated_fast_labels.push_back(&&RomLine1108);
        main_exec_generated_fast_labels.push_back(&&RomLine1109);
        main_exec_generated_fast_labels.push_back(&&RomLine1110);
        main_exec_generated_fast_labels.push_back(&&RomLine1111);
        main_exec_generated_fast_labels.push_back(&&RomLine1112);
        main_exec_generated_fast_labels.push_back(&&RomLine1113);
        main_exec_generated_fast_labels.push_back(&&RomLine1114);
        main_exec_generated_fast_labels.push_back(&&RomLine1115);
        main_exec_generated_fast_labels.push_back(&&RomLine1116);
        main_exec_generated_fast_labels.push_back(&&RomLine1117);
        main_exec_generated_fast_labels.push_back(&&RomLine1118);
        main_exec_generated_fast_labels.push_back(&&RomLine1119);
        main_exec_generated_fast_labels.push_back(&&RomLine1120);
        main_exec_generated_fast_labels.push_back(&&RomLine1121);
        main_exec_generated_fast_labels.push_back(&&RomLine1122);
        main_exec_generated_fast_labels.push_back(&&RomLine1123);
        main_exec_generated_fast_labels.push_back(&&RomLine1124);
        main_exec_generated_fast_labels.push_back(&&RomLine1125);
        main_exec_generated_fast_labels.push_back(&&RomLine1126);
        main_exec_generated_fast_labels.push_back(&&RomLine1127);
        main_exec_generated_fast_labels.push_back(&&RomLine1128);
        main_exec_generated_fast_labels.push_back(&&RomLine1129);
        main_exec_generated_fast_labels.push_back(&&RomLine1130);
        main_exec_generated_fast_labels.push_back(&&RomLine1131);
        main_exec_generated_fast_labels.push_back(&&RomLine1132);
        main_exec_generated_fast_labels.push_back(&&RomLine1133);
        main_exec_generated_fast_labels.push_back(&&RomLine1134);
        main_exec_generated_fast_labels.push_back(&&RomLine1135);
        main_exec_generated_fast_labels.push_back(&&RomLine1136);
        main_exec_generated_fast_labels.push_back(&&RomLine1137);
        main_exec_generated_fast_labels.push_back(&&RomLine1138);
        main_exec_generated_fast_labels.push_back(&&RomLine1139);
        main_exec_generated_fast_labels.push_back(&&RomLine1140);
        main_exec_generated_fast_labels.push_back(&&RomLine1141);
        main_exec_generated_fast_labels.push_back(&&RomLine1142);
        main_exec_generated_fast_labels.push_back(&&RomLine1143);
        main_exec_generated_fast_labels.push_back(&&RomLine1144);
        main_exec_generated_fast_labels.push_back(&&RomLine1145);
        main_exec_generated_fast_labels.push_back(&&RomLine1146);
        main_exec_generated_fast_labels.push_back(&&RomLine1147);
        main_exec_generated_fast_labels.push_back(&&RomLine1148);
        main_exec_generated_fast_labels.push_back(&&RomLine1149);
        main_exec_generated_fast_labels.push_back(&&RomLine1150);
        main_exec_generated_fast_labels.push_back(&&RomLine1151);
        main_exec_generated_fast_labels.push_back(&&RomLine1152);
        main_exec_generated_fast_labels.push_back(&&RomLine1153);
        main_exec_generated_fast_labels.push_back(&&RomLine1154);
        main_exec_generated_fast_labels.push_back(&&RomLine1155);
        main_exec_generated_fast_labels.push_back(&&RomLine1156);
        main_exec_generated_fast_labels.push_back(&&RomLine1157);
        main_exec_generated_fast_labels.push_back(&&RomLine1158);
        main_exec_generated_fast_labels.push_back(&&RomLine1159);
        main_exec_generated_fast_labels.push_back(&&RomLine1160);
        main_exec_generated_fast_labels.push_back(&&RomLine1161);
        main_exec_generated_fast_labels.push_back(&&RomLine1162);
        main_exec_generated_fast_labels.push_back(&&RomLine1163);
        main_exec_generated_fast_labels.push_back(&&RomLine1164);
        main_exec_generated_fast_labels.push_back(&&RomLine1165);
        main_exec_generated_fast_labels.push_back(&&RomLine1166);
        main_exec_generated_fast_labels.push_back(&&RomLine1167);
        main_exec_generated_fast_labels.push_back(&&RomLine1168);
        main_exec_generated_fast_labels.push_back(&&RomLine1169);
        main_exec_generated_fast_labels.push_back(&&RomLine1170);
        main_exec_generated_fast_labels.push_back(&&RomLine1171);
        main_exec_generated_fast_labels.push_back(&&RomLine1172);
        main_exec_generated_fast_labels.push_back(&&RomLine1173);
        main_exec_generated_fast_labels.push_back(&&RomLine1174);
        main_exec_generated_fast_labels.push_back(&&RomLine1175);
        main_exec_generated_fast_labels.push_back(&&RomLine1176);
        main_exec_generated_fast_labels.push_back(&&RomLine1177);
        main_exec_generated_fast_labels.push_back(&&RomLine1178);
        main_exec_generated_fast_labels.push_back(&&RomLine1179);
        main_exec_generated_fast_labels.push_back(&&RomLine1180);
        main_exec_generated_fast_labels.push_back(&&RomLine1181);
        main_exec_generated_fast_labels.push_back(&&RomLine1182);
        main_exec_generated_fast_labels.push_back(&&RomLine1183);
        main_exec_generated_fast_labels.push_back(&&RomLine1184);
        main_exec_generated_fast_labels.push_back(&&RomLine1185);
        main_exec_generated_fast_labels.push_back(&&RomLine1186);
        main_exec_generated_fast_labels.push_back(&&RomLine1187);
        main_exec_generated_fast_labels.push_back(&&RomLine1188);
        main_exec_generated_fast_labels.push_back(&&RomLine1189);
        main_exec_generated_fast_labels.push_back(&&RomLine1190);
        main_exec_generated_fast_labels.push_back(&&RomLine1191);
        main_exec_generated_fast_labels.push_back(&&RomLine1192);
        main_exec_generated_fast_labels.push_back(&&RomLine1193);
        main_exec_generated_fast_labels.push_back(&&RomLine1194);
        main_exec_generated_fast_labels.push_back(&&RomLine1195);
        main_exec_generated_fast_labels.push_back(&&RomLine1196);
        main_exec_generated_fast_labels.push_back(&&RomLine1197);
        main_exec_generated_fast_labels.push_back(&&RomLine1198);
        main_exec_generated_fast_labels.push_back(&&RomLine1199);
        main_exec_generated_fast_labels.push_back(&&RomLine1200);
        main_exec_generated_fast_labels.push_back(&&RomLine1201);
        main_exec_generated_fast_labels.push_back(&&RomLine1202);
        main_exec_generated_fast_labels.push_back(&&RomLine1203);
        main_exec_generated_fast_labels.push_back(&&RomLine1204);
        main_exec_generated_fast_labels.push_back(&&RomLine1205);
        main_exec_generated_fast_labels.push_back(&&RomLine1206);
        main_exec_generated_fast_labels.push_back(&&RomLine1207);
        main_exec_generated_fast_labels.push_back(&&RomLine1208);
        main_exec_generated_fast_labels.push_back(&&RomLine1209);
        main_exec_generated_fast_labels.push_back(&&RomLine1210);
        main_exec_generated_fast_labels.push_back(&&RomLine1211);
        main_exec_generated_fast_labels.push_back(&&RomLine1212);
        main_exec_generated_fast_labels.push_back(&&RomLine1213);
        main_exec_generated_fast_labels.push_back(&&RomLine1214);
        main_exec_generated_fast_labels.push_back(&&RomLine1215);
        main_exec_generated_fast_labels.push_back(&&RomLine1216);
        main_exec_generated_fast_labels.push_back(&&RomLine1217);
        main_exec_generated_fast_labels.push_back(&&RomLine1218);
        main_exec_generated_fast_labels.push_back(&&RomLine1219);
        main_exec_generated_fast_labels.push_back(&&RomLine1220);
        main_exec_generated_fast_labels.push_back(&&RomLine1221);
        main_exec_generated_fast_labels.push_back(&&RomLine1222);
        main_exec_generated_fast_labels.push_back(&&RomLine1223);
        main_exec_generated_fast_labels.push_back(&&RomLine1224);
        main_exec_generated_fast_labels.push_back(&&RomLine1225);
        main_exec_generated_fast_labels.push_back(&&RomLine1226);
        main_exec_generated_fast_labels.push_back(&&RomLine1227);
        main_exec_generated_fast_labels.push_back(&&RomLine1228);
        main_exec_generated_fast_labels.push_back(&&RomLine1229);
        main_exec_generated_fast_labels.push_back(&&RomLine1230);
        main_exec_generated_fast_labels.push_back(&&RomLine1231);
        main_exec_generated_fast_labels.push_back(&&RomLine1232);
        main_exec_generated_fast_labels.push_back(&&RomLine1233);
        main_exec_generated_fast_labels.push_back(&&RomLine1234);
        main_exec_generated_fast_labels.push_back(&&RomLine1235);
        main_exec_generated_fast_labels.push_back(&&RomLine1236);
        main_exec_generated_fast_labels.push_back(&&RomLine1237);
        main_exec_generated_fast_labels.push_back(&&RomLine1238);
        main_exec_generated_fast_labels.push_back(&&RomLine1239);
        main_exec_generated_fast_labels.push_back(&&RomLine1240);
        main_exec_generated_fast_labels.push_back(&&RomLine1241);
        main_exec_generated_fast_labels.push_back(&&RomLine1242);
        main_exec_generated_fast_labels.push_back(&&RomLine1243);
        main_exec_generated_fast_labels.push_back(&&RomLine1244);
        main_exec_generated_fast_labels.push_back(&&RomLine1245);
        main_exec_generated_fast_labels.push_back(&&RomLine1246);
        main_exec_generated_fast_labels.push_back(&&RomLine1247);
        main_exec_generated_fast_labels.push_back(&&RomLine1248);
        main_exec_generated_fast_labels.push_back(&&RomLine1249);
        main_exec_generated_fast_labels.push_back(&&RomLine1250);
        main_exec_generated_fast_labels.push_back(&&RomLine1251);
        main_exec_generated_fast_labels.push_back(&&RomLine1252);
        main_exec_generated_fast_labels.push_back(&&RomLine1253);
        main_exec_generated_fast_labels.push_back(&&RomLine1254);
        main_exec_generated_fast_labels.push_back(&&RomLine1255);
        main_exec_generated_fast_labels.push_back(&&RomLine1256);
        main_exec_generated_fast_labels.push_back(&&RomLine1257);
        main_exec_generated_fast_labels.push_back(&&RomLine1258);
        main_exec_generated_fast_labels.push_back(&&RomLine1259);
        main_exec_generated_fast_labels.push_back(&&RomLine1260);
        main_exec_generated_fast_labels.push_back(&&RomLine1261);
        main_exec_generated_fast_labels.push_back(&&RomLine1262);
        main_exec_generated_fast_labels.push_back(&&RomLine1263);
        main_exec_generated_fast_labels.push_back(&&RomLine1264);
        main_exec_generated_fast_labels.push_back(&&RomLine1265);
        main_exec_generated_fast_labels.push_back(&&RomLine1266);
        main_exec_generated_fast_labels.push_back(&&RomLine1267);
        main_exec_generated_fast_labels.push_back(&&RomLine1268);
        main_exec_generated_fast_labels.push_back(&&RomLine1269);
        main_exec_generated_fast_labels.push_back(&&RomLine1270);
        main_exec_generated_fast_labels.push_back(&&RomLine1271);
        main_exec_generated_fast_labels.push_back(&&RomLine1272);
        main_exec_generated_fast_labels.push_back(&&RomLine1273);
        main_exec_generated_fast_labels.push_back(&&RomLine1274);
        main_exec_generated_fast_labels.push_back(&&RomLine1275);
        main_exec_generated_fast_labels.push_back(&&RomLine1276);
        main_exec_generated_fast_labels.push_back(&&RomLine1277);
        main_exec_generated_fast_labels.push_back(&&RomLine1278);
        main_exec_generated_fast_labels.push_back(&&RomLine1279);
        main_exec_generated_fast_labels.push_back(&&RomLine1280);
        main_exec_generated_fast_labels.push_back(&&RomLine1281);
        main_exec_generated_fast_labels.push_back(&&RomLine1282);
        main_exec_generated_fast_labels.push_back(&&RomLine1283);
        main_exec_generated_fast_labels.push_back(&&RomLine1284);
        main_exec_generated_fast_labels.push_back(&&RomLine1285);
        main_exec_generated_fast_labels.push_back(&&RomLine1286);
        main_exec_generated_fast_labels.push_back(&&RomLine1287);
        main_exec_generated_fast_labels.push_back(&&RomLine1288);
        main_exec_generated_fast_labels.push_back(&&RomLine1289);
        main_exec_generated_fast_labels.push_back(&&RomLine1290);
        main_exec_generated_fast_labels.push_back(&&RomLine1291);
        main_exec_generated_fast_labels.push_back(&&RomLine1292);
        main_exec_generated_fast_labels.push_back(&&RomLine1293);
        main_exec_generated_fast_labels.push_back(&&RomLine1294);
        main_exec_generated_fast_labels.push_back(&&RomLine1295);
        main_exec_generated_fast_labels.push_back(&&RomLine1296);
        main_exec_generated_fast_labels.push_back(&&RomLine1297);
        main_exec_generated_fast_labels.push_back(&&RomLine1298);
        main_exec_generated_fast_labels.push_back(&&RomLine1299);
        main_exec_generated_fast_labels.push_back(&&RomLine1300);
        main_exec_generated_fast_labels.push_back(&&RomLine1301);
        main_exec_generated_fast_labels.push_back(&&RomLine1302);
        main_exec_generated_fast_labels.push_back(&&RomLine1303);
        main_exec_generated_fast_labels.push_back(&&RomLine1304);
        main_exec_generated_fast_labels.push_back(&&RomLine1305);
        main_exec_generated_fast_labels.push_back(&&RomLine1306);
        main_exec_generated_fast_labels.push_back(&&RomLine1307);
        main_exec_generated_fast_labels.push_back(&&RomLine1308);
        main_exec_generated_fast_labels.push_back(&&RomLine1309);
        main_exec_generated_fast_labels.push_back(&&RomLine1310);
        main_exec_generated_fast_labels.push_back(&&RomLine1311);
        main_exec_generated_fast_labels.push_back(&&RomLine1312);
        main_exec_generated_fast_labels.push_back(&&RomLine1313);
        main_exec_generated_fast_labels.push_back(&&RomLine1314);
        main_exec_generated_fast_labels.push_back(&&RomLine1315);
        main_exec_generated_fast_labels.push_back(&&RomLine1316);
        main_exec_generated_fast_labels.push_back(&&RomLine1317);
        main_exec_generated_fast_labels.push_back(&&RomLine1318);
        main_exec_generated_fast_labels.push_back(&&RomLine1319);
        main_exec_generated_fast_labels.push_back(&&RomLine1320);
        main_exec_generated_fast_labels.push_back(&&RomLine1321);
        main_exec_generated_fast_labels.push_back(&&RomLine1322);
        main_exec_generated_fast_labels.push_back(&&RomLine1323);
        main_exec_generated_fast_labels.push_back(&&RomLine1324);
        main_exec_generated_fast_labels.push_back(&&RomLine1325);
        main_exec_generated_fast_labels.push_back(&&RomLine1326);
        main_exec_generated_fast_labels.push_back(&&RomLine1327);
        main_exec_generated_fast_labels.push_back(&&RomLine1328);
        main_exec_generated_fast_labels.push_back(&&RomLine1329);
        main_exec_generated_fast_labels.push_back(&&RomLine1330);
        main_exec_generated_fast_labels.push_back(&&RomLine1331);
        main_exec_generated_fast_labels.push_back(&&RomLine1332);
        main_exec_generated_fast_labels.push_back(&&RomLine1333);
        main_exec_generated_fast_labels.push_back(&&RomLine1334);
        main_exec_generated_fast_labels.push_back(&&RomLine1335);
        main_exec_generated_fast_labels.push_back(&&RomLine1336);
        main_exec_generated_fast_labels.push_back(&&RomLine1337);
        main_exec_generated_fast_labels.push_back(&&RomLine1338);
        main_exec_generated_fast_labels.push_back(&&RomLine1339);
        main_exec_generated_fast_labels.push_back(&&RomLine1340);
        main_exec_generated_fast_labels.push_back(&&RomLine1341);
        main_exec_generated_fast_labels.push_back(&&RomLine1342);
        main_exec_generated_fast_labels.push_back(&&RomLine1343);
        main_exec_generated_fast_labels.push_back(&&RomLine1344);
        main_exec_generated_fast_labels.push_back(&&RomLine1345);
        main_exec_generated_fast_labels.push_back(&&RomLine1346);
        main_exec_generated_fast_labels.push_back(&&RomLine1347);
        main_exec_generated_fast_labels.push_back(&&RomLine1348);
        main_exec_generated_fast_labels.push_back(&&RomLine1349);
        main_exec_generated_fast_labels.push_back(&&RomLine1350);
        main_exec_generated_fast_labels.push_back(&&RomLine1351);
        main_exec_generated_fast_labels.push_back(&&RomLine1352);
        main_exec_generated_fast_labels.push_back(&&RomLine1353);
        main_exec_generated_fast_labels.push_back(&&RomLine1354);
        main_exec_generated_fast_labels.push_back(&&RomLine1355);
        main_exec_generated_fast_labels.push_back(&&RomLine1356);
        main_exec_generated_fast_labels.push_back(&&RomLine1357);
        main_exec_generated_fast_labels.push_back(&&RomLine1358);
        main_exec_generated_fast_labels.push_back(&&RomLine1359);
        main_exec_generated_fast_labels.push_back(&&RomLine1360);
        main_exec_generated_fast_labels.push_back(&&RomLine1361);
        main_exec_generated_fast_labels.push_back(&&RomLine1362);
        main_exec_generated_fast_labels.push_back(&&RomLine1363);
        main_exec_generated_fast_labels.push_back(&&RomLine1364);
        main_exec_generated_fast_labels.push_back(&&RomLine1365);
        main_exec_generated_fast_labels.push_back(&&RomLine1366);
        main_exec_generated_fast_labels.push_back(&&RomLine1367);
        main_exec_generated_fast_labels.push_back(&&RomLine1368);
        main_exec_generated_fast_labels.push_back(&&RomLine1369);
        main_exec_generated_fast_labels.push_back(&&RomLine1370);
        main_exec_generated_fast_labels.push_back(&&RomLine1371);
        main_exec_generated_fast_labels.push_back(&&RomLine1372);
        main_exec_generated_fast_labels.push_back(&&RomLine1373);
        main_exec_generated_fast_labels.push_back(&&RomLine1374);
        main_exec_generated_fast_labels.push_back(&&RomLine1375);
        main_exec_generated_fast_labels.push_back(&&RomLine1376);
        main_exec_generated_fast_labels.push_back(&&RomLine1377);
        main_exec_generated_fast_labels.push_back(&&RomLine1378);
        main_exec_generated_fast_labels.push_back(&&RomLine1379);
        main_exec_generated_fast_labels.push_back(&&RomLine1380);
        main_exec_generated_fast_labels.push_back(&&RomLine1381);
        main_exec_generated_fast_labels.push_back(&&RomLine1382);
        main_exec_generated_fast_labels.push_back(&&RomLine1383);
        main_exec_generated_fast_labels.push_back(&&RomLine1384);
        main_exec_generated_fast_labels.push_back(&&RomLine1385);
        main_exec_generated_fast_labels.push_back(&&RomLine1386);
        main_exec_generated_fast_labels.push_back(&&RomLine1387);
        main_exec_generated_fast_labels.push_back(&&RomLine1388);
        main_exec_generated_fast_labels.push_back(&&RomLine1389);
        main_exec_generated_fast_labels.push_back(&&RomLine1390);
        main_exec_generated_fast_labels.push_back(&&RomLine1391);
        main_exec_generated_fast_labels.push_back(&&RomLine1392);
        main_exec_generated_fast_labels.push_back(&&RomLine1393);
        main_exec_generated_fast_labels.push_back(&&RomLine1394);
        main_exec_generated_fast_labels.push_back(&&RomLine1395);
        main_exec_generated_fast_labels.push_back(&&RomLine1396);
        main_exec_generated_fast_labels.push_back(&&RomLine1397);
        main_exec_generated_fast_labels.push_back(&&RomLine1398);
        main_exec_generated_fast_labels.push_back(&&RomLine1399);
        main_exec_generated_fast_labels.push_back(&&RomLine1400);
        main_exec_generated_fast_labels.push_back(&&RomLine1401);
        main_exec_generated_fast_labels.push_back(&&RomLine1402);
        main_exec_generated_fast_labels.push_back(&&RomLine1403);
        main_exec_generated_fast_labels.push_back(&&RomLine1404);
        main_exec_generated_fast_labels.push_back(&&RomLine1405);
        main_exec_generated_fast_labels.push_back(&&RomLine1406);
        main_exec_generated_fast_labels.push_back(&&RomLine1407);
        main_exec_generated_fast_labels.push_back(&&RomLine1408);
        main_exec_generated_fast_labels.push_back(&&RomLine1409);
        main_exec_generated_fast_labels.push_back(&&RomLine1410);
        main_exec_generated_fast_labels.push_back(&&RomLine1411);
        main_exec_generated_fast_labels.push_back(&&RomLine1412);
        main_exec_generated_fast_labels.push_back(&&RomLine1413);
        main_exec_generated_fast_labels.push_back(&&RomLine1414);
        main_exec_generated_fast_labels.push_back(&&RomLine1415);
        main_exec_generated_fast_labels.push_back(&&RomLine1416);
        main_exec_generated_fast_labels.push_back(&&RomLine1417);
        main_exec_generated_fast_labels.push_back(&&RomLine1418);
        main_exec_generated_fast_labels.push_back(&&RomLine1419);
        main_exec_generated_fast_labels.push_back(&&RomLine1420);
        main_exec_generated_fast_labels.push_back(&&RomLine1421);
        main_exec_generated_fast_labels.push_back(&&RomLine1422);
        main_exec_generated_fast_labels.push_back(&&RomLine1423);
        main_exec_generated_fast_labels.push_back(&&RomLine1424);
        main_exec_generated_fast_labels.push_back(&&RomLine1425);
        main_exec_generated_fast_labels.push_back(&&RomLine1426);
        main_exec_generated_fast_labels.push_back(&&RomLine1427);
        main_exec_generated_fast_labels.push_back(&&RomLine1428);
        main_exec_generated_fast_labels.push_back(&&RomLine1429);
        main_exec_generated_fast_labels.push_back(&&RomLine1430);
        main_exec_generated_fast_labels.push_back(&&RomLine1431);
        main_exec_generated_fast_labels.push_back(&&RomLine1432);
        main_exec_generated_fast_labels.push_back(&&RomLine1433);
        main_exec_generated_fast_labels.push_back(&&RomLine1434);
        main_exec_generated_fast_labels.push_back(&&RomLine1435);
        main_exec_generated_fast_labels.push_back(&&RomLine1436);
        main_exec_generated_fast_labels.push_back(&&RomLine1437);
        main_exec_generated_fast_labels.push_back(&&RomLine1438);
        main_exec_generated_fast_labels.push_back(&&RomLine1439);
        main_exec_generated_fast_labels.push_back(&&RomLine1440);
        main_exec_generated_fast_labels.push_back(&&RomLine1441);
        main_exec_generated_fast_labels.push_back(&&RomLine1442);
        main_exec_generated_fast_labels.push_back(&&RomLine1443);
        main_exec_generated_fast_labels.push_back(&&RomLine1444);
        main_exec_generated_fast_labels.push_back(&&RomLine1445);
        main_exec_generated_fast_labels.push_back(&&RomLine1446);
        main_exec_generated_fast_labels.push_back(&&RomLine1447);
        main_exec_generated_fast_labels.push_back(&&RomLine1448);
        main_exec_generated_fast_labels.push_back(&&RomLine1449);
        main_exec_generated_fast_labels.push_back(&&RomLine1450);
        main_exec_generated_fast_labels.push_back(&&RomLine1451);
        main_exec_generated_fast_labels.push_back(&&RomLine1452);
        main_exec_generated_fast_labels.push_back(&&RomLine1453);
        main_exec_generated_fast_labels.push_back(&&RomLine1454);
        main_exec_generated_fast_labels.push_back(&&RomLine1455);
        main_exec_generated_fast_labels.push_back(&&RomLine1456);
        main_exec_generated_fast_labels.push_back(&&RomLine1457);
        main_exec_generated_fast_labels.push_back(&&RomLine1458);
        main_exec_generated_fast_labels.push_back(&&RomLine1459);
        main_exec_generated_fast_labels.push_back(&&RomLine1460);
        main_exec_generated_fast_labels.push_back(&&RomLine1461);
        main_exec_generated_fast_labels.push_back(&&RomLine1462);
        main_exec_generated_fast_labels.push_back(&&RomLine1463);
        main_exec_generated_fast_labels.push_back(&&RomLine1464);
        main_exec_generated_fast_labels.push_back(&&RomLine1465);
        main_exec_generated_fast_labels.push_back(&&RomLine1466);
        main_exec_generated_fast_labels.push_back(&&RomLine1467);
        main_exec_generated_fast_labels.push_back(&&RomLine1468);
        main_exec_generated_fast_labels.push_back(&&RomLine1469);
        main_exec_generated_fast_labels.push_back(&&RomLine1470);
        main_exec_generated_fast_labels.push_back(&&RomLine1471);
        main_exec_generated_fast_labels.push_back(&&RomLine1472);
        main_exec_generated_fast_labels.push_back(&&RomLine1473);
        main_exec_generated_fast_labels.push_back(&&RomLine1474);
        main_exec_generated_fast_labels.push_back(&&RomLine1475);
        main_exec_generated_fast_labels.push_back(&&RomLine1476);
        main_exec_generated_fast_labels.push_back(&&RomLine1477);
        main_exec_generated_fast_labels.push_back(&&RomLine1478);
        main_exec_generated_fast_labels.push_back(&&RomLine1479);
        main_exec_generated_fast_labels.push_back(&&RomLine1480);
        main_exec_generated_fast_labels.push_back(&&RomLine1481);
        main_exec_generated_fast_labels.push_back(&&RomLine1482);
        main_exec_generated_fast_labels.push_back(&&RomLine1483);
        main_exec_generated_fast_labels.push_back(&&RomLine1484);
        main_exec_generated_fast_labels.push_back(&&RomLine1485);
        main_exec_generated_fast_labels.push_back(&&RomLine1486);
        main_exec_generated_fast_labels.push_back(&&RomLine1487);
        main_exec_generated_fast_labels.push_back(&&RomLine1488);
        main_exec_generated_fast_labels.push_back(&&RomLine1489);
        main_exec_generated_fast_labels.push_back(&&RomLine1490);
        main_exec_generated_fast_labels.push_back(&&RomLine1491);
        main_exec_generated_fast_labels.push_back(&&RomLine1492);
        main_exec_generated_fast_labels.push_back(&&RomLine1493);
        main_exec_generated_fast_labels.push_back(&&RomLine1494);
        main_exec_generated_fast_labels.push_back(&&RomLine1495);
        main_exec_generated_fast_labels.push_back(&&RomLine1496);
        main_exec_generated_fast_labels.push_back(&&RomLine1497);
        main_exec_generated_fast_labels.push_back(&&RomLine1498);
        main_exec_generated_fast_labels.push_back(&&RomLine1499);
        main_exec_generated_fast_labels.push_back(&&RomLine1500);
        main_exec_generated_fast_labels.push_back(&&RomLine1501);
        main_exec_generated_fast_labels.push_back(&&RomLine1502);
        main_exec_generated_fast_labels.push_back(&&RomLine1503);
        main_exec_generated_fast_labels.push_back(&&RomLine1504);
        main_exec_generated_fast_labels.push_back(&&RomLine1505);
        main_exec_generated_fast_labels.push_back(&&RomLine1506);
        main_exec_generated_fast_labels.push_back(&&RomLine1507);
        main_exec_generated_fast_labels.push_back(&&RomLine1508);
        main_exec_generated_fast_labels.push_back(&&RomLine1509);
        main_exec_generated_fast_labels.push_back(&&RomLine1510);
        main_exec_generated_fast_labels.push_back(&&RomLine1511);
        main_exec_generated_fast_labels.push_back(&&RomLine1512);
        main_exec_generated_fast_labels.push_back(&&RomLine1513);
        main_exec_generated_fast_labels.push_back(&&RomLine1514);
        main_exec_generated_fast_labels.push_back(&&RomLine1515);
        main_exec_generated_fast_labels.push_back(&&RomLine1516);
        main_exec_generated_fast_labels.push_back(&&RomLine1517);
        main_exec_generated_fast_labels.push_back(&&RomLine1518);
        main_exec_generated_fast_labels.push_back(&&RomLine1519);
        main_exec_generated_fast_labels.push_back(&&RomLine1520);
        main_exec_generated_fast_labels.push_back(&&RomLine1521);
        main_exec_generated_fast_labels.push_back(&&RomLine1522);
        main_exec_generated_fast_labels.push_back(&&RomLine1523);
        main_exec_generated_fast_labels.push_back(&&RomLine1524);
        main_exec_generated_fast_labels.push_back(&&RomLine1525);
        main_exec_generated_fast_labels.push_back(&&RomLine1526);
        main_exec_generated_fast_labels.push_back(&&RomLine1527);
        main_exec_generated_fast_labels.push_back(&&RomLine1528);
        main_exec_generated_fast_labels.push_back(&&RomLine1529);
        main_exec_generated_fast_labels.push_back(&&RomLine1530);
        main_exec_generated_fast_labels.push_back(&&RomLine1531);
        main_exec_generated_fast_labels.push_back(&&RomLine1532);
        main_exec_generated_fast_labels.push_back(&&RomLine1533);
        main_exec_generated_fast_labels.push_back(&&RomLine1534);
        main_exec_generated_fast_labels.push_back(&&RomLine1535);
        main_exec_generated_fast_labels.push_back(&&RomLine1536);
        main_exec_generated_fast_labels.push_back(&&RomLine1537);
        main_exec_generated_fast_labels.push_back(&&RomLine1538);
        main_exec_generated_fast_labels.push_back(&&RomLine1539);
        main_exec_generated_fast_labels.push_back(&&RomLine1540);
        main_exec_generated_fast_labels.push_back(&&RomLine1541);
        main_exec_generated_fast_labels.push_back(&&RomLine1542);
        main_exec_generated_fast_labels.push_back(&&RomLine1543);
        main_exec_generated_fast_labels.push_back(&&RomLine1544);
        main_exec_generated_fast_labels.push_back(&&RomLine1545);
        main_exec_generated_fast_labels.push_back(&&RomLine1546);
        main_exec_generated_fast_labels.push_back(&&RomLine1547);
        main_exec_generated_fast_labels.push_back(&&RomLine1548);
        main_exec_generated_fast_labels.push_back(&&RomLine1549);
        main_exec_generated_fast_labels.push_back(&&RomLine1550);
        main_exec_generated_fast_labels.push_back(&&RomLine1551);
        main_exec_generated_fast_labels.push_back(&&RomLine1552);
        main_exec_generated_fast_labels.push_back(&&RomLine1553);
        main_exec_generated_fast_labels.push_back(&&RomLine1554);
        main_exec_generated_fast_labels.push_back(&&RomLine1555);
        main_exec_generated_fast_labels.push_back(&&RomLine1556);
        main_exec_generated_fast_labels.push_back(&&RomLine1557);
        main_exec_generated_fast_labels.push_back(&&RomLine1558);
        main_exec_generated_fast_labels.push_back(&&RomLine1559);
        main_exec_generated_fast_labels.push_back(&&RomLine1560);
        main_exec_generated_fast_labels.push_back(&&RomLine1561);
        main_exec_generated_fast_labels.push_back(&&RomLine1562);
        main_exec_generated_fast_labels.push_back(&&RomLine1563);
        main_exec_generated_fast_labels.push_back(&&RomLine1564);
        main_exec_generated_fast_labels.push_back(&&RomLine1565);
        main_exec_generated_fast_labels.push_back(&&RomLine1566);
        main_exec_generated_fast_labels.push_back(&&RomLine1567);
        main_exec_generated_fast_labels.push_back(&&RomLine1568);
        main_exec_generated_fast_labels.push_back(&&RomLine1569);
        main_exec_generated_fast_labels.push_back(&&RomLine1570);
        main_exec_generated_fast_labels.push_back(&&RomLine1571);
        main_exec_generated_fast_labels.push_back(&&RomLine1572);
        main_exec_generated_fast_labels.push_back(&&RomLine1573);
        main_exec_generated_fast_labels.push_back(&&RomLine1574);
        main_exec_generated_fast_labels.push_back(&&RomLine1575);
        main_exec_generated_fast_labels.push_back(&&RomLine1576);
        main_exec_generated_fast_labels.push_back(&&RomLine1577);
        main_exec_generated_fast_labels.push_back(&&RomLine1578);
        main_exec_generated_fast_labels.push_back(&&RomLine1579);
        main_exec_generated_fast_labels.push_back(&&RomLine1580);
        main_exec_generated_fast_labels.push_back(&&RomLine1581);
        main_exec_generated_fast_labels.push_back(&&RomLine1582);
        main_exec_generated_fast_labels.push_back(&&RomLine1583);
        main_exec_generated_fast_labels.push_back(&&RomLine1584);
        main_exec_generated_fast_labels.push_back(&&RomLine1585);
        main_exec_generated_fast_labels.push_back(&&RomLine1586);
        main_exec_generated_fast_labels.push_back(&&RomLine1587);
        main_exec_generated_fast_labels.push_back(&&RomLine1588);
        main_exec_generated_fast_labels.push_back(&&RomLine1589);
        main_exec_generated_fast_labels.push_back(&&RomLine1590);
        main_exec_generated_fast_labels.push_back(&&RomLine1591);
        main_exec_generated_fast_labels.push_back(&&RomLine1592);
        main_exec_generated_fast_labels.push_back(&&RomLine1593);
        main_exec_generated_fast_labels.push_back(&&RomLine1594);
        main_exec_generated_fast_labels.push_back(&&RomLine1595);
        main_exec_generated_fast_labels.push_back(&&RomLine1596);
        main_exec_generated_fast_labels.push_back(&&RomLine1597);
        main_exec_generated_fast_labels.push_back(&&RomLine1598);
        main_exec_generated_fast_labels.push_back(&&RomLine1599);
        main_exec_generated_fast_labels.push_back(&&RomLine1600);
        main_exec_generated_fast_labels.push_back(&&RomLine1601);
        main_exec_generated_fast_labels.push_back(&&RomLine1602);
        main_exec_generated_fast_labels.push_back(&&RomLine1603);
        main_exec_generated_fast_labels.push_back(&&RomLine1604);
        main_exec_generated_fast_labels.push_back(&&RomLine1605);
        main_exec_generated_fast_labels.push_back(&&RomLine1606);
        main_exec_generated_fast_labels.push_back(&&RomLine1607);
        main_exec_generated_fast_labels.push_back(&&RomLine1608);
        main_exec_generated_fast_labels.push_back(&&RomLine1609);
        main_exec_generated_fast_labels.push_back(&&RomLine1610);
        main_exec_generated_fast_labels.push_back(&&RomLine1611);
        main_exec_generated_fast_labels.push_back(&&RomLine1612);
        main_exec_generated_fast_labels.push_back(&&RomLine1613);
        main_exec_generated_fast_labels.push_back(&&RomLine1614);
        main_exec_generated_fast_labels.push_back(&&RomLine1615);
        main_exec_generated_fast_labels.push_back(&&RomLine1616);
        main_exec_generated_fast_labels.push_back(&&RomLine1617);
        main_exec_generated_fast_labels.push_back(&&RomLine1618);
        main_exec_generated_fast_labels.push_back(&&RomLine1619);
        main_exec_generated_fast_labels.push_back(&&RomLine1620);
        main_exec_generated_fast_labels.push_back(&&RomLine1621);
        main_exec_generated_fast_labels.push_back(&&RomLine1622);
        main_exec_generated_fast_labels.push_back(&&RomLine1623);
        main_exec_generated_fast_labels.push_back(&&RomLine1624);
        main_exec_generated_fast_labels.push_back(&&RomLine1625);
        main_exec_generated_fast_labels.push_back(&&RomLine1626);
        main_exec_generated_fast_labels.push_back(&&RomLine1627);
        main_exec_generated_fast_labels.push_back(&&RomLine1628);
        main_exec_generated_fast_labels.push_back(&&RomLine1629);
        main_exec_generated_fast_labels.push_back(&&RomLine1630);
        main_exec_generated_fast_labels.push_back(&&RomLine1631);
        main_exec_generated_fast_labels.push_back(&&RomLine1632);
        main_exec_generated_fast_labels.push_back(&&RomLine1633);
        main_exec_generated_fast_labels.push_back(&&RomLine1634);
        main_exec_generated_fast_labels.push_back(&&RomLine1635);
        main_exec_generated_fast_labels.push_back(&&RomLine1636);
        main_exec_generated_fast_labels.push_back(&&RomLine1637);
        main_exec_generated_fast_labels.push_back(&&RomLine1638);
        main_exec_generated_fast_labels.push_back(&&RomLine1639);
        main_exec_generated_fast_labels.push_back(&&RomLine1640);
        main_exec_generated_fast_labels.push_back(&&RomLine1641);
        main_exec_generated_fast_labels.push_back(&&RomLine1642);
        main_exec_generated_fast_labels.push_back(&&RomLine1643);
        main_exec_generated_fast_labels.push_back(&&RomLine1644);
        main_exec_generated_fast_labels.push_back(&&RomLine1645);
        main_exec_generated_fast_labels.push_back(&&RomLine1646);
        main_exec_generated_fast_labels.push_back(&&RomLine1647);
        main_exec_generated_fast_labels.push_back(&&RomLine1648);
        main_exec_generated_fast_labels.push_back(&&RomLine1649);
        main_exec_generated_fast_labels.push_back(&&RomLine1650);
        main_exec_generated_fast_labels.push_back(&&RomLine1651);
        main_exec_generated_fast_labels.push_back(&&RomLine1652);
        main_exec_generated_fast_labels.push_back(&&RomLine1653);
        main_exec_generated_fast_labels.push_back(&&RomLine1654);
        main_exec_generated_fast_labels.push_back(&&RomLine1655);
        main_exec_generated_fast_labels.push_back(&&RomLine1656);
        main_exec_generated_fast_labels.push_back(&&RomLine1657);
        main_exec_generated_fast_labels.push_back(&&RomLine1658);
        main_exec_generated_fast_labels.push_back(&&RomLine1659);
        main_exec_generated_fast_labels.push_back(&&RomLine1660);
        main_exec_generated_fast_labels.push_back(&&RomLine1661);
        main_exec_generated_fast_labels.push_back(&&RomLine1662);
        main_exec_generated_fast_labels.push_back(&&RomLine1663);
        main_exec_generated_fast_labels.push_back(&&RomLine1664);
        main_exec_generated_fast_labels.push_back(&&RomLine1665);
        main_exec_generated_fast_labels.push_back(&&RomLine1666);
        main_exec_generated_fast_labels.push_back(&&RomLine1667);
        main_exec_generated_fast_labels.push_back(&&RomLine1668);
        main_exec_generated_fast_labels.push_back(&&RomLine1669);
        main_exec_generated_fast_labels.push_back(&&RomLine1670);
        main_exec_generated_fast_labels.push_back(&&RomLine1671);
        main_exec_generated_fast_labels.push_back(&&RomLine1672);
        main_exec_generated_fast_labels.push_back(&&RomLine1673);
        main_exec_generated_fast_labels.push_back(&&RomLine1674);
        main_exec_generated_fast_labels.push_back(&&RomLine1675);
        main_exec_generated_fast_labels.push_back(&&RomLine1676);
        main_exec_generated_fast_labels.push_back(&&RomLine1677);
        main_exec_generated_fast_labels.push_back(&&RomLine1678);
        main_exec_generated_fast_labels.push_back(&&RomLine1679);
        main_exec_generated_fast_labels.push_back(&&RomLine1680);
        main_exec_generated_fast_labels.push_back(&&RomLine1681);
        main_exec_generated_fast_labels.push_back(&&RomLine1682);
        main_exec_generated_fast_labels.push_back(&&RomLine1683);
        main_exec_generated_fast_labels.push_back(&&RomLine1684);
        main_exec_generated_fast_labels.push_back(&&RomLine1685);
        main_exec_generated_fast_labels.push_back(&&RomLine1686);
        main_exec_generated_fast_labels.push_back(&&RomLine1687);
        main_exec_generated_fast_labels.push_back(&&RomLine1688);
        main_exec_generated_fast_labels.push_back(&&RomLine1689);
        main_exec_generated_fast_labels.push_back(&&RomLine1690);
        main_exec_generated_fast_labels.push_back(&&RomLine1691);
        main_exec_generated_fast_labels.push_back(&&RomLine1692);
        main_exec_generated_fast_labels.push_back(&&RomLine1693);
        main_exec_generated_fast_labels.push_back(&&RomLine1694);
        main_exec_generated_fast_labels.push_back(&&RomLine1695);
        main_exec_generated_fast_labels.push_back(&&RomLine1696);
        main_exec_generated_fast_labels.push_back(&&RomLine1697);
        main_exec_generated_fast_labels.push_back(&&RomLine1698);
        main_exec_generated_fast_labels.push_back(&&RomLine1699);
        main_exec_generated_fast_labels.push_back(&&RomLine1700);
        main_exec_generated_fast_labels.push_back(&&RomLine1701);
        main_exec_generated_fast_labels.push_back(&&RomLine1702);
        main_exec_generated_fast_labels.push_back(&&RomLine1703);
        main_exec_generated_fast_labels.push_back(&&RomLine1704);
        main_exec_generated_fast_labels.push_back(&&RomLine1705);
        main_exec_generated_fast_labels.push_back(&&RomLine1706);
        main_exec_generated_fast_labels.push_back(&&RomLine1707);
        main_exec_generated_fast_labels.push_back(&&RomLine1708);
        main_exec_generated_fast_labels.push_back(&&RomLine1709);
        main_exec_generated_fast_labels.push_back(&&RomLine1710);
        main_exec_generated_fast_labels.push_back(&&RomLine1711);
        main_exec_generated_fast_labels.push_back(&&RomLine1712);
        main_exec_generated_fast_labels.push_back(&&RomLine1713);
        main_exec_generated_fast_labels.push_back(&&RomLine1714);
        main_exec_generated_fast_labels.push_back(&&RomLine1715);
        main_exec_generated_fast_labels.push_back(&&RomLine1716);
        main_exec_generated_fast_labels.push_back(&&RomLine1717);
        main_exec_generated_fast_labels.push_back(&&RomLine1718);
        main_exec_generated_fast_labels.push_back(&&RomLine1719);
        main_exec_generated_fast_labels.push_back(&&RomLine1720);
        main_exec_generated_fast_labels.push_back(&&RomLine1721);
        main_exec_generated_fast_labels.push_back(&&RomLine1722);
        main_exec_generated_fast_labels.push_back(&&RomLine1723);
        main_exec_generated_fast_labels.push_back(&&RomLine1724);
        main_exec_generated_fast_labels.push_back(&&RomLine1725);
        main_exec_generated_fast_labels.push_back(&&RomLine1726);
        main_exec_generated_fast_labels.push_back(&&RomLine1727);
        main_exec_generated_fast_labels.push_back(&&RomLine1728);
        main_exec_generated_fast_labels.push_back(&&RomLine1729);
        main_exec_generated_fast_labels.push_back(&&RomLine1730);
        main_exec_generated_fast_labels.push_back(&&RomLine1731);
        main_exec_generated_fast_labels.push_back(&&RomLine1732);
        main_exec_generated_fast_labels.push_back(&&RomLine1733);
        main_exec_generated_fast_labels.push_back(&&RomLine1734);
        main_exec_generated_fast_labels.push_back(&&RomLine1735);
        main_exec_generated_fast_labels.push_back(&&RomLine1736);
        main_exec_generated_fast_labels.push_back(&&RomLine1737);
        main_exec_generated_fast_labels.push_back(&&RomLine1738);
        main_exec_generated_fast_labels.push_back(&&RomLine1739);
        main_exec_generated_fast_labels.push_back(&&RomLine1740);
        main_exec_generated_fast_labels.push_back(&&RomLine1741);
        main_exec_generated_fast_labels.push_back(&&RomLine1742);
        main_exec_generated_fast_labels.push_back(&&RomLine1743);
        main_exec_generated_fast_labels.push_back(&&RomLine1744);
        main_exec_generated_fast_labels.push_back(&&RomLine1745);
        main_exec_generated_fast_labels.push_back(&&RomLine1746);
        main_exec_generated_fast_labels.push_back(&&RomLine1747);
        main_exec_generated_fast_labels.push_back(&&RomLine1748);
        main_exec_generated_fast_labels.push_back(&&RomLine1749);
        main_exec_generated_fast_labels.push_back(&&RomLine1750);
        main_exec_generated_fast_labels.push_back(&&RomLine1751);
        main_exec_generated_fast_labels.push_back(&&RomLine1752);
        main_exec_generated_fast_labels.push_back(&&RomLine1753);
        main_exec_generated_fast_labels.push_back(&&RomLine1754);
        main_exec_generated_fast_labels.push_back(&&RomLine1755);
        main_exec_generated_fast_labels.push_back(&&RomLine1756);
        main_exec_generated_fast_labels.push_back(&&RomLine1757);
        main_exec_generated_fast_labels.push_back(&&RomLine1758);
        main_exec_generated_fast_labels.push_back(&&RomLine1759);
        main_exec_generated_fast_labels.push_back(&&RomLine1760);
        main_exec_generated_fast_labels.push_back(&&RomLine1761);
        main_exec_generated_fast_labels.push_back(&&RomLine1762);
        main_exec_generated_fast_labels.push_back(&&RomLine1763);
        main_exec_generated_fast_labels.push_back(&&RomLine1764);
        main_exec_generated_fast_labels.push_back(&&RomLine1765);
        main_exec_generated_fast_labels.push_back(&&RomLine1766);
        main_exec_generated_fast_labels.push_back(&&RomLine1767);
        main_exec_generated_fast_labels.push_back(&&RomLine1768);
        main_exec_generated_fast_labels.push_back(&&RomLine1769);
        main_exec_generated_fast_labels.push_back(&&RomLine1770);
        main_exec_generated_fast_labels.push_back(&&RomLine1771);
        main_exec_generated_fast_labels.push_back(&&RomLine1772);
        main_exec_generated_fast_labels.push_back(&&RomLine1773);
        main_exec_generated_fast_labels.push_back(&&RomLine1774);
        main_exec_generated_fast_labels.push_back(&&RomLine1775);
        main_exec_generated_fast_labels.push_back(&&RomLine1776);
        main_exec_generated_fast_labels.push_back(&&RomLine1777);
        main_exec_generated_fast_labels.push_back(&&RomLine1778);
        main_exec_generated_fast_labels.push_back(&&RomLine1779);
        main_exec_generated_fast_labels.push_back(&&RomLine1780);
        main_exec_generated_fast_labels.push_back(&&RomLine1781);
        main_exec_generated_fast_labels.push_back(&&RomLine1782);
        main_exec_generated_fast_labels.push_back(&&RomLine1783);
        main_exec_generated_fast_labels.push_back(&&RomLine1784);
        main_exec_generated_fast_labels.push_back(&&RomLine1785);
        main_exec_generated_fast_labels.push_back(&&RomLine1786);
        main_exec_generated_fast_labels.push_back(&&RomLine1787);
        main_exec_generated_fast_labels.push_back(&&RomLine1788);
        main_exec_generated_fast_labels.push_back(&&RomLine1789);
        main_exec_generated_fast_labels.push_back(&&RomLine1790);
        main_exec_generated_fast_labels.push_back(&&RomLine1791);
        main_exec_generated_fast_labels.push_back(&&RomLine1792);
        main_exec_generated_fast_labels.push_back(&&RomLine1793);
        main_exec_generated_fast_labels.push_back(&&RomLine1794);
        main_exec_generated_fast_labels.push_back(&&RomLine1795);
        main_exec_generated_fast_labels.push_back(&&RomLine1796);
        main_exec_generated_fast_labels.push_back(&&RomLine1797);
        main_exec_generated_fast_labels.push_back(&&RomLine1798);
        main_exec_generated_fast_labels.push_back(&&RomLine1799);
        main_exec_generated_fast_labels.push_back(&&RomLine1800);
        main_exec_generated_fast_labels.push_back(&&RomLine1801);
        main_exec_generated_fast_labels.push_back(&&RomLine1802);
        main_exec_generated_fast_labels.push_back(&&RomLine1803);
        main_exec_generated_fast_labels.push_back(&&RomLine1804);
        main_exec_generated_fast_labels.push_back(&&RomLine1805);
        main_exec_generated_fast_labels.push_back(&&RomLine1806);
        main_exec_generated_fast_labels.push_back(&&RomLine1807);
        main_exec_generated_fast_labels.push_back(&&RomLine1808);
        main_exec_generated_fast_labels.push_back(&&RomLine1809);
        main_exec_generated_fast_labels.push_back(&&RomLine1810);
        main_exec_generated_fast_labels.push_back(&&RomLine1811);
        main_exec_generated_fast_labels.push_back(&&RomLine1812);
        main_exec_generated_fast_labels.push_back(&&RomLine1813);
        main_exec_generated_fast_labels.push_back(&&RomLine1814);
        main_exec_generated_fast_labels.push_back(&&RomLine1815);
        main_exec_generated_fast_labels.push_back(&&RomLine1816);
        main_exec_generated_fast_labels.push_back(&&RomLine1817);
        main_exec_generated_fast_labels.push_back(&&RomLine1818);
        main_exec_generated_fast_labels.push_back(&&RomLine1819);
        main_exec_generated_fast_labels.push_back(&&RomLine1820);
        main_exec_generated_fast_labels.push_back(&&RomLine1821);
        main_exec_generated_fast_labels.push_back(&&RomLine1822);
        main_exec_generated_fast_labels.push_back(&&RomLine1823);
        main_exec_generated_fast_labels.push_back(&&RomLine1824);
        main_exec_generated_fast_labels.push_back(&&RomLine1825);
        main_exec_generated_fast_labels.push_back(&&RomLine1826);
        main_exec_generated_fast_labels.push_back(&&RomLine1827);
        main_exec_generated_fast_labels.push_back(&&RomLine1828);
        main_exec_generated_fast_labels.push_back(&&RomLine1829);
        main_exec_generated_fast_labels.push_back(&&RomLine1830);
        main_exec_generated_fast_labels.push_back(&&RomLine1831);
        main_exec_generated_fast_labels.push_back(&&RomLine1832);
        main_exec_generated_fast_labels.push_back(&&RomLine1833);
        main_exec_generated_fast_labels.push_back(&&RomLine1834);
        main_exec_generated_fast_labels.push_back(&&RomLine1835);
        main_exec_generated_fast_labels.push_back(&&RomLine1836);
        main_exec_generated_fast_labels.push_back(&&RomLine1837);
        main_exec_generated_fast_labels.push_back(&&RomLine1838);
        main_exec_generated_fast_labels.push_back(&&RomLine1839);
        main_exec_generated_fast_labels.push_back(&&RomLine1840);
        main_exec_generated_fast_labels.push_back(&&RomLine1841);
        main_exec_generated_fast_labels.push_back(&&RomLine1842);
        main_exec_generated_fast_labels.push_back(&&RomLine1843);
        main_exec_generated_fast_labels.push_back(&&RomLine1844);
        main_exec_generated_fast_labels.push_back(&&RomLine1845);
        main_exec_generated_fast_labels.push_back(&&RomLine1846);
        main_exec_generated_fast_labels.push_back(&&RomLine1847);
        main_exec_generated_fast_labels.push_back(&&RomLine1848);
        main_exec_generated_fast_labels.push_back(&&RomLine1849);
        main_exec_generated_fast_labels.push_back(&&RomLine1850);
        main_exec_generated_fast_labels.push_back(&&RomLine1851);
        main_exec_generated_fast_labels.push_back(&&RomLine1852);
        main_exec_generated_fast_labels.push_back(&&RomLine1853);
        main_exec_generated_fast_labels.push_back(&&RomLine1854);
        main_exec_generated_fast_labels.push_back(&&RomLine1855);
        main_exec_generated_fast_labels.push_back(&&RomLine1856);
        main_exec_generated_fast_labels.push_back(&&RomLine1857);
        main_exec_generated_fast_labels.push_back(&&RomLine1858);
        main_exec_generated_fast_labels.push_back(&&RomLine1859);
        main_exec_generated_fast_labels.push_back(&&RomLine1860);
        main_exec_generated_fast_labels.push_back(&&RomLine1861);
        main_exec_generated_fast_labels.push_back(&&RomLine1862);
        main_exec_generated_fast_labels.push_back(&&RomLine1863);
        main_exec_generated_fast_labels.push_back(&&RomLine1864);
        main_exec_generated_fast_labels.push_back(&&RomLine1865);
        main_exec_generated_fast_labels.push_back(&&RomLine1866);
        main_exec_generated_fast_labels.push_back(&&RomLine1867);
        main_exec_generated_fast_labels.push_back(&&RomLine1868);
        main_exec_generated_fast_labels.push_back(&&RomLine1869);
        main_exec_generated_fast_labels.push_back(&&RomLine1870);
        main_exec_generated_fast_labels.push_back(&&RomLine1871);
        main_exec_generated_fast_labels.push_back(&&RomLine1872);
        main_exec_generated_fast_labels.push_back(&&RomLine1873);
        main_exec_generated_fast_labels.push_back(&&RomLine1874);
        main_exec_generated_fast_labels.push_back(&&RomLine1875);
        main_exec_generated_fast_labels.push_back(&&RomLine1876);
        main_exec_generated_fast_labels.push_back(&&RomLine1877);
        main_exec_generated_fast_labels.push_back(&&RomLine1878);
        main_exec_generated_fast_labels.push_back(&&RomLine1879);
        main_exec_generated_fast_labels.push_back(&&RomLine1880);
        main_exec_generated_fast_labels.push_back(&&RomLine1881);
        main_exec_generated_fast_labels.push_back(&&RomLine1882);
        main_exec_generated_fast_labels.push_back(&&RomLine1883);
        main_exec_generated_fast_labels.push_back(&&RomLine1884);
        main_exec_generated_fast_labels.push_back(&&RomLine1885);
        main_exec_generated_fast_labels.push_back(&&RomLine1886);
        main_exec_generated_fast_labels.push_back(&&RomLine1887);
        main_exec_generated_fast_labels.push_back(&&RomLine1888);
        main_exec_generated_fast_labels.push_back(&&RomLine1889);
        main_exec_generated_fast_labels.push_back(&&RomLine1890);
        main_exec_generated_fast_labels.push_back(&&RomLine1891);
        main_exec_generated_fast_labels.push_back(&&RomLine1892);
        main_exec_generated_fast_labels.push_back(&&RomLine1893);
        main_exec_generated_fast_labels.push_back(&&RomLine1894);
        main_exec_generated_fast_labels.push_back(&&RomLine1895);
        main_exec_generated_fast_labels.push_back(&&RomLine1896);
        main_exec_generated_fast_labels.push_back(&&RomLine1897);
        main_exec_generated_fast_labels.push_back(&&RomLine1898);
        main_exec_generated_fast_labels.push_back(&&RomLine1899);
        main_exec_generated_fast_labels.push_back(&&RomLine1900);
        main_exec_generated_fast_labels.push_back(&&RomLine1901);
        main_exec_generated_fast_labels.push_back(&&RomLine1902);
        main_exec_generated_fast_labels.push_back(&&RomLine1903);
        main_exec_generated_fast_labels.push_back(&&RomLine1904);
        main_exec_generated_fast_labels.push_back(&&RomLine1905);
        main_exec_generated_fast_labels.push_back(&&RomLine1906);
        main_exec_generated_fast_labels.push_back(&&RomLine1907);
        main_exec_generated_fast_labels.push_back(&&RomLine1908);
        main_exec_generated_fast_labels.push_back(&&RomLine1909);
        main_exec_generated_fast_labels.push_back(&&RomLine1910);
        main_exec_generated_fast_labels.push_back(&&RomLine1911);
        main_exec_generated_fast_labels.push_back(&&RomLine1912);
        main_exec_generated_fast_labels.push_back(&&RomLine1913);
        main_exec_generated_fast_labels.push_back(&&RomLine1914);
        main_exec_generated_fast_labels.push_back(&&RomLine1915);
        main_exec_generated_fast_labels.push_back(&&RomLine1916);
        main_exec_generated_fast_labels.push_back(&&RomLine1917);
        main_exec_generated_fast_labels.push_back(&&RomLine1918);
        main_exec_generated_fast_labels.push_back(&&RomLine1919);
        main_exec_generated_fast_labels.push_back(&&RomLine1920);
        main_exec_generated_fast_labels.push_back(&&RomLine1921);
        main_exec_generated_fast_labels.push_back(&&RomLine1922);
        main_exec_generated_fast_labels.push_back(&&RomLine1923);
        main_exec_generated_fast_labels.push_back(&&RomLine1924);
        main_exec_generated_fast_labels.push_back(&&RomLine1925);
        main_exec_generated_fast_labels.push_back(&&RomLine1926);
        main_exec_generated_fast_labels.push_back(&&RomLine1927);
        main_exec_generated_fast_labels.push_back(&&RomLine1928);
        main_exec_generated_fast_labels.push_back(&&RomLine1929);
        main_exec_generated_fast_labels.push_back(&&RomLine1930);
        main_exec_generated_fast_labels.push_back(&&RomLine1931);
        main_exec_generated_fast_labels.push_back(&&RomLine1932);
        main_exec_generated_fast_labels.push_back(&&RomLine1933);
        main_exec_generated_fast_labels.push_back(&&RomLine1934);
        main_exec_generated_fast_labels.push_back(&&RomLine1935);
        main_exec_generated_fast_labels.push_back(&&RomLine1936);
        main_exec_generated_fast_labels.push_back(&&RomLine1937);
        main_exec_generated_fast_labels.push_back(&&RomLine1938);
        main_exec_generated_fast_labels.push_back(&&RomLine1939);
        main_exec_generated_fast_labels.push_back(&&RomLine1940);
        main_exec_generated_fast_labels.push_back(&&RomLine1941);
        main_exec_generated_fast_labels.push_back(&&RomLine1942);
        main_exec_generated_fast_labels.push_back(&&RomLine1943);
        main_exec_generated_fast_labels.push_back(&&RomLine1944);
        main_exec_generated_fast_labels.push_back(&&RomLine1945);
        main_exec_generated_fast_labels.push_back(&&RomLine1946);
        main_exec_generated_fast_labels.push_back(&&RomLine1947);
        main_exec_generated_fast_labels.push_back(&&RomLine1948);
        main_exec_generated_fast_labels.push_back(&&RomLine1949);
        main_exec_generated_fast_labels.push_back(&&RomLine1950);
        main_exec_generated_fast_labels.push_back(&&RomLine1951);
        main_exec_generated_fast_labels.push_back(&&RomLine1952);
        main_exec_generated_fast_labels.push_back(&&RomLine1953);
        main_exec_generated_fast_labels.push_back(&&RomLine1954);
        main_exec_generated_fast_labels.push_back(&&RomLine1955);
        main_exec_generated_fast_labels.push_back(&&RomLine1956);
        main_exec_generated_fast_labels.push_back(&&RomLine1957);
        main_exec_generated_fast_labels.push_back(&&RomLine1958);
        main_exec_generated_fast_labels.push_back(&&RomLine1959);
        main_exec_generated_fast_labels.push_back(&&RomLine1960);
        main_exec_generated_fast_labels.push_back(&&RomLine1961);
        main_exec_generated_fast_labels.push_back(&&RomLine1962);
        main_exec_generated_fast_labels.push_back(&&RomLine1963);
        main_exec_generated_fast_labels.push_back(&&RomLine1964);
        main_exec_generated_fast_labels.push_back(&&RomLine1965);
        main_exec_generated_fast_labels.push_back(&&RomLine1966);
        main_exec_generated_fast_labels.push_back(&&RomLine1967);
        main_exec_generated_fast_labels.push_back(&&RomLine1968);
        main_exec_generated_fast_labels.push_back(&&RomLine1969);
        main_exec_generated_fast_labels.push_back(&&RomLine1970);
        main_exec_generated_fast_labels.push_back(&&RomLine1971);
        main_exec_generated_fast_labels.push_back(&&RomLine1972);
        main_exec_generated_fast_labels.push_back(&&RomLine1973);
        main_exec_generated_fast_labels.push_back(&&RomLine1974);
        main_exec_generated_fast_labels.push_back(&&RomLine1975);
        main_exec_generated_fast_labels.push_back(&&RomLine1976);
        main_exec_generated_fast_labels.push_back(&&RomLine1977);
        main_exec_generated_fast_labels.push_back(&&RomLine1978);
        main_exec_generated_fast_labels.push_back(&&RomLine1979);
        main_exec_generated_fast_labels.push_back(&&RomLine1980);
        main_exec_generated_fast_labels.push_back(&&RomLine1981);
        main_exec_generated_fast_labels.push_back(&&RomLine1982);
        main_exec_generated_fast_labels.push_back(&&RomLine1983);
        main_exec_generated_fast_labels.push_back(&&RomLine1984);
        main_exec_generated_fast_labels.push_back(&&RomLine1985);
        main_exec_generated_fast_labels.push_back(&&RomLine1986);
        main_exec_generated_fast_labels.push_back(&&RomLine1987);
        main_exec_generated_fast_labels.push_back(&&RomLine1988);
        main_exec_generated_fast_labels.push_back(&&RomLine1989);
        main_exec_generated_fast_labels.push_back(&&RomLine1990);
        main_exec_generated_fast_labels.push_back(&&RomLine1991);
        main_exec_generated_fast_labels.push_back(&&RomLine1992);
        main_exec_generated_fast_labels.push_back(&&RomLine1993);
        main_exec_generated_fast_labels.push_back(&&RomLine1994);
        main_exec_generated_fast_labels.push_back(&&RomLine1995);
        main_exec_generated_fast_labels.push_back(&&RomLine1996);
        main_exec_generated_fast_labels.push_back(&&RomLine1997);
        main_exec_generated_fast_labels.push_back(&&RomLine1998);
        main_exec_generated_fast_labels.push_back(&&RomLine1999);
        main_exec_generated_fast_labels.push_back(&&RomLine2000);
        main_exec_generated_fast_labels.push_back(&&RomLine2001);
        main_exec_generated_fast_labels.push_back(&&RomLine2002);
        main_exec_generated_fast_labels.push_back(&&RomLine2003);
        main_exec_generated_fast_labels.push_back(&&RomLine2004);
        main_exec_generated_fast_labels.push_back(&&RomLine2005);
        main_exec_generated_fast_labels.push_back(&&RomLine2006);
        main_exec_generated_fast_labels.push_back(&&RomLine2007);
        main_exec_generated_fast_labels.push_back(&&RomLine2008);
        main_exec_generated_fast_labels.push_back(&&RomLine2009);
        main_exec_generated_fast_labels.push_back(&&RomLine2010);
        main_exec_generated_fast_labels.push_back(&&RomLine2011);
        main_exec_generated_fast_labels.push_back(&&RomLine2012);
        main_exec_generated_fast_labels.push_back(&&RomLine2013);
        main_exec_generated_fast_labels.push_back(&&RomLine2014);
        main_exec_generated_fast_labels.push_back(&&RomLine2015);
        main_exec_generated_fast_labels.push_back(&&RomLine2016);
        main_exec_generated_fast_labels.push_back(&&RomLine2017);
        main_exec_generated_fast_labels.push_back(&&RomLine2018);
        main_exec_generated_fast_labels.push_back(&&RomLine2019);
        main_exec_generated_fast_labels.push_back(&&RomLine2020);
        main_exec_generated_fast_labels.push_back(&&RomLine2021);
        main_exec_generated_fast_labels.push_back(&&RomLine2022);
        main_exec_generated_fast_labels.push_back(&&RomLine2023);
        main_exec_generated_fast_labels.push_back(&&RomLine2024);
        main_exec_generated_fast_labels.push_back(&&RomLine2025);
        main_exec_generated_fast_labels.push_back(&&RomLine2026);
        main_exec_generated_fast_labels.push_back(&&RomLine2027);
        main_exec_generated_fast_labels.push_back(&&RomLine2028);
        main_exec_generated_fast_labels.push_back(&&RomLine2029);
        main_exec_generated_fast_labels.push_back(&&RomLine2030);
        main_exec_generated_fast_labels.push_back(&&RomLine2031);
        main_exec_generated_fast_labels.push_back(&&RomLine2032);
        main_exec_generated_fast_labels.push_back(&&RomLine2033);
        main_exec_generated_fast_labels.push_back(&&RomLine2034);
        main_exec_generated_fast_labels.push_back(&&RomLine2035);
        main_exec_generated_fast_labels.push_back(&&RomLine2036);
        main_exec_generated_fast_labels.push_back(&&RomLine2037);
        main_exec_generated_fast_labels.push_back(&&RomLine2038);
        main_exec_generated_fast_labels.push_back(&&RomLine2039);
        main_exec_generated_fast_labels.push_back(&&RomLine2040);
        main_exec_generated_fast_labels.push_back(&&RomLine2041);
        main_exec_generated_fast_labels.push_back(&&RomLine2042);
        main_exec_generated_fast_labels.push_back(&&RomLine2043);
        main_exec_generated_fast_labels.push_back(&&RomLine2044);
        main_exec_generated_fast_labels.push_back(&&RomLine2045);
        main_exec_generated_fast_labels.push_back(&&RomLine2046);
        main_exec_generated_fast_labels.push_back(&&RomLine2047);
        main_exec_generated_fast_labels.push_back(&&RomLine2048);
        main_exec_generated_fast_labels.push_back(&&RomLine2049);
        main_exec_generated_fast_labels.push_back(&&RomLine2050);
        main_exec_generated_fast_labels.push_back(&&RomLine2051);
        main_exec_generated_fast_labels.push_back(&&RomLine2052);
        main_exec_generated_fast_labels.push_back(&&RomLine2053);
        main_exec_generated_fast_labels.push_back(&&RomLine2054);
        main_exec_generated_fast_labels.push_back(&&RomLine2055);
        main_exec_generated_fast_labels.push_back(&&RomLine2056);
        main_exec_generated_fast_labels.push_back(&&RomLine2057);
        main_exec_generated_fast_labels.push_back(&&RomLine2058);
        main_exec_generated_fast_labels.push_back(&&RomLine2059);
        main_exec_generated_fast_labels.push_back(&&RomLine2060);
        main_exec_generated_fast_labels.push_back(&&RomLine2061);
        main_exec_generated_fast_labels.push_back(&&RomLine2062);
        main_exec_generated_fast_labels.push_back(&&RomLine2063);
        main_exec_generated_fast_labels.push_back(&&RomLine2064);
        main_exec_generated_fast_labels.push_back(&&RomLine2065);
        main_exec_generated_fast_labels.push_back(&&RomLine2066);
        main_exec_generated_fast_labels.push_back(&&RomLine2067);
        main_exec_generated_fast_labels.push_back(&&RomLine2068);
        main_exec_generated_fast_labels.push_back(&&RomLine2069);
        main_exec_generated_fast_labels.push_back(&&RomLine2070);
        main_exec_generated_fast_labels.push_back(&&RomLine2071);
        main_exec_generated_fast_labels.push_back(&&RomLine2072);
        main_exec_generated_fast_labels.push_back(&&RomLine2073);
        main_exec_generated_fast_labels.push_back(&&RomLine2074);
        main_exec_generated_fast_labels.push_back(&&RomLine2075);
        main_exec_generated_fast_labels.push_back(&&RomLine2076);
        main_exec_generated_fast_labels.push_back(&&RomLine2077);
        main_exec_generated_fast_labels.push_back(&&RomLine2078);
        main_exec_generated_fast_labels.push_back(&&RomLine2079);
        main_exec_generated_fast_labels.push_back(&&RomLine2080);
        main_exec_generated_fast_labels.push_back(&&RomLine2081);
        main_exec_generated_fast_labels.push_back(&&RomLine2082);
        main_exec_generated_fast_labels.push_back(&&RomLine2083);
        main_exec_generated_fast_labels.push_back(&&RomLine2084);
        main_exec_generated_fast_labels.push_back(&&RomLine2085);
        main_exec_generated_fast_labels.push_back(&&RomLine2086);
        main_exec_generated_fast_labels.push_back(&&RomLine2087);
        main_exec_generated_fast_labels.push_back(&&RomLine2088);
        main_exec_generated_fast_labels.push_back(&&RomLine2089);
        main_exec_generated_fast_labels.push_back(&&RomLine2090);
        main_exec_generated_fast_labels.push_back(&&RomLine2091);
        main_exec_generated_fast_labels.push_back(&&RomLine2092);
        main_exec_generated_fast_labels.push_back(&&RomLine2093);
        main_exec_generated_fast_labels.push_back(&&RomLine2094);
        main_exec_generated_fast_labels.push_back(&&RomLine2095);
        main_exec_generated_fast_labels.push_back(&&RomLine2096);
        main_exec_generated_fast_labels.push_back(&&RomLine2097);
        main_exec_generated_fast_labels.push_back(&&RomLine2098);
        main_exec_generated_fast_labels.push_back(&&RomLine2099);
        main_exec_generated_fast_labels.push_back(&&RomLine2100);
        main_exec_generated_fast_labels.push_back(&&RomLine2101);
        main_exec_generated_fast_labels.push_back(&&RomLine2102);
        main_exec_generated_fast_labels.push_back(&&RomLine2103);
        main_exec_generated_fast_labels.push_back(&&RomLine2104);
        main_exec_generated_fast_labels.push_back(&&RomLine2105);
        main_exec_generated_fast_labels.push_back(&&RomLine2106);
        main_exec_generated_fast_labels.push_back(&&RomLine2107);
        main_exec_generated_fast_labels.push_back(&&RomLine2108);
        main_exec_generated_fast_labels.push_back(&&RomLine2109);
        main_exec_generated_fast_labels.push_back(&&RomLine2110);
        main_exec_generated_fast_labels.push_back(&&RomLine2111);
        main_exec_generated_fast_labels.push_back(&&RomLine2112);
        main_exec_generated_fast_labels.push_back(&&RomLine2113);
        main_exec_generated_fast_labels.push_back(&&RomLine2114);
        main_exec_generated_fast_labels.push_back(&&RomLine2115);
        main_exec_generated_fast_labels.push_back(&&RomLine2116);
        main_exec_generated_fast_labels.push_back(&&RomLine2117);
        main_exec_generated_fast_labels.push_back(&&RomLine2118);
        main_exec_generated_fast_labels.push_back(&&RomLine2119);
        main_exec_generated_fast_labels.push_back(&&RomLine2120);
        main_exec_generated_fast_labels.push_back(&&RomLine2121);
        main_exec_generated_fast_labels.push_back(&&RomLine2122);
        main_exec_generated_fast_labels.push_back(&&RomLine2123);
        main_exec_generated_fast_labels.push_back(&&RomLine2124);
        main_exec_generated_fast_labels.push_back(&&RomLine2125);
        main_exec_generated_fast_labels.push_back(&&RomLine2126);
        main_exec_generated_fast_labels.push_back(&&RomLine2127);
        main_exec_generated_fast_labels.push_back(&&RomLine2128);
        main_exec_generated_fast_labels.push_back(&&RomLine2129);
        main_exec_generated_fast_labels.push_back(&&RomLine2130);
        main_exec_generated_fast_labels.push_back(&&RomLine2131);
        main_exec_generated_fast_labels.push_back(&&RomLine2132);
        main_exec_generated_fast_labels.push_back(&&RomLine2133);
        main_exec_generated_fast_labels.push_back(&&RomLine2134);
        main_exec_generated_fast_labels.push_back(&&RomLine2135);
        main_exec_generated_fast_labels.push_back(&&RomLine2136);
        main_exec_generated_fast_labels.push_back(&&RomLine2137);
        main_exec_generated_fast_labels.push_back(&&RomLine2138);
        main_exec_generated_fast_labels.push_back(&&RomLine2139);
        main_exec_generated_fast_labels.push_back(&&RomLine2140);
        main_exec_generated_fast_labels.push_back(&&RomLine2141);
        main_exec_generated_fast_labels.push_back(&&RomLine2142);
        main_exec_generated_fast_labels.push_back(&&RomLine2143);
        main_exec_generated_fast_labels.push_back(&&RomLine2144);
        main_exec_generated_fast_labels.push_back(&&RomLine2145);
        main_exec_generated_fast_labels.push_back(&&RomLine2146);
        main_exec_generated_fast_labels.push_back(&&RomLine2147);
        main_exec_generated_fast_labels.push_back(&&RomLine2148);
        main_exec_generated_fast_labels.push_back(&&RomLine2149);
        main_exec_generated_fast_labels.push_back(&&RomLine2150);
        main_exec_generated_fast_labels.push_back(&&RomLine2151);
        main_exec_generated_fast_labels.push_back(&&RomLine2152);
        main_exec_generated_fast_labels.push_back(&&RomLine2153);
        main_exec_generated_fast_labels.push_back(&&RomLine2154);
        main_exec_generated_fast_labels.push_back(&&RomLine2155);
        main_exec_generated_fast_labels.push_back(&&RomLine2156);
        main_exec_generated_fast_labels.push_back(&&RomLine2157);
        main_exec_generated_fast_labels.push_back(&&RomLine2158);
        main_exec_generated_fast_labels.push_back(&&RomLine2159);
        main_exec_generated_fast_labels.push_back(&&RomLine2160);
        main_exec_generated_fast_labels.push_back(&&RomLine2161);
        main_exec_generated_fast_labels.push_back(&&RomLine2162);
        main_exec_generated_fast_labels.push_back(&&RomLine2163);
        main_exec_generated_fast_labels.push_back(&&RomLine2164);
        main_exec_generated_fast_labels.push_back(&&RomLine2165);
        main_exec_generated_fast_labels.push_back(&&RomLine2166);
        main_exec_generated_fast_labels.push_back(&&RomLine2167);
        main_exec_generated_fast_labels.push_back(&&RomLine2168);
        main_exec_generated_fast_labels.push_back(&&RomLine2169);
        main_exec_generated_fast_labels.push_back(&&RomLine2170);
        main_exec_generated_fast_labels.push_back(&&RomLine2171);
        main_exec_generated_fast_labels.push_back(&&RomLine2172);
        main_exec_generated_fast_labels.push_back(&&RomLine2173);
        main_exec_generated_fast_labels.push_back(&&RomLine2174);
        main_exec_generated_fast_labels.push_back(&&RomLine2175);
        main_exec_generated_fast_labels.push_back(&&RomLine2176);
        main_exec_generated_fast_labels.push_back(&&RomLine2177);
        main_exec_generated_fast_labels.push_back(&&RomLine2178);
        main_exec_generated_fast_labels.push_back(&&RomLine2179);
        main_exec_generated_fast_labels.push_back(&&RomLine2180);
        main_exec_generated_fast_labels.push_back(&&RomLine2181);
        main_exec_generated_fast_labels.push_back(&&RomLine2182);
        main_exec_generated_fast_labels.push_back(&&RomLine2183);
        main_exec_generated_fast_labels.push_back(&&RomLine2184);
        main_exec_generated_fast_labels.push_back(&&RomLine2185);
        main_exec_generated_fast_labels.push_back(&&RomLine2186);
        main_exec_generated_fast_labels.push_back(&&RomLine2187);
        main_exec_generated_fast_labels.push_back(&&RomLine2188);
        main_exec_generated_fast_labels.push_back(&&RomLine2189);
        main_exec_generated_fast_labels.push_back(&&RomLine2190);
        main_exec_generated_fast_labels.push_back(&&RomLine2191);
        main_exec_generated_fast_labels.push_back(&&RomLine2192);
        main_exec_generated_fast_labels.push_back(&&RomLine2193);
        main_exec_generated_fast_labels.push_back(&&RomLine2194);
        main_exec_generated_fast_labels.push_back(&&RomLine2195);
        main_exec_generated_fast_labels.push_back(&&RomLine2196);
        main_exec_generated_fast_labels.push_back(&&RomLine2197);
        main_exec_generated_fast_labels.push_back(&&RomLine2198);
        main_exec_generated_fast_labels.push_back(&&RomLine2199);
        main_exec_generated_fast_labels.push_back(&&RomLine2200);
        main_exec_generated_fast_labels.push_back(&&RomLine2201);
        main_exec_generated_fast_labels.push_back(&&RomLine2202);
        main_exec_generated_fast_labels.push_back(&&RomLine2203);
        main_exec_generated_fast_labels.push_back(&&RomLine2204);
        main_exec_generated_fast_labels.push_back(&&RomLine2205);
        main_exec_generated_fast_labels.push_back(&&RomLine2206);
        main_exec_generated_fast_labels.push_back(&&RomLine2207);
        main_exec_generated_fast_labels.push_back(&&RomLine2208);
        main_exec_generated_fast_labels.push_back(&&RomLine2209);
        main_exec_generated_fast_labels.push_back(&&RomLine2210);
        main_exec_generated_fast_labels.push_back(&&RomLine2211);
        main_exec_generated_fast_labels.push_back(&&RomLine2212);
        main_exec_generated_fast_labels.push_back(&&RomLine2213);
        main_exec_generated_fast_labels.push_back(&&RomLine2214);
        main_exec_generated_fast_labels.push_back(&&RomLine2215);
        main_exec_generated_fast_labels.push_back(&&RomLine2216);
        main_exec_generated_fast_labels.push_back(&&RomLine2217);
        main_exec_generated_fast_labels.push_back(&&RomLine2218);
        main_exec_generated_fast_labels.push_back(&&RomLine2219);
        main_exec_generated_fast_labels.push_back(&&RomLine2220);
        main_exec_generated_fast_labels.push_back(&&RomLine2221);
        main_exec_generated_fast_labels.push_back(&&RomLine2222);
        main_exec_generated_fast_labels.push_back(&&RomLine2223);
        main_exec_generated_fast_labels.push_back(&&RomLine2224);
        main_exec_generated_fast_labels.push_back(&&RomLine2225);
        main_exec_generated_fast_labels.push_back(&&RomLine2226);
        main_exec_generated_fast_labels.push_back(&&RomLine2227);
        main_exec_generated_fast_labels.push_back(&&RomLine2228);
        main_exec_generated_fast_labels.push_back(&&RomLine2229);
        main_exec_generated_fast_labels.push_back(&&RomLine2230);
        main_exec_generated_fast_labels.push_back(&&RomLine2231);
        main_exec_generated_fast_labels.push_back(&&RomLine2232);
        main_exec_generated_fast_labels.push_back(&&RomLine2233);
        main_exec_generated_fast_labels.push_back(&&RomLine2234);
        main_exec_generated_fast_labels.push_back(&&RomLine2235);
        main_exec_generated_fast_labels.push_back(&&RomLine2236);
        main_exec_generated_fast_labels.push_back(&&RomLine2237);
        main_exec_generated_fast_labels.push_back(&&RomLine2238);
        main_exec_generated_fast_labels.push_back(&&RomLine2239);
        main_exec_generated_fast_labels.push_back(&&RomLine2240);
        main_exec_generated_fast_labels.push_back(&&RomLine2241);
        main_exec_generated_fast_labels.push_back(&&RomLine2242);
        main_exec_generated_fast_labels.push_back(&&RomLine2243);
        main_exec_generated_fast_labels.push_back(&&RomLine2244);
        main_exec_generated_fast_labels.push_back(&&RomLine2245);
        main_exec_generated_fast_labels.push_back(&&RomLine2246);
        main_exec_generated_fast_labels.push_back(&&RomLine2247);
        main_exec_generated_fast_labels.push_back(&&RomLine2248);
        main_exec_generated_fast_labels.push_back(&&RomLine2249);
        main_exec_generated_fast_labels.push_back(&&RomLine2250);
        main_exec_generated_fast_labels.push_back(&&RomLine2251);
        main_exec_generated_fast_labels.push_back(&&RomLine2252);
        main_exec_generated_fast_labels.push_back(&&RomLine2253);
        main_exec_generated_fast_labels.push_back(&&RomLine2254);
        main_exec_generated_fast_labels.push_back(&&RomLine2255);
        main_exec_generated_fast_labels.push_back(&&RomLine2256);
        main_exec_generated_fast_labels.push_back(&&RomLine2257);
        main_exec_generated_fast_labels.push_back(&&RomLine2258);
        main_exec_generated_fast_labels.push_back(&&RomLine2259);
        main_exec_generated_fast_labels.push_back(&&RomLine2260);
        main_exec_generated_fast_labels.push_back(&&RomLine2261);
        main_exec_generated_fast_labels.push_back(&&RomLine2262);
        main_exec_generated_fast_labels.push_back(&&RomLine2263);
        main_exec_generated_fast_labels.push_back(&&RomLine2264);
        main_exec_generated_fast_labels.push_back(&&RomLine2265);
        main_exec_generated_fast_labels.push_back(&&RomLine2266);
        main_exec_generated_fast_labels.push_back(&&RomLine2267);
        main_exec_generated_fast_labels.push_back(&&RomLine2268);
        main_exec_generated_fast_labels.push_back(&&RomLine2269);
        main_exec_generated_fast_labels.push_back(&&RomLine2270);
        main_exec_generated_fast_labels.push_back(&&RomLine2271);
        main_exec_generated_fast_labels.push_back(&&RomLine2272);
        main_exec_generated_fast_labels.push_back(&&RomLine2273);
        main_exec_generated_fast_labels.push_back(&&RomLine2274);
        main_exec_generated_fast_labels.push_back(&&RomLine2275);
        main_exec_generated_fast_labels.push_back(&&RomLine2276);
        main_exec_generated_fast_labels.push_back(&&RomLine2277);
        main_exec_generated_fast_labels.push_back(&&RomLine2278);
        main_exec_generated_fast_labels.push_back(&&RomLine2279);
        main_exec_generated_fast_labels.push_back(&&RomLine2280);
        main_exec_generated_fast_labels.push_back(&&RomLine2281);
        main_exec_generated_fast_labels.push_back(&&RomLine2282);
        main_exec_generated_fast_labels.push_back(&&RomLine2283);
        main_exec_generated_fast_labels.push_back(&&RomLine2284);
        main_exec_generated_fast_labels.push_back(&&RomLine2285);
        main_exec_generated_fast_labels.push_back(&&RomLine2286);
        main_exec_generated_fast_labels.push_back(&&RomLine2287);
        main_exec_generated_fast_labels.push_back(&&RomLine2288);
        main_exec_generated_fast_labels.push_back(&&RomLine2289);
        main_exec_generated_fast_labels.push_back(&&RomLine2290);
        main_exec_generated_fast_labels.push_back(&&RomLine2291);
        main_exec_generated_fast_labels.push_back(&&RomLine2292);
        main_exec_generated_fast_labels.push_back(&&RomLine2293);
        main_exec_generated_fast_labels.push_back(&&RomLine2294);
        main_exec_generated_fast_labels.push_back(&&RomLine2295);
        main_exec_generated_fast_labels.push_back(&&RomLine2296);
        main_exec_generated_fast_labels.push_back(&&RomLine2297);
        main_exec_generated_fast_labels.push_back(&&RomLine2298);
        main_exec_generated_fast_labels.push_back(&&RomLine2299);
        main_exec_generated_fast_labels.push_back(&&RomLine2300);
        main_exec_generated_fast_labels.push_back(&&RomLine2301);
        main_exec_generated_fast_labels.push_back(&&RomLine2302);
        main_exec_generated_fast_labels.push_back(&&RomLine2303);
        main_exec_generated_fast_labels.push_back(&&RomLine2304);
        main_exec_generated_fast_labels.push_back(&&RomLine2305);
        main_exec_generated_fast_labels.push_back(&&RomLine2306);
        main_exec_generated_fast_labels.push_back(&&RomLine2307);
        main_exec_generated_fast_labels.push_back(&&RomLine2308);
        main_exec_generated_fast_labels.push_back(&&RomLine2309);
        main_exec_generated_fast_labels.push_back(&&RomLine2310);
        main_exec_generated_fast_labels.push_back(&&RomLine2311);
        main_exec_generated_fast_labels.push_back(&&RomLine2312);
        main_exec_generated_fast_labels.push_back(&&RomLine2313);
        main_exec_generated_fast_labels.push_back(&&RomLine2314);
        main_exec_generated_fast_labels.push_back(&&RomLine2315);
        main_exec_generated_fast_labels.push_back(&&RomLine2316);
        main_exec_generated_fast_labels.push_back(&&RomLine2317);
        main_exec_generated_fast_labels.push_back(&&RomLine2318);
        main_exec_generated_fast_labels.push_back(&&RomLine2319);
        main_exec_generated_fast_labels.push_back(&&RomLine2320);
        main_exec_generated_fast_labels.push_back(&&RomLine2321);
        main_exec_generated_fast_labels.push_back(&&RomLine2322);
        main_exec_generated_fast_labels.push_back(&&RomLine2323);
        main_exec_generated_fast_labels.push_back(&&RomLine2324);
        main_exec_generated_fast_labels.push_back(&&RomLine2325);
        main_exec_generated_fast_labels.push_back(&&RomLine2326);
        main_exec_generated_fast_labels.push_back(&&RomLine2327);
        main_exec_generated_fast_labels.push_back(&&RomLine2328);
        main_exec_generated_fast_labels.push_back(&&RomLine2329);
        main_exec_generated_fast_labels.push_back(&&RomLine2330);
        main_exec_generated_fast_labels.push_back(&&RomLine2331);
        main_exec_generated_fast_labels.push_back(&&RomLine2332);
        main_exec_generated_fast_labels.push_back(&&RomLine2333);
        main_exec_generated_fast_labels.push_back(&&RomLine2334);
        main_exec_generated_fast_labels.push_back(&&RomLine2335);
        main_exec_generated_fast_labels.push_back(&&RomLine2336);
        main_exec_generated_fast_labels.push_back(&&RomLine2337);
        main_exec_generated_fast_labels.push_back(&&RomLine2338);
        main_exec_generated_fast_labels.push_back(&&RomLine2339);
        main_exec_generated_fast_labels.push_back(&&RomLine2340);
        main_exec_generated_fast_labels.push_back(&&RomLine2341);
        main_exec_generated_fast_labels.push_back(&&RomLine2342);
        main_exec_generated_fast_labels.push_back(&&RomLine2343);
        main_exec_generated_fast_labels.push_back(&&RomLine2344);
        main_exec_generated_fast_labels.push_back(&&RomLine2345);
        main_exec_generated_fast_labels.push_back(&&RomLine2346);
        main_exec_generated_fast_labels.push_back(&&RomLine2347);
        main_exec_generated_fast_labels.push_back(&&RomLine2348);
        main_exec_generated_fast_labels.push_back(&&RomLine2349);
        main_exec_generated_fast_labels.push_back(&&RomLine2350);
        main_exec_generated_fast_labels.push_back(&&RomLine2351);
        main_exec_generated_fast_labels.push_back(&&RomLine2352);
        main_exec_generated_fast_labels.push_back(&&RomLine2353);
        main_exec_generated_fast_labels.push_back(&&RomLine2354);
        main_exec_generated_fast_labels.push_back(&&RomLine2355);
        main_exec_generated_fast_labels.push_back(&&RomLine2356);
        main_exec_generated_fast_labels.push_back(&&RomLine2357);
        main_exec_generated_fast_labels.push_back(&&RomLine2358);
        main_exec_generated_fast_labels.push_back(&&RomLine2359);
        main_exec_generated_fast_labels.push_back(&&RomLine2360);
        main_exec_generated_fast_labels.push_back(&&RomLine2361);
        main_exec_generated_fast_labels.push_back(&&RomLine2362);
        main_exec_generated_fast_labels.push_back(&&RomLine2363);
        main_exec_generated_fast_labels.push_back(&&RomLine2364);
        main_exec_generated_fast_labels.push_back(&&RomLine2365);
        main_exec_generated_fast_labels.push_back(&&RomLine2366);
        main_exec_generated_fast_labels.push_back(&&RomLine2367);
        main_exec_generated_fast_labels.push_back(&&RomLine2368);
        main_exec_generated_fast_labels.push_back(&&RomLine2369);
        main_exec_generated_fast_labels.push_back(&&RomLine2370);
        main_exec_generated_fast_labels.push_back(&&RomLine2371);
        main_exec_generated_fast_labels.push_back(&&RomLine2372);
        main_exec_generated_fast_labels.push_back(&&RomLine2373);
        main_exec_generated_fast_labels.push_back(&&RomLine2374);
        main_exec_generated_fast_labels.push_back(&&RomLine2375);
        main_exec_generated_fast_labels.push_back(&&RomLine2376);
        main_exec_generated_fast_labels.push_back(&&RomLine2377);
        main_exec_generated_fast_labels.push_back(&&RomLine2378);
        main_exec_generated_fast_labels.push_back(&&RomLine2379);
        main_exec_generated_fast_labels.push_back(&&RomLine2380);
        main_exec_generated_fast_labels.push_back(&&RomLine2381);
        main_exec_generated_fast_labels.push_back(&&RomLine2382);
        main_exec_generated_fast_labels.push_back(&&RomLine2383);
        main_exec_generated_fast_labels.push_back(&&RomLine2384);
        main_exec_generated_fast_labels.push_back(&&RomLine2385);
        main_exec_generated_fast_labels.push_back(&&RomLine2386);
        main_exec_generated_fast_labels.push_back(&&RomLine2387);
        main_exec_generated_fast_labels.push_back(&&RomLine2388);
        main_exec_generated_fast_labels.push_back(&&RomLine2389);
        main_exec_generated_fast_labels.push_back(&&RomLine2390);
        main_exec_generated_fast_labels.push_back(&&RomLine2391);
        main_exec_generated_fast_labels.push_back(&&RomLine2392);
        main_exec_generated_fast_labels.push_back(&&RomLine2393);
        main_exec_generated_fast_labels.push_back(&&RomLine2394);
        main_exec_generated_fast_labels.push_back(&&RomLine2395);
        main_exec_generated_fast_labels.push_back(&&RomLine2396);
        main_exec_generated_fast_labels.push_back(&&RomLine2397);
        main_exec_generated_fast_labels.push_back(&&RomLine2398);
        main_exec_generated_fast_labels.push_back(&&RomLine2399);
        main_exec_generated_fast_labels.push_back(&&RomLine2400);
        main_exec_generated_fast_labels.push_back(&&RomLine2401);
        main_exec_generated_fast_labels.push_back(&&RomLine2402);
        main_exec_generated_fast_labels.push_back(&&RomLine2403);
        main_exec_generated_fast_labels.push_back(&&RomLine2404);
        main_exec_generated_fast_labels.push_back(&&RomLine2405);
        main_exec_generated_fast_labels.push_back(&&RomLine2406);
        main_exec_generated_fast_labels.push_back(&&RomLine2407);
        main_exec_generated_fast_labels.push_back(&&RomLine2408);
        main_exec_generated_fast_labels.push_back(&&RomLine2409);
        main_exec_generated_fast_labels.push_back(&&RomLine2410);
        main_exec_generated_fast_labels.push_back(&&RomLine2411);
        main_exec_generated_fast_labels.push_back(&&RomLine2412);
        main_exec_generated_fast_labels.push_back(&&RomLine2413);
        main_exec_generated_fast_labels.push_back(&&RomLine2414);
        main_exec_generated_fast_labels.push_back(&&RomLine2415);
        main_exec_generated_fast_labels.push_back(&&RomLine2416);
        main_exec_generated_fast_labels.push_back(&&RomLine2417);
        main_exec_generated_fast_labels.push_back(&&RomLine2418);
        main_exec_generated_fast_labels.push_back(&&RomLine2419);
        main_exec_generated_fast_labels.push_back(&&RomLine2420);
        main_exec_generated_fast_labels.push_back(&&RomLine2421);
        main_exec_generated_fast_labels.push_back(&&RomLine2422);
        main_exec_generated_fast_labels.push_back(&&RomLine2423);
        main_exec_generated_fast_labels.push_back(&&RomLine2424);
        main_exec_generated_fast_labels.push_back(&&RomLine2425);
        main_exec_generated_fast_labels.push_back(&&RomLine2426);
        main_exec_generated_fast_labels.push_back(&&RomLine2427);
        main_exec_generated_fast_labels.push_back(&&RomLine2428);
        main_exec_generated_fast_labels.push_back(&&RomLine2429);
        main_exec_generated_fast_labels.push_back(&&RomLine2430);
        main_exec_generated_fast_labels.push_back(&&RomLine2431);
        main_exec_generated_fast_labels.push_back(&&RomLine2432);
        main_exec_generated_fast_labels.push_back(&&RomLine2433);
        main_exec_generated_fast_labels.push_back(&&RomLine2434);
        main_exec_generated_fast_labels.push_back(&&RomLine2435);
        main_exec_generated_fast_labels.push_back(&&RomLine2436);
        main_exec_generated_fast_labels.push_back(&&RomLine2437);
        main_exec_generated_fast_labels.push_back(&&RomLine2438);
        main_exec_generated_fast_labels.push_back(&&RomLine2439);
        main_exec_generated_fast_labels.push_back(&&RomLine2440);
        main_exec_generated_fast_labels.push_back(&&RomLine2441);
        main_exec_generated_fast_labels.push_back(&&RomLine2442);
        main_exec_generated_fast_labels.push_back(&&RomLine2443);
        main_exec_generated_fast_labels.push_back(&&RomLine2444);
        main_exec_generated_fast_labels.push_back(&&RomLine2445);
        main_exec_generated_fast_labels.push_back(&&RomLine2446);
        main_exec_generated_fast_labels.push_back(&&RomLine2447);
        main_exec_generated_fast_labels.push_back(&&RomLine2448);
        main_exec_generated_fast_labels.push_back(&&RomLine2449);
        main_exec_generated_fast_labels.push_back(&&RomLine2450);
        main_exec_generated_fast_labels.push_back(&&RomLine2451);
        main_exec_generated_fast_labels.push_back(&&RomLine2452);
        main_exec_generated_fast_labels.push_back(&&RomLine2453);
        main_exec_generated_fast_labels.push_back(&&RomLine2454);
        main_exec_generated_fast_labels.push_back(&&RomLine2455);
        main_exec_generated_fast_labels.push_back(&&RomLine2456);
        main_exec_generated_fast_labels.push_back(&&RomLine2457);
        main_exec_generated_fast_labels.push_back(&&RomLine2458);
        main_exec_generated_fast_labels.push_back(&&RomLine2459);
        main_exec_generated_fast_labels.push_back(&&RomLine2460);
        main_exec_generated_fast_labels.push_back(&&RomLine2461);
        main_exec_generated_fast_labels.push_back(&&RomLine2462);
        main_exec_generated_fast_labels.push_back(&&RomLine2463);
        main_exec_generated_fast_labels.push_back(&&RomLine2464);
        main_exec_generated_fast_labels.push_back(&&RomLine2465);
        main_exec_generated_fast_labels.push_back(&&RomLine2466);
        main_exec_generated_fast_labels.push_back(&&RomLine2467);
        main_exec_generated_fast_labels.push_back(&&RomLine2468);
        main_exec_generated_fast_labels.push_back(&&RomLine2469);
        main_exec_generated_fast_labels.push_back(&&RomLine2470);
        main_exec_generated_fast_labels.push_back(&&RomLine2471);
        main_exec_generated_fast_labels.push_back(&&RomLine2472);
        main_exec_generated_fast_labels.push_back(&&RomLine2473);
        main_exec_generated_fast_labels.push_back(&&RomLine2474);
        main_exec_generated_fast_labels.push_back(&&RomLine2475);
        main_exec_generated_fast_labels.push_back(&&RomLine2476);
        main_exec_generated_fast_labels.push_back(&&RomLine2477);
        main_exec_generated_fast_labels.push_back(&&RomLine2478);
        main_exec_generated_fast_labels.push_back(&&RomLine2479);
        main_exec_generated_fast_labels.push_back(&&RomLine2480);
        main_exec_generated_fast_labels.push_back(&&RomLine2481);
        main_exec_generated_fast_labels.push_back(&&RomLine2482);
        main_exec_generated_fast_labels.push_back(&&RomLine2483);
        main_exec_generated_fast_labels.push_back(&&RomLine2484);
        main_exec_generated_fast_labels.push_back(&&RomLine2485);
        main_exec_generated_fast_labels.push_back(&&RomLine2486);
        main_exec_generated_fast_labels.push_back(&&RomLine2487);
        main_exec_generated_fast_labels.push_back(&&RomLine2488);
        main_exec_generated_fast_labels.push_back(&&RomLine2489);
        main_exec_generated_fast_labels.push_back(&&RomLine2490);
        main_exec_generated_fast_labels.push_back(&&RomLine2491);
        main_exec_generated_fast_labels.push_back(&&RomLine2492);
        main_exec_generated_fast_labels.push_back(&&RomLine2493);
        main_exec_generated_fast_labels.push_back(&&RomLine2494);
        main_exec_generated_fast_labels.push_back(&&RomLine2495);
        main_exec_generated_fast_labels.push_back(&&RomLine2496);
        main_exec_generated_fast_labels.push_back(&&RomLine2497);
        main_exec_generated_fast_labels.push_back(&&RomLine2498);
        main_exec_generated_fast_labels.push_back(&&RomLine2499);
        main_exec_generated_fast_labels.push_back(&&RomLine2500);
        main_exec_generated_fast_labels.push_back(&&RomLine2501);
        main_exec_generated_fast_labels.push_back(&&RomLine2502);
        main_exec_generated_fast_labels.push_back(&&RomLine2503);
        main_exec_generated_fast_labels.push_back(&&RomLine2504);
        main_exec_generated_fast_labels.push_back(&&RomLine2505);
        main_exec_generated_fast_labels.push_back(&&RomLine2506);
        main_exec_generated_fast_labels.push_back(&&RomLine2507);
        main_exec_generated_fast_labels.push_back(&&RomLine2508);
        main_exec_generated_fast_labels.push_back(&&RomLine2509);
        main_exec_generated_fast_labels.push_back(&&RomLine2510);
        main_exec_generated_fast_labels.push_back(&&RomLine2511);
        main_exec_generated_fast_labels.push_back(&&RomLine2512);
        main_exec_generated_fast_labels.push_back(&&RomLine2513);
        main_exec_generated_fast_labels.push_back(&&RomLine2514);
        main_exec_generated_fast_labels.push_back(&&RomLine2515);
        main_exec_generated_fast_labels.push_back(&&RomLine2516);
        main_exec_generated_fast_labels.push_back(&&RomLine2517);
        main_exec_generated_fast_labels.push_back(&&RomLine2518);
        main_exec_generated_fast_labels.push_back(&&RomLine2519);
        main_exec_generated_fast_labels.push_back(&&RomLine2520);
        main_exec_generated_fast_labels.push_back(&&RomLine2521);
        main_exec_generated_fast_labels.push_back(&&RomLine2522);
        main_exec_generated_fast_labels.push_back(&&RomLine2523);
        main_exec_generated_fast_labels.push_back(&&RomLine2524);
        main_exec_generated_fast_labels.push_back(&&RomLine2525);
        main_exec_generated_fast_labels.push_back(&&RomLine2526);
        main_exec_generated_fast_labels.push_back(&&RomLine2527);
        main_exec_generated_fast_labels.push_back(&&RomLine2528);
        main_exec_generated_fast_labels.push_back(&&RomLine2529);
        main_exec_generated_fast_labels.push_back(&&RomLine2530);
        main_exec_generated_fast_labels.push_back(&&RomLine2531);
        main_exec_generated_fast_labels.push_back(&&RomLine2532);
        main_exec_generated_fast_labels.push_back(&&RomLine2533);
        main_exec_generated_fast_labels.push_back(&&RomLine2534);
        main_exec_generated_fast_labels.push_back(&&RomLine2535);
        main_exec_generated_fast_labels.push_back(&&RomLine2536);
        main_exec_generated_fast_labels.push_back(&&RomLine2537);
        main_exec_generated_fast_labels.push_back(&&RomLine2538);
        main_exec_generated_fast_labels.push_back(&&RomLine2539);
        main_exec_generated_fast_labels.push_back(&&RomLine2540);
        main_exec_generated_fast_labels.push_back(&&RomLine2541);
        main_exec_generated_fast_labels.push_back(&&RomLine2542);
        main_exec_generated_fast_labels.push_back(&&RomLine2543);
        main_exec_generated_fast_labels.push_back(&&RomLine2544);
        main_exec_generated_fast_labels.push_back(&&RomLine2545);
        main_exec_generated_fast_labels.push_back(&&RomLine2546);
        main_exec_generated_fast_labels.push_back(&&RomLine2547);
        main_exec_generated_fast_labels.push_back(&&RomLine2548);
        main_exec_generated_fast_labels.push_back(&&RomLine2549);
        main_exec_generated_fast_labels.push_back(&&RomLine2550);
        main_exec_generated_fast_labels.push_back(&&RomLine2551);
        main_exec_generated_fast_labels.push_back(&&RomLine2552);
        main_exec_generated_fast_labels.push_back(&&RomLine2553);
        main_exec_generated_fast_labels.push_back(&&RomLine2554);
        main_exec_generated_fast_labels.push_back(&&RomLine2555);
        main_exec_generated_fast_labels.push_back(&&RomLine2556);
        main_exec_generated_fast_labels.push_back(&&RomLine2557);
        main_exec_generated_fast_labels.push_back(&&RomLine2558);
        main_exec_generated_fast_labels.push_back(&&RomLine2559);
        main_exec_generated_fast_labels.push_back(&&RomLine2560);
        main_exec_generated_fast_labels.push_back(&&RomLine2561);
        main_exec_generated_fast_labels.push_back(&&RomLine2562);
        main_exec_generated_fast_labels.push_back(&&RomLine2563);
        main_exec_generated_fast_labels.push_back(&&RomLine2564);
        main_exec_generated_fast_labels.push_back(&&RomLine2565);
        main_exec_generated_fast_labels.push_back(&&RomLine2566);
        main_exec_generated_fast_labels.push_back(&&RomLine2567);
        main_exec_generated_fast_labels.push_back(&&RomLine2568);
        main_exec_generated_fast_labels.push_back(&&RomLine2569);
        main_exec_generated_fast_labels.push_back(&&RomLine2570);
        main_exec_generated_fast_labels.push_back(&&RomLine2571);
        main_exec_generated_fast_labels.push_back(&&RomLine2572);
        main_exec_generated_fast_labels.push_back(&&RomLine2573);
        main_exec_generated_fast_labels.push_back(&&RomLine2574);
        main_exec_generated_fast_labels.push_back(&&RomLine2575);
        main_exec_generated_fast_labels.push_back(&&RomLine2576);
        main_exec_generated_fast_labels.push_back(&&RomLine2577);
        main_exec_generated_fast_labels.push_back(&&RomLine2578);
        main_exec_generated_fast_labels.push_back(&&RomLine2579);
        main_exec_generated_fast_labels.push_back(&&RomLine2580);
        main_exec_generated_fast_labels.push_back(&&RomLine2581);
        main_exec_generated_fast_labels.push_back(&&RomLine2582);
        main_exec_generated_fast_labels.push_back(&&RomLine2583);
        main_exec_generated_fast_labels.push_back(&&RomLine2584);
        main_exec_generated_fast_labels.push_back(&&RomLine2585);
        main_exec_generated_fast_labels.push_back(&&RomLine2586);
        main_exec_generated_fast_labels.push_back(&&RomLine2587);
        main_exec_generated_fast_labels.push_back(&&RomLine2588);
        main_exec_generated_fast_labels.push_back(&&RomLine2589);
        main_exec_generated_fast_labels.push_back(&&RomLine2590);
        main_exec_generated_fast_labels.push_back(&&RomLine2591);
        main_exec_generated_fast_labels.push_back(&&RomLine2592);
        main_exec_generated_fast_labels.push_back(&&RomLine2593);
        main_exec_generated_fast_labels.push_back(&&RomLine2594);
        main_exec_generated_fast_labels.push_back(&&RomLine2595);
        main_exec_generated_fast_labels.push_back(&&RomLine2596);
        main_exec_generated_fast_labels.push_back(&&RomLine2597);
        main_exec_generated_fast_labels.push_back(&&RomLine2598);
        main_exec_generated_fast_labels.push_back(&&RomLine2599);
        main_exec_generated_fast_labels.push_back(&&RomLine2600);
        main_exec_generated_fast_labels.push_back(&&RomLine2601);
        main_exec_generated_fast_labels.push_back(&&RomLine2602);
        main_exec_generated_fast_labels.push_back(&&RomLine2603);
        main_exec_generated_fast_labels.push_back(&&RomLine2604);
        main_exec_generated_fast_labels.push_back(&&RomLine2605);
        main_exec_generated_fast_labels.push_back(&&RomLine2606);
        main_exec_generated_fast_labels.push_back(&&RomLine2607);
        main_exec_generated_fast_labels.push_back(&&RomLine2608);
        main_exec_generated_fast_labels.push_back(&&RomLine2609);
        main_exec_generated_fast_labels.push_back(&&RomLine2610);
        main_exec_generated_fast_labels.push_back(&&RomLine2611);
        main_exec_generated_fast_labels.push_back(&&RomLine2612);
        main_exec_generated_fast_labels.push_back(&&RomLine2613);
        main_exec_generated_fast_labels.push_back(&&RomLine2614);
        main_exec_generated_fast_labels.push_back(&&RomLine2615);
        main_exec_generated_fast_labels.push_back(&&RomLine2616);
        main_exec_generated_fast_labels.push_back(&&RomLine2617);
        main_exec_generated_fast_labels.push_back(&&RomLine2618);
        main_exec_generated_fast_labels.push_back(&&RomLine2619);
        main_exec_generated_fast_labels.push_back(&&RomLine2620);
        main_exec_generated_fast_labels.push_back(&&RomLine2621);
        main_exec_generated_fast_labels.push_back(&&RomLine2622);
        main_exec_generated_fast_labels.push_back(&&RomLine2623);
        main_exec_generated_fast_labels.push_back(&&RomLine2624);
        main_exec_generated_fast_labels.push_back(&&RomLine2625);
        main_exec_generated_fast_labels.push_back(&&RomLine2626);
        main_exec_generated_fast_labels.push_back(&&RomLine2627);
        main_exec_generated_fast_labels.push_back(&&RomLine2628);
        main_exec_generated_fast_labels.push_back(&&RomLine2629);
        main_exec_generated_fast_labels.push_back(&&RomLine2630);
        main_exec_generated_fast_labels.push_back(&&RomLine2631);
        main_exec_generated_fast_labels.push_back(&&RomLine2632);
        main_exec_generated_fast_labels.push_back(&&RomLine2633);
        main_exec_generated_fast_labels.push_back(&&RomLine2634);
        main_exec_generated_fast_labels.push_back(&&RomLine2635);
        main_exec_generated_fast_labels.push_back(&&RomLine2636);
        main_exec_generated_fast_labels.push_back(&&RomLine2637);
        main_exec_generated_fast_labels.push_back(&&RomLine2638);
        main_exec_generated_fast_labels.push_back(&&RomLine2639);
        main_exec_generated_fast_labels.push_back(&&RomLine2640);
        main_exec_generated_fast_labels.push_back(&&RomLine2641);
        main_exec_generated_fast_labels.push_back(&&RomLine2642);
        main_exec_generated_fast_labels.push_back(&&RomLine2643);
        main_exec_generated_fast_labels.push_back(&&RomLine2644);
        main_exec_generated_fast_labels.push_back(&&RomLine2645);
        main_exec_generated_fast_labels.push_back(&&RomLine2646);
        main_exec_generated_fast_labels.push_back(&&RomLine2647);
        main_exec_generated_fast_labels.push_back(&&RomLine2648);
        main_exec_generated_fast_labels.push_back(&&RomLine2649);
        main_exec_generated_fast_labels.push_back(&&RomLine2650);
        main_exec_generated_fast_labels.push_back(&&RomLine2651);
        main_exec_generated_fast_labels.push_back(&&RomLine2652);
        main_exec_generated_fast_labels.push_back(&&RomLine2653);
        main_exec_generated_fast_labels.push_back(&&RomLine2654);
        main_exec_generated_fast_labels.push_back(&&RomLine2655);
        main_exec_generated_fast_labels.push_back(&&RomLine2656);
        main_exec_generated_fast_labels.push_back(&&RomLine2657);
        main_exec_generated_fast_labels.push_back(&&RomLine2658);
        main_exec_generated_fast_labels.push_back(&&RomLine2659);
        main_exec_generated_fast_labels.push_back(&&RomLine2660);
        main_exec_generated_fast_labels.push_back(&&RomLine2661);
        main_exec_generated_fast_labels.push_back(&&RomLine2662);
        main_exec_generated_fast_labels.push_back(&&RomLine2663);
        main_exec_generated_fast_labels.push_back(&&RomLine2664);
        main_exec_generated_fast_labels.push_back(&&RomLine2665);
        main_exec_generated_fast_labels.push_back(&&RomLine2666);
        main_exec_generated_fast_labels.push_back(&&RomLine2667);
        main_exec_generated_fast_labels.push_back(&&RomLine2668);
        main_exec_generated_fast_labels.push_back(&&RomLine2669);
        main_exec_generated_fast_labels.push_back(&&RomLine2670);
        main_exec_generated_fast_labels.push_back(&&RomLine2671);
        main_exec_generated_fast_labels.push_back(&&RomLine2672);
        main_exec_generated_fast_labels.push_back(&&RomLine2673);
        main_exec_generated_fast_labels.push_back(&&RomLine2674);
        main_exec_generated_fast_labels.push_back(&&RomLine2675);
        main_exec_generated_fast_labels.push_back(&&RomLine2676);
        main_exec_generated_fast_labels.push_back(&&RomLine2677);
        main_exec_generated_fast_labels.push_back(&&RomLine2678);
        main_exec_generated_fast_labels.push_back(&&RomLine2679);
        main_exec_generated_fast_labels.push_back(&&RomLine2680);
        main_exec_generated_fast_labels.push_back(&&RomLine2681);
        main_exec_generated_fast_labels.push_back(&&RomLine2682);
        main_exec_generated_fast_labels.push_back(&&RomLine2683);
        main_exec_generated_fast_labels.push_back(&&RomLine2684);
        main_exec_generated_fast_labels.push_back(&&RomLine2685);
        main_exec_generated_fast_labels.push_back(&&RomLine2686);
        main_exec_generated_fast_labels.push_back(&&RomLine2687);
        main_exec_generated_fast_labels.push_back(&&RomLine2688);
        main_exec_generated_fast_labels.push_back(&&RomLine2689);
        main_exec_generated_fast_labels.push_back(&&RomLine2690);
        main_exec_generated_fast_labels.push_back(&&RomLine2691);
        main_exec_generated_fast_labels.push_back(&&RomLine2692);
        main_exec_generated_fast_labels.push_back(&&RomLine2693);
        main_exec_generated_fast_labels.push_back(&&RomLine2694);
        main_exec_generated_fast_labels.push_back(&&RomLine2695);
        main_exec_generated_fast_labels.push_back(&&RomLine2696);
        main_exec_generated_fast_labels.push_back(&&RomLine2697);
        main_exec_generated_fast_labels.push_back(&&RomLine2698);
        main_exec_generated_fast_labels.push_back(&&RomLine2699);
        main_exec_generated_fast_labels.push_back(&&RomLine2700);
        main_exec_generated_fast_labels.push_back(&&RomLine2701);
        main_exec_generated_fast_labels.push_back(&&RomLine2702);
        main_exec_generated_fast_labels.push_back(&&RomLine2703);
        main_exec_generated_fast_labels.push_back(&&RomLine2704);
        main_exec_generated_fast_labels.push_back(&&RomLine2705);
        main_exec_generated_fast_labels.push_back(&&RomLine2706);
        main_exec_generated_fast_labels.push_back(&&RomLine2707);
        main_exec_generated_fast_labels.push_back(&&RomLine2708);
        main_exec_generated_fast_labels.push_back(&&RomLine2709);
        main_exec_generated_fast_labels.push_back(&&RomLine2710);
        main_exec_generated_fast_labels.push_back(&&RomLine2711);
        main_exec_generated_fast_labels.push_back(&&RomLine2712);
        main_exec_generated_fast_labels.push_back(&&RomLine2713);
        main_exec_generated_fast_labels.push_back(&&RomLine2714);
        main_exec_generated_fast_labels.push_back(&&RomLine2715);
        main_exec_generated_fast_labels.push_back(&&RomLine2716);
        main_exec_generated_fast_labels.push_back(&&RomLine2717);
        main_exec_generated_fast_labels.push_back(&&RomLine2718);
        main_exec_generated_fast_labels.push_back(&&RomLine2719);
        main_exec_generated_fast_labels.push_back(&&RomLine2720);
        main_exec_generated_fast_labels.push_back(&&RomLine2721);
        main_exec_generated_fast_labels.push_back(&&RomLine2722);
        main_exec_generated_fast_labels.push_back(&&RomLine2723);
        main_exec_generated_fast_labels.push_back(&&RomLine2724);
        main_exec_generated_fast_labels.push_back(&&RomLine2725);
        main_exec_generated_fast_labels.push_back(&&RomLine2726);
        main_exec_generated_fast_labels.push_back(&&RomLine2727);
        main_exec_generated_fast_labels.push_back(&&RomLine2728);
        main_exec_generated_fast_labels.push_back(&&RomLine2729);
        main_exec_generated_fast_labels.push_back(&&RomLine2730);
        main_exec_generated_fast_labels.push_back(&&RomLine2731);
        main_exec_generated_fast_labels.push_back(&&RomLine2732);
        main_exec_generated_fast_labels.push_back(&&RomLine2733);
        main_exec_generated_fast_labels.push_back(&&RomLine2734);
        main_exec_generated_fast_labels.push_back(&&RomLine2735);
        main_exec_generated_fast_labels.push_back(&&RomLine2736);
        main_exec_generated_fast_labels.push_back(&&RomLine2737);
        main_exec_generated_fast_labels.push_back(&&RomLine2738);
        main_exec_generated_fast_labels.push_back(&&RomLine2739);
        main_exec_generated_fast_labels.push_back(&&RomLine2740);
        main_exec_generated_fast_labels.push_back(&&RomLine2741);
        main_exec_generated_fast_labels.push_back(&&RomLine2742);
        main_exec_generated_fast_labels.push_back(&&RomLine2743);
        main_exec_generated_fast_labels.push_back(&&RomLine2744);
        main_exec_generated_fast_labels.push_back(&&RomLine2745);
        main_exec_generated_fast_labels.push_back(&&RomLine2746);
        main_exec_generated_fast_labels.push_back(&&RomLine2747);
        main_exec_generated_fast_labels.push_back(&&RomLine2748);
        main_exec_generated_fast_labels.push_back(&&RomLine2749);
        main_exec_generated_fast_labels.push_back(&&RomLine2750);
        main_exec_generated_fast_labels.push_back(&&RomLine2751);
        main_exec_generated_fast_labels.push_back(&&RomLine2752);
        main_exec_generated_fast_labels.push_back(&&RomLine2753);
        main_exec_generated_fast_labels.push_back(&&RomLine2754);
        main_exec_generated_fast_labels.push_back(&&RomLine2755);
        main_exec_generated_fast_labels.push_back(&&RomLine2756);
        main_exec_generated_fast_labels.push_back(&&RomLine2757);
        main_exec_generated_fast_labels.push_back(&&RomLine2758);
        main_exec_generated_fast_labels.push_back(&&RomLine2759);
        main_exec_generated_fast_labels.push_back(&&RomLine2760);
        main_exec_generated_fast_labels.push_back(&&RomLine2761);
        main_exec_generated_fast_labels.push_back(&&RomLine2762);
        main_exec_generated_fast_labels.push_back(&&RomLine2763);
        main_exec_generated_fast_labels.push_back(&&RomLine2764);
        main_exec_generated_fast_labels.push_back(&&RomLine2765);
        main_exec_generated_fast_labels.push_back(&&RomLine2766);
        main_exec_generated_fast_labels.push_back(&&RomLine2767);
        main_exec_generated_fast_labels.push_back(&&RomLine2768);
        main_exec_generated_fast_labels.push_back(&&RomLine2769);
        main_exec_generated_fast_labels.push_back(&&RomLine2770);
        main_exec_generated_fast_labels.push_back(&&RomLine2771);
        main_exec_generated_fast_labels.push_back(&&RomLine2772);
        main_exec_generated_fast_labels.push_back(&&RomLine2773);
        main_exec_generated_fast_labels.push_back(&&RomLine2774);
        main_exec_generated_fast_labels.push_back(&&RomLine2775);
        main_exec_generated_fast_labels.push_back(&&RomLine2776);
        main_exec_generated_fast_labels.push_back(&&RomLine2777);
        main_exec_generated_fast_labels.push_back(&&RomLine2778);
        main_exec_generated_fast_labels.push_back(&&RomLine2779);
        main_exec_generated_fast_labels.push_back(&&RomLine2780);
        main_exec_generated_fast_labels.push_back(&&RomLine2781);
        main_exec_generated_fast_labels.push_back(&&RomLine2782);
        main_exec_generated_fast_labels.push_back(&&RomLine2783);
        main_exec_generated_fast_labels.push_back(&&RomLine2784);
        main_exec_generated_fast_labels.push_back(&&RomLine2785);
        main_exec_generated_fast_labels.push_back(&&RomLine2786);
        main_exec_generated_fast_labels.push_back(&&RomLine2787);
        main_exec_generated_fast_labels.push_back(&&RomLine2788);
        main_exec_generated_fast_labels.push_back(&&RomLine2789);
        main_exec_generated_fast_labels.push_back(&&RomLine2790);
        main_exec_generated_fast_labels.push_back(&&RomLine2791);
        main_exec_generated_fast_labels.push_back(&&RomLine2792);
        main_exec_generated_fast_labels.push_back(&&RomLine2793);
        main_exec_generated_fast_labels.push_back(&&RomLine2794);
        main_exec_generated_fast_labels.push_back(&&RomLine2795);
        main_exec_generated_fast_labels.push_back(&&RomLine2796);
        main_exec_generated_fast_labels.push_back(&&RomLine2797);
        main_exec_generated_fast_labels.push_back(&&RomLine2798);
        main_exec_generated_fast_labels.push_back(&&RomLine2799);
        main_exec_generated_fast_labels.push_back(&&RomLine2800);
        main_exec_generated_fast_labels.push_back(&&RomLine2801);
        main_exec_generated_fast_labels.push_back(&&RomLine2802);
        main_exec_generated_fast_labels.push_back(&&RomLine2803);
        main_exec_generated_fast_labels.push_back(&&RomLine2804);
        main_exec_generated_fast_labels.push_back(&&RomLine2805);
        main_exec_generated_fast_labels.push_back(&&RomLine2806);
        main_exec_generated_fast_labels.push_back(&&RomLine2807);
        main_exec_generated_fast_labels.push_back(&&RomLine2808);
        main_exec_generated_fast_labels.push_back(&&RomLine2809);
        main_exec_generated_fast_labels.push_back(&&RomLine2810);
        main_exec_generated_fast_labels.push_back(&&RomLine2811);
        main_exec_generated_fast_labels.push_back(&&RomLine2812);
        main_exec_generated_fast_labels.push_back(&&RomLine2813);
        main_exec_generated_fast_labels.push_back(&&RomLine2814);
        main_exec_generated_fast_labels.push_back(&&RomLine2815);
        main_exec_generated_fast_labels.push_back(&&RomLine2816);
        main_exec_generated_fast_labels.push_back(&&RomLine2817);
        main_exec_generated_fast_labels.push_back(&&RomLine2818);
        main_exec_generated_fast_labels.push_back(&&RomLine2819);
        main_exec_generated_fast_labels.push_back(&&RomLine2820);
        main_exec_generated_fast_labels.push_back(&&RomLine2821);
        main_exec_generated_fast_labels.push_back(&&RomLine2822);
        main_exec_generated_fast_labels.push_back(&&RomLine2823);
        main_exec_generated_fast_labels.push_back(&&RomLine2824);
        main_exec_generated_fast_labels.push_back(&&RomLine2825);
        main_exec_generated_fast_labels.push_back(&&RomLine2826);
        main_exec_generated_fast_labels.push_back(&&RomLine2827);
        main_exec_generated_fast_labels.push_back(&&RomLine2828);
        main_exec_generated_fast_labels.push_back(&&RomLine2829);
        main_exec_generated_fast_labels.push_back(&&RomLine2830);
        main_exec_generated_fast_labels.push_back(&&RomLine2831);
        main_exec_generated_fast_labels.push_back(&&RomLine2832);
        main_exec_generated_fast_labels.push_back(&&RomLine2833);
        main_exec_generated_fast_labels.push_back(&&RomLine2834);
        main_exec_generated_fast_labels.push_back(&&RomLine2835);
        main_exec_generated_fast_labels.push_back(&&RomLine2836);
        main_exec_generated_fast_labels.push_back(&&RomLine2837);
        main_exec_generated_fast_labels.push_back(&&RomLine2838);
        main_exec_generated_fast_labels.push_back(&&RomLine2839);
        main_exec_generated_fast_labels.push_back(&&RomLine2840);
        main_exec_generated_fast_labels.push_back(&&RomLine2841);
        main_exec_generated_fast_labels.push_back(&&RomLine2842);
        main_exec_generated_fast_labels.push_back(&&RomLine2843);
        main_exec_generated_fast_labels.push_back(&&RomLine2844);
        main_exec_generated_fast_labels.push_back(&&RomLine2845);
        main_exec_generated_fast_labels.push_back(&&RomLine2846);
        main_exec_generated_fast_labels.push_back(&&RomLine2847);
        main_exec_generated_fast_labels.push_back(&&RomLine2848);
        main_exec_generated_fast_labels.push_back(&&RomLine2849);
        main_exec_generated_fast_labels.push_back(&&RomLine2850);
        main_exec_generated_fast_labels.push_back(&&RomLine2851);
        main_exec_generated_fast_labels.push_back(&&RomLine2852);
        main_exec_generated_fast_labels.push_back(&&RomLine2853);
        main_exec_generated_fast_labels.push_back(&&RomLine2854);
        main_exec_generated_fast_labels.push_back(&&RomLine2855);
        main_exec_generated_fast_labels.push_back(&&RomLine2856);
        main_exec_generated_fast_labels.push_back(&&RomLine2857);
        main_exec_generated_fast_labels.push_back(&&RomLine2858);
        main_exec_generated_fast_labels.push_back(&&RomLine2859);
        main_exec_generated_fast_labels.push_back(&&RomLine2860);
        main_exec_generated_fast_labels.push_back(&&RomLine2861);
        main_exec_generated_fast_labels.push_back(&&RomLine2862);
        main_exec_generated_fast_labels.push_back(&&RomLine2863);
        main_exec_generated_fast_labels.push_back(&&RomLine2864);
        main_exec_generated_fast_labels.push_back(&&RomLine2865);
        main_exec_generated_fast_labels.push_back(&&RomLine2866);
        main_exec_generated_fast_labels.push_back(&&RomLine2867);
        main_exec_generated_fast_labels.push_back(&&RomLine2868);
        main_exec_generated_fast_labels.push_back(&&RomLine2869);
        main_exec_generated_fast_labels.push_back(&&RomLine2870);
        main_exec_generated_fast_labels.push_back(&&RomLine2871);
        main_exec_generated_fast_labels.push_back(&&RomLine2872);
        main_exec_generated_fast_labels.push_back(&&RomLine2873);
        main_exec_generated_fast_labels.push_back(&&RomLine2874);
        main_exec_generated_fast_labels.push_back(&&RomLine2875);
        main_exec_generated_fast_labels.push_back(&&RomLine2876);
        main_exec_generated_fast_labels.push_back(&&RomLine2877);
        main_exec_generated_fast_labels.push_back(&&RomLine2878);
        main_exec_generated_fast_labels.push_back(&&RomLine2879);
        main_exec_generated_fast_labels.push_back(&&RomLine2880);
        main_exec_generated_fast_labels.push_back(&&RomLine2881);
        main_exec_generated_fast_labels.push_back(&&RomLine2882);
        main_exec_generated_fast_labels.push_back(&&RomLine2883);
        main_exec_generated_fast_labels.push_back(&&RomLine2884);
        main_exec_generated_fast_labels.push_back(&&RomLine2885);
        main_exec_generated_fast_labels.push_back(&&RomLine2886);
        main_exec_generated_fast_labels.push_back(&&RomLine2887);
        main_exec_generated_fast_labels.push_back(&&RomLine2888);
        main_exec_generated_fast_labels.push_back(&&RomLine2889);
        main_exec_generated_fast_labels.push_back(&&RomLine2890);
        main_exec_generated_fast_labels.push_back(&&RomLine2891);
        main_exec_generated_fast_labels.push_back(&&RomLine2892);
        main_exec_generated_fast_labels.push_back(&&RomLine2893);
        main_exec_generated_fast_labels.push_back(&&RomLine2894);
        main_exec_generated_fast_labels.push_back(&&RomLine2895);
        main_exec_generated_fast_labels.push_back(&&RomLine2896);
        main_exec_generated_fast_labels.push_back(&&RomLine2897);
        main_exec_generated_fast_labels.push_back(&&RomLine2898);
        main_exec_generated_fast_labels.push_back(&&RomLine2899);
        main_exec_generated_fast_labels.push_back(&&RomLine2900);
        main_exec_generated_fast_labels.push_back(&&RomLine2901);
        main_exec_generated_fast_labels.push_back(&&RomLine2902);
        main_exec_generated_fast_labels.push_back(&&RomLine2903);
        main_exec_generated_fast_labels.push_back(&&RomLine2904);
        main_exec_generated_fast_labels.push_back(&&RomLine2905);
        main_exec_generated_fast_labels.push_back(&&RomLine2906);
        main_exec_generated_fast_labels.push_back(&&RomLine2907);
        main_exec_generated_fast_labels.push_back(&&RomLine2908);
        main_exec_generated_fast_labels.push_back(&&RomLine2909);
        main_exec_generated_fast_labels.push_back(&&RomLine2910);
        main_exec_generated_fast_labels.push_back(&&RomLine2911);
        main_exec_generated_fast_labels.push_back(&&RomLine2912);
        main_exec_generated_fast_labels.push_back(&&RomLine2913);
        main_exec_generated_fast_labels.push_back(&&RomLine2914);
        main_exec_generated_fast_labels.push_back(&&RomLine2915);
        main_exec_generated_fast_labels.push_back(&&RomLine2916);
        main_exec_generated_fast_labels.push_back(&&RomLine2917);
        main_exec_generated_fast_labels.push_back(&&RomLine2918);
        main_exec_generated_fast_labels.push_back(&&RomLine2919);
        main_exec_generated_fast_labels.push_back(&&RomLine2920);
        main_exec_generated_fast_labels.push_back(&&RomLine2921);
        main_exec_generated_fast_labels.push_back(&&RomLine2922);
        main_exec_generated_fast_labels.push_back(&&RomLine2923);
        main_exec_generated_fast_labels.push_back(&&RomLine2924);
        main_exec_generated_fast_labels.push_back(&&RomLine2925);
        main_exec_generated_fast_labels.push_back(&&RomLine2926);
        main_exec_generated_fast_labels.push_back(&&RomLine2927);
        main_exec_generated_fast_labels.push_back(&&RomLine2928);
        main_exec_generated_fast_labels.push_back(&&RomLine2929);
        main_exec_generated_fast_labels.push_back(&&RomLine2930);
        main_exec_generated_fast_labels.push_back(&&RomLine2931);
        main_exec_generated_fast_labels.push_back(&&RomLine2932);
        main_exec_generated_fast_labels.push_back(&&RomLine2933);
        main_exec_generated_fast_labels.push_back(&&RomLine2934);
        main_exec_generated_fast_labels.push_back(&&RomLine2935);
        main_exec_generated_fast_labels.push_back(&&RomLine2936);
        main_exec_generated_fast_labels.push_back(&&RomLine2937);
        main_exec_generated_fast_labels.push_back(&&RomLine2938);
        main_exec_generated_fast_labels.push_back(&&RomLine2939);
        main_exec_generated_fast_labels.push_back(&&RomLine2940);
        main_exec_generated_fast_labels.push_back(&&RomLine2941);
        main_exec_generated_fast_labels.push_back(&&RomLine2942);
        main_exec_generated_fast_labels.push_back(&&RomLine2943);
        main_exec_generated_fast_labels.push_back(&&RomLine2944);
        main_exec_generated_fast_labels.push_back(&&RomLine2945);
        main_exec_generated_fast_labels.push_back(&&RomLine2946);
        main_exec_generated_fast_labels.push_back(&&RomLine2947);
        main_exec_generated_fast_labels.push_back(&&RomLine2948);
        main_exec_generated_fast_labels.push_back(&&RomLine2949);
        main_exec_generated_fast_labels.push_back(&&RomLine2950);
        main_exec_generated_fast_labels.push_back(&&RomLine2951);
        main_exec_generated_fast_labels.push_back(&&RomLine2952);
        main_exec_generated_fast_labels.push_back(&&RomLine2953);
        main_exec_generated_fast_labels.push_back(&&RomLine2954);
        main_exec_generated_fast_labels.push_back(&&RomLine2955);
        main_exec_generated_fast_labels.push_back(&&RomLine2956);
        main_exec_generated_fast_labels.push_back(&&RomLine2957);
        main_exec_generated_fast_labels.push_back(&&RomLine2958);
        main_exec_generated_fast_labels.push_back(&&RomLine2959);
        main_exec_generated_fast_labels.push_back(&&RomLine2960);
        main_exec_generated_fast_labels.push_back(&&RomLine2961);
        main_exec_generated_fast_labels.push_back(&&RomLine2962);
        main_exec_generated_fast_labels.push_back(&&RomLine2963);
        main_exec_generated_fast_labels.push_back(&&RomLine2964);
        main_exec_generated_fast_labels.push_back(&&RomLine2965);
        main_exec_generated_fast_labels.push_back(&&RomLine2966);
        main_exec_generated_fast_labels.push_back(&&RomLine2967);
        main_exec_generated_fast_labels.push_back(&&RomLine2968);
        main_exec_generated_fast_labels.push_back(&&RomLine2969);
        main_exec_generated_fast_labels.push_back(&&RomLine2970);
        main_exec_generated_fast_labels.push_back(&&RomLine2971);
        main_exec_generated_fast_labels.push_back(&&RomLine2972);
        main_exec_generated_fast_labels.push_back(&&RomLine2973);
        main_exec_generated_fast_labels.push_back(&&RomLine2974);
        main_exec_generated_fast_labels.push_back(&&RomLine2975);
        main_exec_generated_fast_labels.push_back(&&RomLine2976);
        main_exec_generated_fast_labels.push_back(&&RomLine2977);
        main_exec_generated_fast_labels.push_back(&&RomLine2978);
        main_exec_generated_fast_labels.push_back(&&RomLine2979);
        main_exec_generated_fast_labels.push_back(&&RomLine2980);
        main_exec_generated_fast_labels.push_back(&&RomLine2981);
        main_exec_generated_fast_labels.push_back(&&RomLine2982);
        main_exec_generated_fast_labels.push_back(&&RomLine2983);
        main_exec_generated_fast_labels.push_back(&&RomLine2984);
        main_exec_generated_fast_labels.push_back(&&RomLine2985);
        main_exec_generated_fast_labels.push_back(&&RomLine2986);
        main_exec_generated_fast_labels.push_back(&&RomLine2987);
        main_exec_generated_fast_labels.push_back(&&RomLine2988);
        main_exec_generated_fast_labels.push_back(&&RomLine2989);
        main_exec_generated_fast_labels.push_back(&&RomLine2990);
        main_exec_generated_fast_labels.push_back(&&RomLine2991);
        main_exec_generated_fast_labels.push_back(&&RomLine2992);
        main_exec_generated_fast_labels.push_back(&&RomLine2993);
        main_exec_generated_fast_labels.push_back(&&RomLine2994);
        main_exec_generated_fast_labels.push_back(&&RomLine2995);
        main_exec_generated_fast_labels.push_back(&&RomLine2996);
        main_exec_generated_fast_labels.push_back(&&RomLine2997);
        main_exec_generated_fast_labels.push_back(&&RomLine2998);
        main_exec_generated_fast_labels.push_back(&&RomLine2999);
        main_exec_generated_fast_labels.push_back(&&RomLine3000);
        main_exec_generated_fast_labels.push_back(&&RomLine3001);
        main_exec_generated_fast_labels.push_back(&&RomLine3002);
        main_exec_generated_fast_labels.push_back(&&RomLine3003);
        main_exec_generated_fast_labels.push_back(&&RomLine3004);
        main_exec_generated_fast_labels.push_back(&&RomLine3005);
        main_exec_generated_fast_labels.push_back(&&RomLine3006);
        main_exec_generated_fast_labels.push_back(&&RomLine3007);
        main_exec_generated_fast_labels.push_back(&&RomLine3008);
        main_exec_generated_fast_labels.push_back(&&RomLine3009);
        main_exec_generated_fast_labels.push_back(&&RomLine3010);
        main_exec_generated_fast_labels.push_back(&&RomLine3011);
        main_exec_generated_fast_labels.push_back(&&RomLine3012);
        main_exec_generated_fast_labels.push_back(&&RomLine3013);
        main_exec_generated_fast_labels.push_back(&&RomLine3014);
        main_exec_generated_fast_labels.push_back(&&RomLine3015);
        main_exec_generated_fast_labels.push_back(&&RomLine3016);
        main_exec_generated_fast_labels.push_back(&&RomLine3017);
        main_exec_generated_fast_labels.push_back(&&RomLine3018);
        main_exec_generated_fast_labels.push_back(&&RomLine3019);
        main_exec_generated_fast_labels.push_back(&&RomLine3020);
        main_exec_generated_fast_labels.push_back(&&RomLine3021);
        main_exec_generated_fast_labels.push_back(&&RomLine3022);
        main_exec_generated_fast_labels.push_back(&&RomLine3023);
        main_exec_generated_fast_labels.push_back(&&RomLine3024);
        main_exec_generated_fast_labels.push_back(&&RomLine3025);
        main_exec_generated_fast_labels.push_back(&&RomLine3026);
        main_exec_generated_fast_labels.push_back(&&RomLine3027);
        main_exec_generated_fast_labels.push_back(&&RomLine3028);
        main_exec_generated_fast_labels.push_back(&&RomLine3029);
        main_exec_generated_fast_labels.push_back(&&RomLine3030);
        main_exec_generated_fast_labels.push_back(&&RomLine3031);
        main_exec_generated_fast_labels.push_back(&&RomLine3032);
        main_exec_generated_fast_labels.push_back(&&RomLine3033);
        main_exec_generated_fast_labels.push_back(&&RomLine3034);
        main_exec_generated_fast_labels.push_back(&&RomLine3035);
        main_exec_generated_fast_labels.push_back(&&RomLine3036);
        main_exec_generated_fast_labels.push_back(&&RomLine3037);
        main_exec_generated_fast_labels.push_back(&&RomLine3038);
        main_exec_generated_fast_labels.push_back(&&RomLine3039);
        main_exec_generated_fast_labels.push_back(&&RomLine3040);
        main_exec_generated_fast_labels.push_back(&&RomLine3041);
        main_exec_generated_fast_labels.push_back(&&RomLine3042);
        main_exec_generated_fast_labels.push_back(&&RomLine3043);
        main_exec_generated_fast_labels.push_back(&&RomLine3044);
        main_exec_generated_fast_labels.push_back(&&RomLine3045);
        main_exec_generated_fast_labels.push_back(&&RomLine3046);
        main_exec_generated_fast_labels.push_back(&&RomLine3047);
        main_exec_generated_fast_labels.push_back(&&RomLine3048);
        main_exec_generated_fast_labels.push_back(&&RomLine3049);
        main_exec_generated_fast_labels.push_back(&&RomLine3050);
        main_exec_generated_fast_labels.push_back(&&RomLine3051);
        main_exec_generated_fast_labels.push_back(&&RomLine3052);
        main_exec_generated_fast_labels.push_back(&&RomLine3053);
        main_exec_generated_fast_labels.push_back(&&RomLine3054);
        main_exec_generated_fast_labels.push_back(&&RomLine3055);
        main_exec_generated_fast_labels.push_back(&&RomLine3056);
        main_exec_generated_fast_labels.push_back(&&RomLine3057);
        main_exec_generated_fast_labels.push_back(&&RomLine3058);
        main_exec_generated_fast_labels.push_back(&&RomLine3059);
        main_exec_generated_fast_labels.push_back(&&RomLine3060);
        main_exec_generated_fast_labels.push_back(&&RomLine3061);
        main_exec_generated_fast_labels.push_back(&&RomLine3062);
        main_exec_generated_fast_labels.push_back(&&RomLine3063);
        main_exec_generated_fast_labels.push_back(&&RomLine3064);
        main_exec_generated_fast_labels.push_back(&&RomLine3065);
        main_exec_generated_fast_labels.push_back(&&RomLine3066);
        main_exec_generated_fast_labels.push_back(&&RomLine3067);
        main_exec_generated_fast_labels.push_back(&&RomLine3068);
        main_exec_generated_fast_labels.push_back(&&RomLine3069);
        main_exec_generated_fast_labels.push_back(&&RomLine3070);
        main_exec_generated_fast_labels.push_back(&&RomLine3071);
        main_exec_generated_fast_labels.push_back(&&RomLine3072);
        main_exec_generated_fast_labels.push_back(&&RomLine3073);
        main_exec_generated_fast_labels.push_back(&&RomLine3074);
        main_exec_generated_fast_labels.push_back(&&RomLine3075);
        main_exec_generated_fast_labels.push_back(&&RomLine3076);
        main_exec_generated_fast_labels.push_back(&&RomLine3077);
        main_exec_generated_fast_labels.push_back(&&RomLine3078);
        main_exec_generated_fast_labels.push_back(&&RomLine3079);
        main_exec_generated_fast_labels.push_back(&&RomLine3080);
        main_exec_generated_fast_labels.push_back(&&RomLine3081);
        main_exec_generated_fast_labels.push_back(&&RomLine3082);
        main_exec_generated_fast_labels.push_back(&&RomLine3083);
        main_exec_generated_fast_labels.push_back(&&RomLine3084);
        main_exec_generated_fast_labels.push_back(&&RomLine3085);
        main_exec_generated_fast_labels.push_back(&&RomLine3086);
        main_exec_generated_fast_labels.push_back(&&RomLine3087);
        main_exec_generated_fast_labels.push_back(&&RomLine3088);
        main_exec_generated_fast_labels.push_back(&&RomLine3089);
        main_exec_generated_fast_labels.push_back(&&RomLine3090);
        main_exec_generated_fast_labels.push_back(&&RomLine3091);
        main_exec_generated_fast_labels.push_back(&&RomLine3092);
        main_exec_generated_fast_labels.push_back(&&RomLine3093);
        main_exec_generated_fast_labels.push_back(&&RomLine3094);
        main_exec_generated_fast_labels.push_back(&&RomLine3095);
        main_exec_generated_fast_labels.push_back(&&RomLine3096);
        main_exec_generated_fast_labels.push_back(&&RomLine3097);
        main_exec_generated_fast_labels.push_back(&&RomLine3098);
        main_exec_generated_fast_labels.push_back(&&RomLine3099);
        main_exec_generated_fast_labels.push_back(&&RomLine3100);
        main_exec_generated_fast_labels.push_back(&&RomLine3101);
        main_exec_generated_fast_labels.push_back(&&RomLine3102);
        main_exec_generated_fast_labels.push_back(&&RomLine3103);
        main_exec_generated_fast_labels.push_back(&&RomLine3104);
        main_exec_generated_fast_labels.push_back(&&RomLine3105);
        main_exec_generated_fast_labels.push_back(&&RomLine3106);
        main_exec_generated_fast_labels.push_back(&&RomLine3107);
        main_exec_generated_fast_labels.push_back(&&RomLine3108);
        main_exec_generated_fast_labels.push_back(&&RomLine3109);
        main_exec_generated_fast_labels.push_back(&&RomLine3110);
        main_exec_generated_fast_labels.push_back(&&RomLine3111);
        main_exec_generated_fast_labels.push_back(&&RomLine3112);
        main_exec_generated_fast_labels.push_back(&&RomLine3113);
        main_exec_generated_fast_labels.push_back(&&RomLine3114);
        main_exec_generated_fast_labels.push_back(&&RomLine3115);
        main_exec_generated_fast_labels.push_back(&&RomLine3116);
        main_exec_generated_fast_labels.push_back(&&RomLine3117);
        main_exec_generated_fast_labels.push_back(&&RomLine3118);
        main_exec_generated_fast_labels.push_back(&&RomLine3119);
        main_exec_generated_fast_labels.push_back(&&RomLine3120);
        main_exec_generated_fast_labels.push_back(&&RomLine3121);
        main_exec_generated_fast_labels.push_back(&&RomLine3122);
        main_exec_generated_fast_labels.push_back(&&RomLine3123);
        main_exec_generated_fast_labels.push_back(&&RomLine3124);
        main_exec_generated_fast_labels.push_back(&&RomLine3125);
        main_exec_generated_fast_labels.push_back(&&RomLine3126);
        main_exec_generated_fast_labels.push_back(&&RomLine3127);
        main_exec_generated_fast_labels.push_back(&&RomLine3128);
        main_exec_generated_fast_labels.push_back(&&RomLine3129);
        main_exec_generated_fast_labels.push_back(&&RomLine3130);
        main_exec_generated_fast_labels.push_back(&&RomLine3131);
        main_exec_generated_fast_labels.push_back(&&RomLine3132);
        main_exec_generated_fast_labels.push_back(&&RomLine3133);
        main_exec_generated_fast_labels.push_back(&&RomLine3134);
        main_exec_generated_fast_labels.push_back(&&RomLine3135);
        main_exec_generated_fast_labels.push_back(&&RomLine3136);
        main_exec_generated_fast_labels.push_back(&&RomLine3137);
        main_exec_generated_fast_labels.push_back(&&RomLine3138);
        main_exec_generated_fast_labels.push_back(&&RomLine3139);
        main_exec_generated_fast_labels.push_back(&&RomLine3140);
        main_exec_generated_fast_labels.push_back(&&RomLine3141);
        main_exec_generated_fast_labels.push_back(&&RomLine3142);
        main_exec_generated_fast_labels.push_back(&&RomLine3143);
        main_exec_generated_fast_labels.push_back(&&RomLine3144);
        main_exec_generated_fast_labels.push_back(&&RomLine3145);
        main_exec_generated_fast_labels.push_back(&&RomLine3146);
        main_exec_generated_fast_labels.push_back(&&RomLine3147);
        main_exec_generated_fast_labels.push_back(&&RomLine3148);
        main_exec_generated_fast_labels.push_back(&&RomLine3149);
        main_exec_generated_fast_labels.push_back(&&RomLine3150);
        main_exec_generated_fast_labels.push_back(&&RomLine3151);
        main_exec_generated_fast_labels.push_back(&&RomLine3152);
        main_exec_generated_fast_labels.push_back(&&RomLine3153);
        main_exec_generated_fast_labels.push_back(&&RomLine3154);
        main_exec_generated_fast_labels.push_back(&&RomLine3155);
        main_exec_generated_fast_labels.push_back(&&RomLine3156);
        main_exec_generated_fast_labels.push_back(&&RomLine3157);
        main_exec_generated_fast_labels.push_back(&&RomLine3158);
        main_exec_generated_fast_labels.push_back(&&RomLine3159);
        main_exec_generated_fast_labels.push_back(&&RomLine3160);
        main_exec_generated_fast_labels.push_back(&&RomLine3161);
        main_exec_generated_fast_labels.push_back(&&RomLine3162);
        main_exec_generated_fast_labels.push_back(&&RomLine3163);
        main_exec_generated_fast_labels.push_back(&&RomLine3164);
        main_exec_generated_fast_labels.push_back(&&RomLine3165);
        main_exec_generated_fast_labels.push_back(&&RomLine3166);
        main_exec_generated_fast_labels.push_back(&&RomLine3167);
        main_exec_generated_fast_labels.push_back(&&RomLine3168);
        main_exec_generated_fast_labels.push_back(&&RomLine3169);
        main_exec_generated_fast_labels.push_back(&&RomLine3170);
        main_exec_generated_fast_labels.push_back(&&RomLine3171);
        main_exec_generated_fast_labels.push_back(&&RomLine3172);
        main_exec_generated_fast_labels.push_back(&&RomLine3173);
        main_exec_generated_fast_labels.push_back(&&RomLine3174);
        main_exec_generated_fast_labels.push_back(&&RomLine3175);
        main_exec_generated_fast_labels.push_back(&&RomLine3176);
        main_exec_generated_fast_labels.push_back(&&RomLine3177);
        main_exec_generated_fast_labels.push_back(&&RomLine3178);
        main_exec_generated_fast_labels.push_back(&&RomLine3179);
        main_exec_generated_fast_labels.push_back(&&RomLine3180);
        main_exec_generated_fast_labels.push_back(&&RomLine3181);
        main_exec_generated_fast_labels.push_back(&&RomLine3182);
        main_exec_generated_fast_labels.push_back(&&RomLine3183);
        main_exec_generated_fast_labels.push_back(&&RomLine3184);
        main_exec_generated_fast_labels.push_back(&&RomLine3185);
        main_exec_generated_fast_labels.push_back(&&RomLine3186);
        main_exec_generated_fast_labels.push_back(&&RomLine3187);
        main_exec_generated_fast_labels.push_back(&&RomLine3188);
        main_exec_generated_fast_labels.push_back(&&RomLine3189);
        main_exec_generated_fast_labels.push_back(&&RomLine3190);
        main_exec_generated_fast_labels.push_back(&&RomLine3191);
        main_exec_generated_fast_labels.push_back(&&RomLine3192);
        main_exec_generated_fast_labels.push_back(&&RomLine3193);
        main_exec_generated_fast_labels.push_back(&&RomLine3194);
        main_exec_generated_fast_labels.push_back(&&RomLine3195);
        main_exec_generated_fast_labels.push_back(&&RomLine3196);
        main_exec_generated_fast_labels.push_back(&&RomLine3197);
        main_exec_generated_fast_labels.push_back(&&RomLine3198);
        main_exec_generated_fast_labels.push_back(&&RomLine3199);
        main_exec_generated_fast_labels.push_back(&&RomLine3200);
        main_exec_generated_fast_labels.push_back(&&RomLine3201);
        main_exec_generated_fast_labels.push_back(&&RomLine3202);
        main_exec_generated_fast_labels.push_back(&&RomLine3203);
        main_exec_generated_fast_labels.push_back(&&RomLine3204);
        main_exec_generated_fast_labels.push_back(&&RomLine3205);
        main_exec_generated_fast_labels.push_back(&&RomLine3206);
        main_exec_generated_fast_labels.push_back(&&RomLine3207);
        main_exec_generated_fast_labels.push_back(&&RomLine3208);
        main_exec_generated_fast_labels.push_back(&&RomLine3209);
        main_exec_generated_fast_labels.push_back(&&RomLine3210);
        main_exec_generated_fast_labels.push_back(&&RomLine3211);
        main_exec_generated_fast_labels.push_back(&&RomLine3212);
        main_exec_generated_fast_labels.push_back(&&RomLine3213);
        main_exec_generated_fast_labels.push_back(&&RomLine3214);
        main_exec_generated_fast_labels.push_back(&&RomLine3215);
        main_exec_generated_fast_labels.push_back(&&RomLine3216);
        main_exec_generated_fast_labels.push_back(&&RomLine3217);
        main_exec_generated_fast_labels.push_back(&&RomLine3218);
        main_exec_generated_fast_labels.push_back(&&RomLine3219);
        main_exec_generated_fast_labels.push_back(&&RomLine3220);
        main_exec_generated_fast_labels.push_back(&&RomLine3221);
        main_exec_generated_fast_labels.push_back(&&RomLine3222);
        main_exec_generated_fast_labels.push_back(&&RomLine3223);
        main_exec_generated_fast_labels.push_back(&&RomLine3224);
        main_exec_generated_fast_labels.push_back(&&RomLine3225);
        main_exec_generated_fast_labels.push_back(&&RomLine3226);
        main_exec_generated_fast_labels.push_back(&&RomLine3227);
        main_exec_generated_fast_labels.push_back(&&RomLine3228);
        main_exec_generated_fast_labels.push_back(&&RomLine3229);
        main_exec_generated_fast_labels.push_back(&&RomLine3230);
        main_exec_generated_fast_labels.push_back(&&RomLine3231);
        main_exec_generated_fast_labels.push_back(&&RomLine3232);
        main_exec_generated_fast_labels.push_back(&&RomLine3233);
        main_exec_generated_fast_labels.push_back(&&RomLine3234);
        main_exec_generated_fast_labels.push_back(&&RomLine3235);
        main_exec_generated_fast_labels.push_back(&&RomLine3236);
        main_exec_generated_fast_labels.push_back(&&RomLine3237);
        main_exec_generated_fast_labels.push_back(&&RomLine3238);
        main_exec_generated_fast_labels.push_back(&&RomLine3239);
        main_exec_generated_fast_labels.push_back(&&RomLine3240);
        main_exec_generated_fast_labels.push_back(&&RomLine3241);
        main_exec_generated_fast_labels.push_back(&&RomLine3242);
        main_exec_generated_fast_labels.push_back(&&RomLine3243);
        main_exec_generated_fast_labels.push_back(&&RomLine3244);
        main_exec_generated_fast_labels.push_back(&&RomLine3245);
        main_exec_generated_fast_labels.push_back(&&RomLine3246);
        main_exec_generated_fast_labels.push_back(&&RomLine3247);
        main_exec_generated_fast_labels.push_back(&&RomLine3248);
        main_exec_generated_fast_labels.push_back(&&RomLine3249);
        main_exec_generated_fast_labels.push_back(&&RomLine3250);
        main_exec_generated_fast_labels.push_back(&&RomLine3251);
        main_exec_generated_fast_labels.push_back(&&RomLine3252);
        main_exec_generated_fast_labels.push_back(&&RomLine3253);
        main_exec_generated_fast_labels.push_back(&&RomLine3254);
        main_exec_generated_fast_labels.push_back(&&RomLine3255);
        main_exec_generated_fast_labels.push_back(&&RomLine3256);
        main_exec_generated_fast_labels.push_back(&&RomLine3257);
        main_exec_generated_fast_labels.push_back(&&RomLine3258);
        main_exec_generated_fast_labels.push_back(&&RomLine3259);
        main_exec_generated_fast_labels.push_back(&&RomLine3260);
        main_exec_generated_fast_labels.push_back(&&RomLine3261);
        main_exec_generated_fast_labels.push_back(&&RomLine3262);
        main_exec_generated_fast_labels.push_back(&&RomLine3263);
        main_exec_generated_fast_labels.push_back(&&RomLine3264);
        main_exec_generated_fast_labels.push_back(&&RomLine3265);
        main_exec_generated_fast_labels.push_back(&&RomLine3266);
        main_exec_generated_fast_labels.push_back(&&RomLine3267);
        main_exec_generated_fast_labels.push_back(&&RomLine3268);
        main_exec_generated_fast_labels.push_back(&&RomLine3269);
        main_exec_generated_fast_labels.push_back(&&RomLine3270);
        main_exec_generated_fast_labels.push_back(&&RomLine3271);
        main_exec_generated_fast_labels.push_back(&&RomLine3272);
        main_exec_generated_fast_labels.push_back(&&RomLine3273);
        main_exec_generated_fast_labels.push_back(&&RomLine3274);
        main_exec_generated_fast_labels.push_back(&&RomLine3275);
        main_exec_generated_fast_labels.push_back(&&RomLine3276);
        main_exec_generated_fast_labels.push_back(&&RomLine3277);
        main_exec_generated_fast_labels.push_back(&&RomLine3278);
        main_exec_generated_fast_labels.push_back(&&RomLine3279);
        main_exec_generated_fast_labels.push_back(&&RomLine3280);
        main_exec_generated_fast_labels.push_back(&&RomLine3281);
        main_exec_generated_fast_labels.push_back(&&RomLine3282);
        main_exec_generated_fast_labels.push_back(&&RomLine3283);
        main_exec_generated_fast_labels.push_back(&&RomLine3284);
        main_exec_generated_fast_labels.push_back(&&RomLine3285);
        main_exec_generated_fast_labels.push_back(&&RomLine3286);
        main_exec_generated_fast_labels.push_back(&&RomLine3287);
        main_exec_generated_fast_labels.push_back(&&RomLine3288);
        main_exec_generated_fast_labels.push_back(&&RomLine3289);
        main_exec_generated_fast_labels.push_back(&&RomLine3290);
        main_exec_generated_fast_labels.push_back(&&RomLine3291);
        main_exec_generated_fast_labels.push_back(&&RomLine3292);
        main_exec_generated_fast_labels.push_back(&&RomLine3293);
        main_exec_generated_fast_labels.push_back(&&RomLine3294);
        main_exec_generated_fast_labels.push_back(&&RomLine3295);
        main_exec_generated_fast_labels.push_back(&&RomLine3296);
        main_exec_generated_fast_labels.push_back(&&RomLine3297);
        main_exec_generated_fast_labels.push_back(&&RomLine3298);
        main_exec_generated_fast_labels.push_back(&&RomLine3299);
        main_exec_generated_fast_labels.push_back(&&RomLine3300);
        main_exec_generated_fast_labels.push_back(&&RomLine3301);
        main_exec_generated_fast_labels.push_back(&&RomLine3302);
        main_exec_generated_fast_labels.push_back(&&RomLine3303);
        main_exec_generated_fast_labels.push_back(&&RomLine3304);
        main_exec_generated_fast_labels.push_back(&&RomLine3305);
        main_exec_generated_fast_labels.push_back(&&RomLine3306);
        main_exec_generated_fast_labels.push_back(&&RomLine3307);
        main_exec_generated_fast_labels.push_back(&&RomLine3308);
        main_exec_generated_fast_labels.push_back(&&RomLine3309);
        main_exec_generated_fast_labels.push_back(&&RomLine3310);
        main_exec_generated_fast_labels.push_back(&&RomLine3311);
        main_exec_generated_fast_labels.push_back(&&RomLine3312);
        main_exec_generated_fast_labels.push_back(&&RomLine3313);
        main_exec_generated_fast_labels.push_back(&&RomLine3314);
        main_exec_generated_fast_labels.push_back(&&RomLine3315);
        main_exec_generated_fast_labels.push_back(&&RomLine3316);
        main_exec_generated_fast_labels.push_back(&&RomLine3317);
        main_exec_generated_fast_labels.push_back(&&RomLine3318);
        main_exec_generated_fast_labels.push_back(&&RomLine3319);
        main_exec_generated_fast_labels.push_back(&&RomLine3320);
        main_exec_generated_fast_labels.push_back(&&RomLine3321);
        main_exec_generated_fast_labels.push_back(&&RomLine3322);
        main_exec_generated_fast_labels.push_back(&&RomLine3323);
        main_exec_generated_fast_labels.push_back(&&RomLine3324);
        main_exec_generated_fast_labels.push_back(&&RomLine3325);
        main_exec_generated_fast_labels.push_back(&&RomLine3326);
        main_exec_generated_fast_labels.push_back(&&RomLine3327);
        main_exec_generated_fast_labels.push_back(&&RomLine3328);
        main_exec_generated_fast_labels.push_back(&&RomLine3329);
        main_exec_generated_fast_labels.push_back(&&RomLine3330);
        main_exec_generated_fast_labels.push_back(&&RomLine3331);
        main_exec_generated_fast_labels.push_back(&&RomLine3332);
        main_exec_generated_fast_labels.push_back(&&RomLine3333);
        main_exec_generated_fast_labels.push_back(&&RomLine3334);
        main_exec_generated_fast_labels.push_back(&&RomLine3335);
        main_exec_generated_fast_labels.push_back(&&RomLine3336);
        main_exec_generated_fast_labels.push_back(&&RomLine3337);
        main_exec_generated_fast_labels.push_back(&&RomLine3338);
        main_exec_generated_fast_labels.push_back(&&RomLine3339);
        main_exec_generated_fast_labels.push_back(&&RomLine3340);
        main_exec_generated_fast_labels.push_back(&&RomLine3341);
        main_exec_generated_fast_labels.push_back(&&RomLine3342);
        main_exec_generated_fast_labels.push_back(&&RomLine3343);
        main_exec_generated_fast_labels.push_back(&&RomLine3344);
        main_exec_generated_fast_labels.push_back(&&RomLine3345);
        main_exec_generated_fast_labels.push_back(&&RomLine3346);
        main_exec_generated_fast_labels.push_back(&&RomLine3347);
        main_exec_generated_fast_labels.push_back(&&RomLine3348);
        main_exec_generated_fast_labels.push_back(&&RomLine3349);
        main_exec_generated_fast_labels.push_back(&&RomLine3350);
        main_exec_generated_fast_labels.push_back(&&RomLine3351);
        main_exec_generated_fast_labels.push_back(&&RomLine3352);
        main_exec_generated_fast_labels.push_back(&&RomLine3353);
        main_exec_generated_fast_labels.push_back(&&RomLine3354);
        main_exec_generated_fast_labels.push_back(&&RomLine3355);
        main_exec_generated_fast_labels.push_back(&&RomLine3356);
        main_exec_generated_fast_labels.push_back(&&RomLine3357);
        main_exec_generated_fast_labels.push_back(&&RomLine3358);
        main_exec_generated_fast_labels.push_back(&&RomLine3359);
        main_exec_generated_fast_labels.push_back(&&RomLine3360);
        main_exec_generated_fast_labels.push_back(&&RomLine3361);
        main_exec_generated_fast_labels.push_back(&&RomLine3362);
        main_exec_generated_fast_labels.push_back(&&RomLine3363);
        main_exec_generated_fast_labels.push_back(&&RomLine3364);
        main_exec_generated_fast_labels.push_back(&&RomLine3365);
        main_exec_generated_fast_labels.push_back(&&RomLine3366);
        main_exec_generated_fast_labels.push_back(&&RomLine3367);
        main_exec_generated_fast_labels.push_back(&&RomLine3368);
        main_exec_generated_fast_labels.push_back(&&RomLine3369);
        main_exec_generated_fast_labels.push_back(&&RomLine3370);
        main_exec_generated_fast_labels.push_back(&&RomLine3371);
        main_exec_generated_fast_labels.push_back(&&RomLine3372);
        main_exec_generated_fast_labels.push_back(&&RomLine3373);
        main_exec_generated_fast_labels.push_back(&&RomLine3374);
        main_exec_generated_fast_labels.push_back(&&RomLine3375);
        main_exec_generated_fast_labels.push_back(&&RomLine3376);
        main_exec_generated_fast_labels.push_back(&&RomLine3377);
        main_exec_generated_fast_labels.push_back(&&RomLine3378);
        main_exec_generated_fast_labels.push_back(&&RomLine3379);
        main_exec_generated_fast_labels.push_back(&&RomLine3380);
        main_exec_generated_fast_labels.push_back(&&RomLine3381);
        main_exec_generated_fast_labels.push_back(&&RomLine3382);
        main_exec_generated_fast_labels.push_back(&&RomLine3383);
        main_exec_generated_fast_labels.push_back(&&RomLine3384);
        main_exec_generated_fast_labels.push_back(&&RomLine3385);
        main_exec_generated_fast_labels.push_back(&&RomLine3386);
        main_exec_generated_fast_labels.push_back(&&RomLine3387);
        main_exec_generated_fast_labels.push_back(&&RomLine3388);
        main_exec_generated_fast_labels.push_back(&&RomLine3389);
        main_exec_generated_fast_labels.push_back(&&RomLine3390);
        main_exec_generated_fast_labels.push_back(&&RomLine3391);
        main_exec_generated_fast_labels.push_back(&&RomLine3392);
        main_exec_generated_fast_labels.push_back(&&RomLine3393);
        main_exec_generated_fast_labels.push_back(&&RomLine3394);
        main_exec_generated_fast_labels.push_back(&&RomLine3395);
        main_exec_generated_fast_labels.push_back(&&RomLine3396);
        main_exec_generated_fast_labels.push_back(&&RomLine3397);
        main_exec_generated_fast_labels.push_back(&&RomLine3398);
        main_exec_generated_fast_labels.push_back(&&RomLine3399);
        main_exec_generated_fast_labels.push_back(&&RomLine3400);
        main_exec_generated_fast_labels.push_back(&&RomLine3401);
        main_exec_generated_fast_labels.push_back(&&RomLine3402);
        main_exec_generated_fast_labels.push_back(&&RomLine3403);
        main_exec_generated_fast_labels.push_back(&&RomLine3404);
        main_exec_generated_fast_labels.push_back(&&RomLine3405);
        main_exec_generated_fast_labels.push_back(&&RomLine3406);
        main_exec_generated_fast_labels.push_back(&&RomLine3407);
        main_exec_generated_fast_labels.push_back(&&RomLine3408);
        main_exec_generated_fast_labels.push_back(&&RomLine3409);
        main_exec_generated_fast_labels.push_back(&&RomLine3410);
        main_exec_generated_fast_labels.push_back(&&RomLine3411);
        main_exec_generated_fast_labels.push_back(&&RomLine3412);
        main_exec_generated_fast_labels.push_back(&&RomLine3413);
        main_exec_generated_fast_labels.push_back(&&RomLine3414);
        main_exec_generated_fast_labels.push_back(&&RomLine3415);
        main_exec_generated_fast_labels.push_back(&&RomLine3416);
        main_exec_generated_fast_labels.push_back(&&RomLine3417);
        main_exec_generated_fast_labels.push_back(&&RomLine3418);
        main_exec_generated_fast_labels.push_back(&&RomLine3419);
        main_exec_generated_fast_labels.push_back(&&RomLine3420);
        main_exec_generated_fast_labels.push_back(&&RomLine3421);
        main_exec_generated_fast_labels.push_back(&&RomLine3422);
        main_exec_generated_fast_labels.push_back(&&RomLine3423);
        main_exec_generated_fast_labels.push_back(&&RomLine3424);
        main_exec_generated_fast_labels.push_back(&&RomLine3425);
        main_exec_generated_fast_labels.push_back(&&RomLine3426);
        main_exec_generated_fast_labels.push_back(&&RomLine3427);
        main_exec_generated_fast_labels.push_back(&&RomLine3428);
        main_exec_generated_fast_labels.push_back(&&RomLine3429);
        main_exec_generated_fast_labels.push_back(&&RomLine3430);
        main_exec_generated_fast_labels.push_back(&&RomLine3431);
        main_exec_generated_fast_labels.push_back(&&RomLine3432);
        main_exec_generated_fast_labels.push_back(&&RomLine3433);
        main_exec_generated_fast_labels.push_back(&&RomLine3434);
        main_exec_generated_fast_labels.push_back(&&RomLine3435);
        main_exec_generated_fast_labels.push_back(&&RomLine3436);
        main_exec_generated_fast_labels.push_back(&&RomLine3437);
        main_exec_generated_fast_labels.push_back(&&RomLine3438);
        main_exec_generated_fast_labels.push_back(&&RomLine3439);
        main_exec_generated_fast_labels.push_back(&&RomLine3440);
        main_exec_generated_fast_labels.push_back(&&RomLine3441);
        main_exec_generated_fast_labels.push_back(&&RomLine3442);
        main_exec_generated_fast_labels.push_back(&&RomLine3443);
        main_exec_generated_fast_labels.push_back(&&RomLine3444);
        main_exec_generated_fast_labels.push_back(&&RomLine3445);
        main_exec_generated_fast_labels.push_back(&&RomLine3446);
        main_exec_generated_fast_labels.push_back(&&RomLine3447);
        main_exec_generated_fast_labels.push_back(&&RomLine3448);
        main_exec_generated_fast_labels.push_back(&&RomLine3449);
        main_exec_generated_fast_labels.push_back(&&RomLine3450);
        main_exec_generated_fast_labels.push_back(&&RomLine3451);
        main_exec_generated_fast_labels.push_back(&&RomLine3452);
        main_exec_generated_fast_labels.push_back(&&RomLine3453);
        main_exec_generated_fast_labels.push_back(&&RomLine3454);
        main_exec_generated_fast_labels.push_back(&&RomLine3455);
        main_exec_generated_fast_labels.push_back(&&RomLine3456);
        main_exec_generated_fast_labels.push_back(&&RomLine3457);
        main_exec_generated_fast_labels.push_back(&&RomLine3458);
        main_exec_generated_fast_labels.push_back(&&RomLine3459);
        main_exec_generated_fast_labels.push_back(&&RomLine3460);
        main_exec_generated_fast_labels.push_back(&&RomLine3461);
        main_exec_generated_fast_labels.push_back(&&RomLine3462);
        main_exec_generated_fast_labels.push_back(&&RomLine3463);
        main_exec_generated_fast_labels.push_back(&&RomLine3464);
        main_exec_generated_fast_labels.push_back(&&RomLine3465);
        main_exec_generated_fast_labels.push_back(&&RomLine3466);
        main_exec_generated_fast_labels.push_back(&&RomLine3467);
        main_exec_generated_fast_labels.push_back(&&RomLine3468);
        main_exec_generated_fast_labels.push_back(&&RomLine3469);
        main_exec_generated_fast_labels.push_back(&&RomLine3470);
        main_exec_generated_fast_labels.push_back(&&RomLine3471);
        main_exec_generated_fast_labels.push_back(&&RomLine3472);
        main_exec_generated_fast_labels.push_back(&&RomLine3473);
        main_exec_generated_fast_labels.push_back(&&RomLine3474);
        main_exec_generated_fast_labels.push_back(&&RomLine3475);
        main_exec_generated_fast_labels.push_back(&&RomLine3476);
        main_exec_generated_fast_labels.push_back(&&RomLine3477);
        main_exec_generated_fast_labels.push_back(&&RomLine3478);
        main_exec_generated_fast_labels.push_back(&&RomLine3479);
        main_exec_generated_fast_labels.push_back(&&RomLine3480);
        main_exec_generated_fast_labels.push_back(&&RomLine3481);
        main_exec_generated_fast_labels.push_back(&&RomLine3482);
        main_exec_generated_fast_labels.push_back(&&RomLine3483);
        main_exec_generated_fast_labels.push_back(&&RomLine3484);
        main_exec_generated_fast_labels.push_back(&&RomLine3485);
        main_exec_generated_fast_labels.push_back(&&RomLine3486);
        main_exec_generated_fast_labels.push_back(&&RomLine3487);
        main_exec_generated_fast_labels.push_back(&&RomLine3488);
        main_exec_generated_fast_labels.push_back(&&RomLine3489);
        main_exec_generated_fast_labels.push_back(&&RomLine3490);
        main_exec_generated_fast_labels.push_back(&&RomLine3491);
        main_exec_generated_fast_labels.push_back(&&RomLine3492);
        main_exec_generated_fast_labels.push_back(&&RomLine3493);
        main_exec_generated_fast_labels.push_back(&&RomLine3494);
        main_exec_generated_fast_labels.push_back(&&RomLine3495);
        main_exec_generated_fast_labels.push_back(&&RomLine3496);
        main_exec_generated_fast_labels.push_back(&&RomLine3497);
        main_exec_generated_fast_labels.push_back(&&RomLine3498);
        main_exec_generated_fast_labels.push_back(&&RomLine3499);
        main_exec_generated_fast_labels.push_back(&&RomLine3500);
        main_exec_generated_fast_labels.push_back(&&RomLine3501);
        main_exec_generated_fast_labels.push_back(&&RomLine3502);
        main_exec_generated_fast_labels.push_back(&&RomLine3503);
        main_exec_generated_fast_labels.push_back(&&RomLine3504);
        main_exec_generated_fast_labels.push_back(&&RomLine3505);
        main_exec_generated_fast_labels.push_back(&&RomLine3506);
        main_exec_generated_fast_labels.push_back(&&RomLine3507);
        main_exec_generated_fast_labels.push_back(&&RomLine3508);
        main_exec_generated_fast_labels.push_back(&&RomLine3509);
        main_exec_generated_fast_labels.push_back(&&RomLine3510);
        main_exec_generated_fast_labels.push_back(&&RomLine3511);
        main_exec_generated_fast_labels.push_back(&&RomLine3512);
        main_exec_generated_fast_labels.push_back(&&RomLine3513);
        main_exec_generated_fast_labels.push_back(&&RomLine3514);
        main_exec_generated_fast_labels.push_back(&&RomLine3515);
        main_exec_generated_fast_labels.push_back(&&RomLine3516);
        main_exec_generated_fast_labels.push_back(&&RomLine3517);
        main_exec_generated_fast_labels.push_back(&&RomLine3518);
        main_exec_generated_fast_labels.push_back(&&RomLine3519);
        main_exec_generated_fast_labels.push_back(&&RomLine3520);
        main_exec_generated_fast_labels.push_back(&&RomLine3521);
        main_exec_generated_fast_labels.push_back(&&RomLine3522);
        main_exec_generated_fast_labels.push_back(&&RomLine3523);
        main_exec_generated_fast_labels.push_back(&&RomLine3524);
        main_exec_generated_fast_labels.push_back(&&RomLine3525);
        main_exec_generated_fast_labels.push_back(&&RomLine3526);
        main_exec_generated_fast_labels.push_back(&&RomLine3527);
        main_exec_generated_fast_labels.push_back(&&RomLine3528);
        main_exec_generated_fast_labels.push_back(&&RomLine3529);
        main_exec_generated_fast_labels.push_back(&&RomLine3530);
        main_exec_generated_fast_labels.push_back(&&RomLine3531);
        main_exec_generated_fast_labels.push_back(&&RomLine3532);
        main_exec_generated_fast_labels.push_back(&&RomLine3533);
        main_exec_generated_fast_labels.push_back(&&RomLine3534);
        main_exec_generated_fast_labels.push_back(&&RomLine3535);
        main_exec_generated_fast_labels.push_back(&&RomLine3536);
        main_exec_generated_fast_labels.push_back(&&RomLine3537);
        main_exec_generated_fast_labels.push_back(&&RomLine3538);
        main_exec_generated_fast_labels.push_back(&&RomLine3539);
        main_exec_generated_fast_labels.push_back(&&RomLine3540);
        main_exec_generated_fast_labels.push_back(&&RomLine3541);
        main_exec_generated_fast_labels.push_back(&&RomLine3542);
        main_exec_generated_fast_labels.push_back(&&RomLine3543);
        main_exec_generated_fast_labels.push_back(&&RomLine3544);
        main_exec_generated_fast_labels.push_back(&&RomLine3545);
        main_exec_generated_fast_labels.push_back(&&RomLine3546);
        main_exec_generated_fast_labels.push_back(&&RomLine3547);
        main_exec_generated_fast_labels.push_back(&&RomLine3548);
        main_exec_generated_fast_labels.push_back(&&RomLine3549);
        main_exec_generated_fast_labels.push_back(&&RomLine3550);
        main_exec_generated_fast_labels.push_back(&&RomLine3551);
        main_exec_generated_fast_labels.push_back(&&RomLine3552);
        main_exec_generated_fast_labels.push_back(&&RomLine3553);
        main_exec_generated_fast_labels.push_back(&&RomLine3554);
    }

RomLine0: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSTEP*STEP, where inSTEP=1
    op0 = i;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 2 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine4: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 4 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine5: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine6: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 6 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine7: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine8: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine9: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine10: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 10 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine11: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 11 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine12: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 12 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine13: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 13 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine14: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(8))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 14 << endl;
        exit(-1);
    }
    addrRel += 8;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine15: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 15 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine16: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 16 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine17: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 17 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine18: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 18 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine19: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine20: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 20 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine21: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 21 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine22: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine23: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 23 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine24: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine25: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine26: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine27: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine28: //        ${eventLog(onStartBatch, C)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine29: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine30: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine31: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 31 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine32: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine33: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine34: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 34 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine35: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 35 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine36: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine37: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 37 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine38: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine39: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine40: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine41: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine42: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine43: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine44: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 44 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine45: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine46: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 46 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine47: //        0                                   :MSTORE(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 47 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine48: //        E                                   :MSTORE(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 48 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine49: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 49 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine50: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 50 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine51: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 51 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine52: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 52 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine53: //        A+1 => CTX      :MSTORE(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 53 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine54: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 54 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine55: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 55 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine56: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(107))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 56 << endl;
        exit(-1);
    }
    addrRel += 107;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine57: //                        :JMP(endCheckRLP)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(58))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 57 << endl;
        exit(-1);
    }
    addrRel += 58;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine58: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(59))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 58 << endl;
        exit(-1);
    }
    addrRel += 59;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine59: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 59 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine60: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 60 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine61: //        A               :JMPN(processTxsEnd)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(67))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 61 << endl;
        exit(-1);
    }
    addrRel += 67;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine62: //        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 62 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine63: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 63 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine64: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(844))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 64 << endl;
        exit(-1);
    }
    addrRel += 844;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine65: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine66: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(59))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 66 << endl;
        exit(-1);
    }
    addrRel += 59;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine67: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine68: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine69: //        %LOCAL_EXIT_ROOT_STORAGE_POS => C                         ; Storage position of the local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine70: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine71: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 71 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 71 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine72: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 72 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine73: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 73 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 73 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine74: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine75: //        $ => E                          :MLOAD(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 75 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine76: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine77: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 77 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine78: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine79: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine80: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 80 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine81: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine82: //        20 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine83: //        $ => A                          :MLOAD(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 83 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine84: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine85: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine86: //        $ => A                          :MLOAD(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(8))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 86 << endl;
        exit(-1);
    }
    addrRel += 8;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine87: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine88: //        $ => A                          :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 88 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine89: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine90: //        HASHPOS                         :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine91: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 91 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine92: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 92 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine93: //        $ => HASHPOS                    :MLOAD(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 93 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine94: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine95: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine96: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 96 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine97: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine98: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 98 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine99: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine100: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine101: //        $ => A                          :MLOAD(globalHash)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine102: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 102 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine103: //        ${eventLog(onFinishBatch)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine104: //        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op
    SP = fe2n(fr, op0); // If setSP, SP'=op
    PC = fe2n(fr, op0); // If setPC, PC'=op
    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine105: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(105))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 105 << endl;
        exit(-1);
    }
    addrRel += 105;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine106: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine107: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine108: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 108 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine109: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 109 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine110: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine111: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine112: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 113;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 112 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine113: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 114;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 113 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine114: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(192));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 114 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine115: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(248));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(120))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 115 << endl;
        exit(-1);
    }
    addrRel += 120;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine116: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(247));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine117: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 118;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 117 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine118: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 119;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 118 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine119: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(121))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 119 << endl;
        exit(-1);
    }
    addrRel += 121;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine120: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(192));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine121: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 121 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine122: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine123: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 124;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 123 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine124: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 125;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 124 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine125: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 125 << endl;
        exit(-1);
    }
    addrRel += 136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine126: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(129))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 126 << endl;
        exit(-1);
    }
    addrRel += 129;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine127: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(137));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(132))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 127 << endl;
        exit(-1);
    }
    addrRel += 132;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine128: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 128 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine129: //        ${eventLog(onStartBatch, C)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 129 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine130: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine131: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 131 << endl;
        exit(-1);
    }
    addrRel += 136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine132: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine133: //        

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 133 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine134: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 135;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 134 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine135: //;; Set global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 136;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 135 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine136: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 136 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine137: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine138: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 139;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 138 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine139: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 140;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 139 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine140: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(150))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 140 << endl;
        exit(-1);
    }
    addrRel += 150;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine141: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(144))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 141 << endl;
        exit(-1);
    }
    addrRel += 144;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine142: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(161));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 142 << endl;
        exit(-1);
    }
    addrRel += 146;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine143: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 143 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine144: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine145: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(150))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 145 << endl;
        exit(-1);
    }
    addrRel += 150;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine146: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine147: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(150))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 147 << endl;
        exit(-1);
    }
    addrRel += 150;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine148: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 149;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 148 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine149: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 150;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 149 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine150: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 150 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine151: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine152: //endCheckRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 153;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 152 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine153: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 154;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 153 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine154: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(163))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 154 << endl;
        exit(-1);
    }
    addrRel += 163;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine155: //txLoop:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(158))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 155 << endl;
        exit(-1);
    }
    addrRel += 158;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine156: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(161));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(159))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 156 << endl;
        exit(-1);
    }
    addrRel += 159;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine157: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 157 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine158: //        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(163))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 158 << endl;
        exit(-1);
    }
    addrRel += 163;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine159: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine160: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(163))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 160 << endl;
        exit(-1);
    }
    addrRel += 163;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine161: //processTxEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 162;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 161 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine162: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 163;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 162 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine163: //processTxsEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine164: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine165: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 166;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 165 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine166: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 167;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 166 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine167: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 167 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine168: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(172))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 168 << endl;
        exit(-1);
    }
    addrRel += 172;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine169: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(148));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 169 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine170: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(149));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(174))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 170 << endl;
        exit(-1);
    }
    addrRel += 174;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine171: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 171 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine172: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 172 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine173: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(179))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 173 << endl;
        exit(-1);
    }
    addrRel += 179;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine174: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine175: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 176;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 175 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine176: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 177;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 176 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine177: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 177 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine178: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 178 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine179: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine180: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 181;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 180 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine181: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 182;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 181 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine182: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 182 << endl;
        exit(-1);
    }
    addrRel += 192;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine183: //; Check Global Hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(186))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 183 << endl;
        exit(-1);
    }
    addrRel += 186;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine184: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(161));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(188))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 184 << endl;
        exit(-1);
    }
    addrRel += 188;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine185: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 185 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine186: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine187: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 187 << endl;
        exit(-1);
    }
    addrRel += 192;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine188: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine189: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 189 << endl;
        exit(-1);
    }
    addrRel += 192;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine190: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 191;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 190 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine191: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 192;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 191 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine192: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 192 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine193: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine194: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine195: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 196;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 195 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine196: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 197;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 196 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine197: //INCLUDE "process_tx.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(202))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 197 << endl;
        exit(-1);
    }
    addrRel += 202;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine198: //INCLUDE "opcodes.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 198 << endl;
        exit(-1);
    }
    addrRel += 228;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine199: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(184));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(207))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 199 << endl;
        exit(-1);
    }
    addrRel += 207;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine200: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(192));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 200 << endl;
        exit(-1);
    }
    addrRel += 209;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine201: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 201 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine202: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 202 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine203: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 31;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine204: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 205;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 204 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine205: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine206: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 206 << endl;
        exit(-1);
    }
    addrRel += 228;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine207: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 207 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine208: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(213))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 208 << endl;
        exit(-1);
    }
    addrRel += 213;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine209: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(183));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine210: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 211;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 210 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine211: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 212;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 211 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine212: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 212 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine213: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine214: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(221))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 214 << endl;
        exit(-1);
    }
    addrRel += 221;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine215: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 215 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine216: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 217;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 216 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine217: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 218;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 217 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine218: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine219: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 219 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine220: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(213))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 220 << endl;
        exit(-1);
    }
    addrRel += 213;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine221: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 221 << endl;
        exit(-1);
    }
    addrRel += 228;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine222: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine223: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 224;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 223 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine224: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 225;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 224 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine225: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine226: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 227;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 226 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine227: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine228: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine229: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 230;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 229 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine230: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 231;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 230 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine231: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(241))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 231 << endl;
        exit(-1);
    }
    addrRel += 241;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine232: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(235))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 232 << endl;
        exit(-1);
    }
    addrRel += 235;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine233: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(137));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(237))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 233 << endl;
        exit(-1);
    }
    addrRel += 237;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine234: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 234 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine235: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine236: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(241))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 236 << endl;
        exit(-1);
    }
    addrRel += 241;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine237: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine238: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(241))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 238 << endl;
        exit(-1);
    }
    addrRel += 241;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine239: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 240;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 239 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine240: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 241;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 240 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine241: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(11))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 241 << endl;
        exit(-1);
    }
    addrRel += 11;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine242: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine243: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 244;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(286))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 243 << endl;
        exit(-1);
    }
    addrRel += 286;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine244: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 245;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 244 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine245: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32896;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine246: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(248))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 246 << endl;
        exit(-1);
    }
    addrRel += 248;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine247: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 247 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine248: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine249: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 249 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine250: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 250 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine251: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 251 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine252: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine253: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine254: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(281))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 254 << endl;
        exit(-1);
    }
    addrRel += 281;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine255: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 255 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine256: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine257: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 258;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 257 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine258: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine259: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 260;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(281))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 259 << endl;
        exit(-1);
    }
    addrRel += 281;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine260: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 260 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine261: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine262: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 263;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 262 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine263: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine264: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 265;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(281))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 264 << endl;
        exit(-1);
    }
    addrRel += 281;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine265: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 265 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine266: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine267: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 268;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(274))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 267 << endl;
        exit(-1);
    }
    addrRel += 274;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine268: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 268 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine269: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 269 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine270: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 270 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine271: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 271 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine272: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 272 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine273: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(52))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 273 << endl;
        exit(-1);
    }
    addrRel += 52;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine274: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 274 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine275: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 275 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine276: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine277: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 277 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine278: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine279: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 279 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine280: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine281: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 281 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine282: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 282 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine283: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 283 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine284: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine285: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine286: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 286 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine287: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 287 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine288: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 288 << endl;
        exit(-1);
    }
    addrRel += 293;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine289: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine290: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine291: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine292: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine293: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 293 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine294: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 294 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine295: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 295 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine296: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 296 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine297: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(303))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 297 << endl;
        exit(-1);
    }
    addrRel += 303;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine298: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine299: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine300: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine301: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine302: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(297))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 302 << endl;
        exit(-1);
    }
    addrRel += 297;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine303: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine304: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 304 << endl;
        exit(-1);
    }
    addrRel += 308;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine305: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine306: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine307: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine308: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 308 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine309: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(67))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 309 << endl;
        exit(-1);
    }
    addrRel += 67;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine310: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1595))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 310 << endl;
        exit(-1);
    }
    addrRel += 1595;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine311: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1608))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 311 << endl;
        exit(-1);
    }
    addrRel += 1608;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine312: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1620))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 312 << endl;
        exit(-1);
    }
    addrRel += 1620;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine313: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1632))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 313 << endl;
        exit(-1);
    }
    addrRel += 1632;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine314: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1644))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 314 << endl;
        exit(-1);
    }
    addrRel += 1644;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine315: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1656))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 315 << endl;
        exit(-1);
    }
    addrRel += 1656;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine316: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1689))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 316 << endl;
        exit(-1);
    }
    addrRel += 1689;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine317: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1701))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 317 << endl;
        exit(-1);
    }
    addrRel += 1701;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine318: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1734))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 318 << endl;
        exit(-1);
    }
    addrRel += 1734;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine319: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1751))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 319 << endl;
        exit(-1);
    }
    addrRel += 1751;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine320: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1768))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 320 << endl;
        exit(-1);
    }
    addrRel += 1768;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine321: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1778))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 321 << endl;
        exit(-1);
    }
    addrRel += 1778;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine322: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 322 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine323: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 323 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine324: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 324 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine325: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 325 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine326: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1823))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 326 << endl;
        exit(-1);
    }
    addrRel += 1823;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine327: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1839))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 327 << endl;
        exit(-1);
    }
    addrRel += 1839;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine328: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1815))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 328 << endl;
        exit(-1);
    }
    addrRel += 1815;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine329: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1831))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 329 << endl;
        exit(-1);
    }
    addrRel += 1831;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine330: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1847))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 330 << endl;
        exit(-1);
    }
    addrRel += 1847;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine331: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1855))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 331 << endl;
        exit(-1);
    }
    addrRel += 1855;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine332: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1862))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 332 << endl;
        exit(-1);
    }
    addrRel += 1862;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine333: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1870))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 333 << endl;
        exit(-1);
    }
    addrRel += 1870;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine334: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1878))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 334 << endl;
        exit(-1);
    }
    addrRel += 1878;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine335: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1886))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 335 << endl;
        exit(-1);
    }
    addrRel += 1886;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine336: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1893))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 336 << endl;
        exit(-1);
    }
    addrRel += 1893;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine337: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1913))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 337 << endl;
        exit(-1);
    }
    addrRel += 1913;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine338: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1904))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 338 << endl;
        exit(-1);
    }
    addrRel += 1904;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine339: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1922))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 339 << endl;
        exit(-1);
    }
    addrRel += 1922;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine340: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 340 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine341: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 341 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine342: //;; Set batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1954))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 342 << endl;
        exit(-1);
    }
    addrRel += 1954;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine343: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 343 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine344: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 344 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine345: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 345 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine346: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 346 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine347: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 347 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine348: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 348 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine349: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 349 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine350: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 350 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine351: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 351 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine352: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 352 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine353: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 353 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine354: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 354 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine355: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 355 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine356: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 356 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine357: //        ${eventLog(onStartBatch, C)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 357 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine358: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1998))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 358 << endl;
        exit(-1);
    }
    addrRel += 1998;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine359: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2007))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 359 << endl;
        exit(-1);
    }
    addrRel += 2007;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine360: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2016))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 360 << endl;
        exit(-1);
    }
    addrRel += 2016;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine361: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2021))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 361 << endl;
        exit(-1);
    }
    addrRel += 2021;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine362: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2026))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 362 << endl;
        exit(-1);
    }
    addrRel += 2026;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine363: //        

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2031))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 363 << endl;
        exit(-1);
    }
    addrRel += 2031;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine364: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2061))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 364 << endl;
        exit(-1);
    }
    addrRel += 2061;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine365: //;; Set global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2066))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 365 << endl;
        exit(-1);
    }
    addrRel += 2066;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine366: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2129))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 366 << endl;
        exit(-1);
    }
    addrRel += 2129;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine367: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2145))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 367 << endl;
        exit(-1);
    }
    addrRel += 2145;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine368: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2176))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 368 << endl;
        exit(-1);
    }
    addrRel += 2176;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine369: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2181))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 369 << endl;
        exit(-1);
    }
    addrRel += 2181;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine370: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 370 << endl;
        exit(-1);
    }
    addrRel += 2192;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine371: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2222))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 371 << endl;
        exit(-1);
    }
    addrRel += 2222;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine372: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 372 << endl;
        exit(-1);
    }
    addrRel += 2227;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine373: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2267))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 373 << endl;
        exit(-1);
    }
    addrRel += 2267;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine374: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2293))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 374 << endl;
        exit(-1);
    }
    addrRel += 2293;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine375: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2315))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 375 << endl;
        exit(-1);
    }
    addrRel += 2315;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine376: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2320))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 376 << endl;
        exit(-1);
    }
    addrRel += 2320;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine377: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2325))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 377 << endl;
        exit(-1);
    }
    addrRel += 2325;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine378: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2330))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 378 << endl;
        exit(-1);
    }
    addrRel += 2330;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine379: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2335))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 379 << endl;
        exit(-1);
    }
    addrRel += 2335;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine380: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 380 << endl;
        exit(-1);
    }
    addrRel += 2340;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine381: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2345))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 381 << endl;
        exit(-1);
    }
    addrRel += 2345;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine382: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 382 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine383: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 383 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine384: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 384 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine385: //;; Prepare transaction loop

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 385 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine386: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 386 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine387: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 387 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine388: //        0                                   :MSTORE(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 388 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine389: //        E                                   :MSTORE(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 389 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine390: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2352))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 390 << endl;
        exit(-1);
    }
    addrRel += 2352;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine391: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2355))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 391 << endl;
        exit(-1);
    }
    addrRel += 2355;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine392: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2364))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 392 << endl;
        exit(-1);
    }
    addrRel += 2364;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine393: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2376))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 393 << endl;
        exit(-1);
    }
    addrRel += 2376;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine394: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2389))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 394 << endl;
        exit(-1);
    }
    addrRel += 2389;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine395: //        $${var p = 0}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2399))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 395 << endl;
        exit(-1);
    }
    addrRel += 2399;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine396: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2486))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 396 << endl;
        exit(-1);
    }
    addrRel += 2486;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine397: //txLoopRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2491))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 397 << endl;
        exit(-1);
    }
    addrRel += 2491;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine398: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2501))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 398 << endl;
        exit(-1);
    }
    addrRel += 2501;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine399: //        A+1 => CTX      :MSTORE(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2505))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 399 << endl;
        exit(-1);
    }
    addrRel += 2505;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine400: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2510))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 400 << endl;
        exit(-1);
    }
    addrRel += 2510;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine401: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2514))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 401 << endl;
        exit(-1);
    }
    addrRel += 2514;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine402: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 402 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine403: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 403 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine404: //                        :JMP(endCheckRLP)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 404 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine405: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 405 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine406: //endCheckRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2554))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 406 << endl;
        exit(-1);
    }
    addrRel += 2554;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine407: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2558))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 407 << endl;
        exit(-1);
    }
    addrRel += 2558;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine408: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2562))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 408 << endl;
        exit(-1);
    }
    addrRel += 2562;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine409: //txLoop:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2566))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 409 << endl;
        exit(-1);
    }
    addrRel += 2566;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine410: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 410 << endl;
        exit(-1);
    }
    addrRel += 2570;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine411: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2574))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 411 << endl;
        exit(-1);
    }
    addrRel += 2574;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine412: //        A               :JMPN(processTxsEnd)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2578))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 412 << endl;
        exit(-1);
    }
    addrRel += 2578;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine413: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 413 << endl;
        exit(-1);
    }
    addrRel += 2582;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine414: //        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2586))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 414 << endl;
        exit(-1);
    }
    addrRel += 2586;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine415: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2590))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 415 << endl;
        exit(-1);
    }
    addrRel += 2590;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine416: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2594))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 416 << endl;
        exit(-1);
    }
    addrRel += 2594;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine417: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2598))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 417 << endl;
        exit(-1);
    }
    addrRel += 2598;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine418: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2602))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 418 << endl;
        exit(-1);
    }
    addrRel += 2602;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine419: //processTxEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2606))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 419 << endl;
        exit(-1);
    }
    addrRel += 2606;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine420: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2610))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 420 << endl;
        exit(-1);
    }
    addrRel += 2610;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine421: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2614))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 421 << endl;
        exit(-1);
    }
    addrRel += 2614;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine422: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2618))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 422 << endl;
        exit(-1);
    }
    addrRel += 2618;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine423: //processTxsEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2622))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 423 << endl;
        exit(-1);
    }
    addrRel += 2622;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine424: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2626))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 424 << endl;
        exit(-1);
    }
    addrRel += 2626;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine425: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2630))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 425 << endl;
        exit(-1);
    }
    addrRel += 2630;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine426: //;; Assert local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2634))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 426 << endl;
        exit(-1);
    }
    addrRel += 2634;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine427: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2638))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 427 << endl;
        exit(-1);
    }
    addrRel += 2638;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine428: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2642))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 428 << endl;
        exit(-1);
    }
    addrRel += 2642;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine429: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2646))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 429 << endl;
        exit(-1);
    }
    addrRel += 2646;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine430: //        %LOCAL_EXIT_ROOT_STORAGE_POS => C                         ; Storage position of the local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2650))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 430 << endl;
        exit(-1);
    }
    addrRel += 2650;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine431: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2654))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 431 << endl;
        exit(-1);
    }
    addrRel += 2654;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine432: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2658))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 432 << endl;
        exit(-1);
    }
    addrRel += 2658;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine433: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2662))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 433 << endl;
        exit(-1);
    }
    addrRel += 2662;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine434: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2666))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 434 << endl;
        exit(-1);
    }
    addrRel += 2666;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine435: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2670))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 435 << endl;
        exit(-1);
    }
    addrRel += 2670;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine436: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2674))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 436 << endl;
        exit(-1);
    }
    addrRel += 2674;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine437: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2678))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 437 << endl;
        exit(-1);
    }
    addrRel += 2678;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine438: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2682))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 438 << endl;
        exit(-1);
    }
    addrRel += 2682;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine439: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2689))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 439 << endl;
        exit(-1);
    }
    addrRel += 2689;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine440: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2696))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 440 << endl;
        exit(-1);
    }
    addrRel += 2696;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine441: //;; Check batchHashData

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2703))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 441 << endl;
        exit(-1);
    }
    addrRel += 2703;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine442: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2710))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 442 << endl;
        exit(-1);
    }
    addrRel += 2710;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine443: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2717))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 443 << endl;
        exit(-1);
    }
    addrRel += 2717;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine444: //        $ => E                          :MLOAD(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2724))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 444 << endl;
        exit(-1);
    }
    addrRel += 2724;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine445: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2731))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 445 << endl;
        exit(-1);
    }
    addrRel += 2731;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine446: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2738))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 446 << endl;
        exit(-1);
    }
    addrRel += 2738;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine447: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2745))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 447 << endl;
        exit(-1);
    }
    addrRel += 2745;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine448: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2752))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 448 << endl;
        exit(-1);
    }
    addrRel += 2752;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine449: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2759))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 449 << endl;
        exit(-1);
    }
    addrRel += 2759;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine450: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2766))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 450 << endl;
        exit(-1);
    }
    addrRel += 2766;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine451: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2773))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 451 << endl;
        exit(-1);
    }
    addrRel += 2773;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine452: //        20 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2780))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 452 << endl;
        exit(-1);
    }
    addrRel += 2780;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine453: //        $ => A                          :MLOAD(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2787))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 453 << endl;
        exit(-1);
    }
    addrRel += 2787;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine454: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2794))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 454 << endl;
        exit(-1);
    }
    addrRel += 2794;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine455: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2804))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 455 << endl;
        exit(-1);
    }
    addrRel += 2804;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine456: //        $ => A                          :MLOAD(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2815))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 456 << endl;
        exit(-1);
    }
    addrRel += 2815;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine457: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2826))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 457 << endl;
        exit(-1);
    }
    addrRel += 2826;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine458: //        $ => A                          :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2837))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 458 << endl;
        exit(-1);
    }
    addrRel += 2837;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine459: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2848))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 459 << endl;
        exit(-1);
    }
    addrRel += 2848;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine460: //        HASHPOS                         :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2859))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 460 << endl;
        exit(-1);
    }
    addrRel += 2859;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine461: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2870))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 461 << endl;
        exit(-1);
    }
    addrRel += 2870;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine462: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2881))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 462 << endl;
        exit(-1);
    }
    addrRel += 2881;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine463: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2892))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 463 << endl;
        exit(-1);
    }
    addrRel += 2892;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine464: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2903))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 464 << endl;
        exit(-1);
    }
    addrRel += 2903;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine465: //; Check Global Hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2914))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 465 << endl;
        exit(-1);
    }
    addrRel += 2914;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine466: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 466 << endl;
        exit(-1);
    }
    addrRel += 2925;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine467: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2936))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 467 << endl;
        exit(-1);
    }
    addrRel += 2936;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine468: //        ; Get position of the previous hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2947))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 468 << endl;
        exit(-1);
    }
    addrRel += 2947;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine469: //        $ => HASHPOS                    :MLOAD(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2958))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 469 << endl;
        exit(-1);
    }
    addrRel += 2958;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine470: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2969))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 470 << endl;
        exit(-1);
    }
    addrRel += 2969;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine471: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2982))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 471 << endl;
        exit(-1);
    }
    addrRel += 2982;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine472: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2995))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 472 << endl;
        exit(-1);
    }
    addrRel += 2995;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine473: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3008))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 473 << endl;
        exit(-1);
    }
    addrRel += 3008;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine474: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3021))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 474 << endl;
        exit(-1);
    }
    addrRel += 3021;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine475: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 475 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine476: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 476 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine477: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 477 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine478: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 478 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine479: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 479 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine480: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 480 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine481: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 481 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine482: //        $ => A                          :MLOAD(globalHash)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 482 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine483: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 483 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine484: //        ${eventLog(onFinishBatch)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 484 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine485: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 485 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine486: //        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 486 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine487: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 487 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine488: //finalWait:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 488 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine489: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 489 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine490: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 490 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine491: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 491 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine492: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 492 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine493: //INCLUDE "process_tx.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 493 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine494: //INCLUDE "opcodes.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 494 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine495: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 495 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine496: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 496 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine497: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 497 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine498: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 498 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine499: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 499 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine500: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 500 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine501: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 501 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine502: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 502 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine503: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 503 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine504: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 504 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine505: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 505 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine506: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 506 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine507: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 507 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine508: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 508 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine509: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 509 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine510: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 510 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine511: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 511 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine512: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 512 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine513: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 513 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine514: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 514 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine515: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 515 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine516: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 516 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine517: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 517 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine518: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 518 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine519: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 519 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine520: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 520 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine521: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 521 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine522: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 522 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine523: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 523 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine524: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 524 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine525: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 525 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine526: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 526 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine527: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 527 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine528: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 528 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine529: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 529 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine530: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 530 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine531: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 531 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine532: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 532 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine533: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 533 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine534: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 534 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine535: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 535 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine536: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 536 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine537: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 537 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine538: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 538 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine539: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 539 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine540: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 540 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine541: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 541 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine542: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 542 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine543: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 543 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine544: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 544 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine545: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 545 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine546: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 546 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine547: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 547 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine548: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 548 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine549: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 549 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine550: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 550 << endl;
        exit(-1);
    }
    addrRel += 3054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine551: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3103))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 551 << endl;
        exit(-1);
    }
    addrRel += 3103;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine552: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3166))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 552 << endl;
        exit(-1);
    }
    addrRel += 3166;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine553: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 553 << endl;
        exit(-1);
    }
    addrRel += 3227;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine554: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3330))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 554 << endl;
        exit(-1);
    }
    addrRel += 3330;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine555: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3386))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 555 << endl;
        exit(-1);
    }
    addrRel += 3386;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine556: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 556 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine557: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 557 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine558: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 558 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine559: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 559 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine560: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3438))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 560 << endl;
        exit(-1);
    }
    addrRel += 3438;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine561: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 561 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine562: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 562 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine563: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3493))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 563 << endl;
        exit(-1);
    }
    addrRel += 3493;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine564: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 564 << endl;
        exit(-1);
    }
    addrRel += 3539;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine565: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3509))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 565 << endl;
        exit(-1);
    }
    addrRel += 3509;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine566: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 566 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine567: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine568: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine569: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine570: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 27;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine571: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(588))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 571 << endl;
        exit(-1);
    }
    addrRel += 588;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine572: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine573: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 28;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine574: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(588))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 574 << endl;
        exit(-1);
    }
    addrRel += 588;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine575: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine576: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine577: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine578: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine579: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine580: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine581: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine582: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(588))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 582 << endl;
        exit(-1);
    }
    addrRel += 588;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine583: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 583 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine584: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 584 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine585: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 585 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine586: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 587;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 586 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine587: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 587 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine588: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 588 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine589: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 589 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine590: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 590 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine591: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(60));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 591 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine592: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 592 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine593: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine594: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(604))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 594 << endl;
        exit(-1);
    }
    addrRel += 604;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine595: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(600))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 595 << endl;
        exit(-1);
    }
    addrRel += 600;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine596: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine597: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine598: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine599: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(594))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 599 << endl;
        exit(-1);
    }
    addrRel += 594;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine600: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine601: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine602: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 603;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 602 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine603: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine604: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine605: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine606: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 606 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine607: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 607 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine608: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 608 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine609: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 610;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 609 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine610: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 610 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine611: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 611 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine612: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(600));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 612 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine613: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 613 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine614: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine615: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(625))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 615 << endl;
        exit(-1);
    }
    addrRel += 625;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine616: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(621))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 616 << endl;
        exit(-1);
    }
    addrRel += 621;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine617: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine618: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine619: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine620: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(615))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 620 << endl;
        exit(-1);
    }
    addrRel += 615;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine621: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine622: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine623: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 624;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 623 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine624: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine625: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine626: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine627: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 627 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine628: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 628 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine629: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 629 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine630: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 631;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 630 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine631: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 631 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine632: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 632 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine633: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 633 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine634: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine635: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-3
    op0 = fr.mul(-3, A0);
    op1 = fr.mul(-3, A1);
    op2 = fr.mul(-3, A2);
    op3 = fr.mul(-3, A3);
    op4 = fr.mul(-3, A4);
    op5 = fr.mul(-3, A5);
    op6 = fr.mul(-3, A6);
    op7 = fr.mul(-3, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 635 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine636: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 636 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine637: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 637 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine638: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 638 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine639: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 639 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine640: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 640 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine641: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(651))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 641 << endl;
        exit(-1);
    }
    addrRel += 651;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine642: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 643;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 642 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine643: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine644: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine645: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 645 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine646: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 647;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 646 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine647: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine648: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine649: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine650: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(640))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 650 << endl;
        exit(-1);
    }
    addrRel += 640;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine651: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 652;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 651 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine652: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine653: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 653 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine654: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 655;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 654 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine655: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 655 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine656: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 656 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine657: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 657 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine658: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 658 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine659: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 659 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine660: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 661;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 660 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine661: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 661 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine662: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 663;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 662 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine663: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 663 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine664: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 665;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 664 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine665: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 665 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine666: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 666 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine667: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 668;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 667 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine668: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine669: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 669 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine670: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 671;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 670 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine671: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 671 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine672: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine673: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 673 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine674: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 675;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 674 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine675: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine676: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine677: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine678: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 678 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine679: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 679 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine680: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine681: //;; Set batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 682;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 681 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine682: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 682 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine683: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(686))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 683 << endl;
        exit(-1);
    }
    addrRel += 686;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine684: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 685;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 684 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine685: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(687))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 685 << endl;
        exit(-1);
    }
    addrRel += 687;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine686: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 687;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 686 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine687: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 687 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine688: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 688 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine689: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine690: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(692))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 690 << endl;
        exit(-1);
    }
    addrRel += 692;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine691: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine692: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine693: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine694: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine695: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 695 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine696: //        

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 696 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine697: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 697 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine698: //;; Set global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(700))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 698 << endl;
        exit(-1);
    }
    addrRel += 700;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine699: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(703))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 699 << endl;
        exit(-1);
    }
    addrRel += 703;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine700: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine701: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(703))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 701 << endl;
        exit(-1);
    }
    addrRel += 703;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine702: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=8
    op0 = fr.mul(8, C0);
    op1 = fr.mul(8, C1);
    op2 = fr.mul(8, C2);
    op3 = fr.mul(8, C3);
    op4 = fr.mul(8, C4);
    op5 = fr.mul(8, C5);
    op6 = fr.mul(8, C6);
    op7 = fr.mul(8, C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine703: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine704: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine705: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine706: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(708))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 706 << endl;
        exit(-1);
    }
    addrRel += 708;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine707: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine708: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 708 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine709: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine710: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 200;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine711: //;; Prepare transaction loop

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine712: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(714))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 712 << endl;
        exit(-1);
    }
    addrRel += 714;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine713: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 200;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine714: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 714 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine715: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 715 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine716: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 716 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine717: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 717 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine718: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 128;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine719: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine720: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(743))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 720 << endl;
        exit(-1);
    }
    addrRel += 743;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine721: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 721 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine722: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 64;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine723: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine724: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(743))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 724 << endl;
        exit(-1);
    }
    addrRel += 743;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine725: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 725 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine726: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 727;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 726 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine727: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine728: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 729;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 728 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine729: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine730: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 731;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 730 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine731: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine732: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 733;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 732 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine733: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 733 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine734: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine735: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine736: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 736 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine737: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 738;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 737 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine738: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine739: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 739 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine740: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 741;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 740 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine741: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(150));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 741 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine742: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 742 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine743: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(828))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 743 << endl;
        exit(-1);
    }
    addrRel += 828;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine744: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 744 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine745: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 745 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine746: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 96;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine747: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine748: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(769))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 748 << endl;
        exit(-1);
    }
    addrRel += 769;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine749: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 749 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine750: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 64;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine751: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine752: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(769))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 752 << endl;
        exit(-1);
    }
    addrRel += 769;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine753: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 753 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine754: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 755;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 754 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine755: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine756: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 757;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 756 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine757: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine758: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 759;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 758 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine759: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 759 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine760: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine761: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine762: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 762 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine763: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 764;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 763 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine764: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine765: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 765 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine766: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 767;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 766 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine767: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 767 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine768: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 768 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine769: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(828))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 769 << endl;
        exit(-1);
    }
    addrRel += 828;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine770: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 770 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine771: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 771 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine772: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine773: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine774: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine775: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(790))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 775 << endl;
        exit(-1);
    }
    addrRel += 790;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine776: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 776 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine777: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(782))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 777 << endl;
        exit(-1);
    }
    addrRel += 782;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine778: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 779;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 778 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine779: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine780: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine781: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(777))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 781 << endl;
        exit(-1);
    }
    addrRel += 777;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine782: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine783: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 783 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine784: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 784 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine785: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 786;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 785 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine786: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 786 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine787: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine788: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-34000
    op0 = fr.mul(-34000, A0);
    op1 = fr.mul(-34000, A1);
    op2 = fr.mul(-34000, A2);
    op3 = fr.mul(-34000, A3);
    op4 = fr.mul(-34000, A4);
    op5 = fr.mul(-34000, A5);
    op6 = fr.mul(-34000, A6);
    op7 = fr.mul(-34000, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(45000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 788 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine789: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 789 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine790: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(828))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 790 << endl;
        exit(-1);
    }
    addrRel += 828;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine791: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine792: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 792 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine793: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 213;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine794: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine795: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(819))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 795 << endl;
        exit(-1);
    }
    addrRel += 819;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine796: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine797: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(797))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 797 << endl;
        exit(-1);
    }
    addrRel += 797;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine798: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(803))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 798 << endl;
        exit(-1);
    }
    addrRel += 803;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine799: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine800: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine801: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine802: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(797))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 802 << endl;
        exit(-1);
    }
    addrRel += 797;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine803: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine804: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine805: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 806;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 805 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine806: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine807: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine808: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 808 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine809: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine810: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine811: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine812: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 812 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine813: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 813 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine814: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 814 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine815: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 816;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 815 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine816: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 816 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine817: //;; Set batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 818;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 817 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine818: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(821))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 818 << endl;
        exit(-1);
    }
    addrRel += 821;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine819: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 819 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine820: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(828))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 820 << endl;
        exit(-1);
    }
    addrRel += 828;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine821: //INCLUDE "vars.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 821 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine822: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine823: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(834))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 823 << endl;
        exit(-1);
    }
    addrRel += 834;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine824: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 824 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine825: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 825 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine826: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine827: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 827 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine828: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 828 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine829: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(834))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 829 << endl;
        exit(-1);
    }
    addrRel += 834;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine830: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 830 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine831: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 831 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine832: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine833: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 833 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine834: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 834 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine835: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(566))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 835 << endl;
        exit(-1);
    }
    addrRel += 566;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine836: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 836 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine837: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 837 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine838: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(632))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 838 << endl;
        exit(-1);
    }
    addrRel += 632;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine839: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(656))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 839 << endl;
        exit(-1);
    }
    addrRel += 656;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine840: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 840 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine841: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 841 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine842: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 842 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine843: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 843 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine844: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 844 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine845: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 845 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine846: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 846 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine847: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine848: //        ${getOldLocalExitRoot()}  => A      :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 848 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine849: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 849 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine850: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 850 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine851: //        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine852: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine853: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 853 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine854: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 854 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine855: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 855 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine856: //        ${getChainId()}                     :MSTORE(chainId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine857: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 857 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine858: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 858 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine859: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(11))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 859 << endl;
        exit(-1);
    }
    addrRel += 11;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine860: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(8))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 860 << endl;
        exit(-1);
    }
    addrRel += 8;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine861: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(865))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 861 << endl;
        exit(-1);
    }
    addrRel += 865;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine862: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine863: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(865))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 863 << endl;
        exit(-1);
    }
    addrRel += 865;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine864: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 864 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine865: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 865 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine866: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine867: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 867 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine868: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine869: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine870: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine871: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 871 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine872: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine873: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 873 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine874: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
    {
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 874 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
    }


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine875: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine876: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine877: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine878: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine879: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine880: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine881: //        0                                   :MSTORE(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 881 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine882: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 882 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine883: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 883 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine884: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 885;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 884 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine885: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 885 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine886: //        $${var p = 0}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 886 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine887: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine888: //txLoopRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine889: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine890: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 890 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine891: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine892: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine893: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 893 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine894: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 894 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine895: //endCheckRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 895 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine896: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine897: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine898: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 898 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine899: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine900: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(21000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 900 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine901: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 901 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine902: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine903: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 903 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine904: //        %LOCAL_EXIT_ROOT_STORAGE_POS => C                         ; Storage position of the local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine905: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = fr.neg(1);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine906: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine907: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine908: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine909: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(910))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 909 << endl;
        exit(-1);
    }
    addrRel += 910;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine910: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 910 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine911: //;; Check batchHashData

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 911 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine912: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 913;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 912 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine913: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 913 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine914: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 914 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine915: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(906))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 915 << endl;
        exit(-1);
    }
    addrRel += 906;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine916: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine917: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine918: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine919: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(921))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 919 << endl;
        exit(-1);
    }
    addrRel += 921;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine920: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(923))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 920 << endl;
        exit(-1);
    }
    addrRel += 923;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine921: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 921 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine922: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(910))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 922 << endl;
        exit(-1);
    }
    addrRel += 910;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine923: //        $ => A                          :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 923 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine924: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(910))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 924 << endl;
        exit(-1);
    }
    addrRel += 910;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine925: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 925 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine926: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 926 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine927: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(938))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 927 << endl;
        exit(-1);
    }
    addrRel += 938;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine928: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 928 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine929: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine930: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 10;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine931: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(835))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 931 << endl;
        exit(-1);
    }
    addrRel += 835;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine932: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine933: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine934: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine935: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine936: //        $ => A                          :MLOAD(globalHash)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 936 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine937: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1040))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 937 << endl;
        exit(-1);
    }
    addrRel += 1040;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine938: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine939: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 939 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine940: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 940 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine941: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 941 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine942: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(974))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 942 << endl;
        exit(-1);
    }
    addrRel += 974;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine943: //INCLUDE "process_tx.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 943 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine944: //INCLUDE "opcodes.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 944 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine945: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(957))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 945 << endl;
        exit(-1);
    }
    addrRel += 957;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine946: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 946 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine947: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine948: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 214);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine949: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 148;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine950: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine951: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine952: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine953: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 128);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine954: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine955: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine956: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(967))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 956 << endl;
        exit(-1);
    }
    addrRel += 967;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine957: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine958: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 214;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine959: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 148;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine960: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine961: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine962: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine963: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(966))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 963 << endl;
        exit(-1);
    }
    addrRel += 966;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine964: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine965: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(967))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 965 << endl;
        exit(-1);
    }
    addrRel += 967;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine966: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 128;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine967: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine968: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine969: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 12;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine970: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 971;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 970 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine971: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 972;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 971 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine972: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 972 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine973: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1016))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 973 << endl;
        exit(-1);
    }
    addrRel += 1016;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine974: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 974 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine975: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine976: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 976 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine977: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 977 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine978: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 979;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 978 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine979: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 979 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine980: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-6
    op0 = fr.mul(-6, A0);
    op1 = fr.mul(-6, A1);
    op2 = fr.mul(-6, A2);
    op3 = fr.mul(-6, A3);
    op4 = fr.mul(-6, A4);
    op5 = fr.mul(-6, A5);
    op6 = fr.mul(-6, A6);
    op7 = fr.mul(-6, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 980 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine981: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine982: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(983))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 982 << endl;
        exit(-1);
    }
    addrRel += 983;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine983: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(995))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 983 << endl;
        exit(-1);
    }
    addrRel += 995;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine984: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(990))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 984 << endl;
        exit(-1);
    }
    addrRel += 990;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine985: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine986: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine987: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine988: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine989: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(983))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 989 << endl;
        exit(-1);
    }
    addrRel += 983;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine990: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine991: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine992: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 993;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 992 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine993: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine994: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine995: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine996: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine997: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine998: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 998 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine999: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 999 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1000: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1001: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1002: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1003: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1003 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1004: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1005: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(36))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1005 << endl;
        exit(-1);
    }
    addrRel += 36;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1006: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1007: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1008: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1009: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1010: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1011: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1012: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 12;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1013: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1014;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1013 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1014: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1015;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1014 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1015: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1015 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1016: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1016 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1017: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1017 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1018: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1019: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1020: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1020 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1021: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1021 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1022: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1022 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1023: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1023 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1024: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1024 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1025: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1025 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1026: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1026 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1027: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1027 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1028: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1029;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1028 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1029: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1029 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1030: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1030 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1031: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = fr.add(op0, SP);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1032: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1032 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1033: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inPC*PC, where inPC=-1
    op0 = fr.add(op0, fr.neg(PC));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1060))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1033 << endl;
        exit(-1);
    }
    addrRel += 1060;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1034: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1035: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1035 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1036: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1037: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1038: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1039: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(310))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1039 << endl;
        exit(-1);
    }
    addrRel += 310;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1040: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1041: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1042: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1042 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1043: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1043 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1044: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1045: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1046: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1047: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1048: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inPC*PC, where inPC=-1
    op0 = fr.add(op0, fr.neg(PC));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1048 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1049: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1050: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1051: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1052: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1053: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(310))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1053 << endl;
        exit(-1);
    }
    addrRel += 310;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1054: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1054 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1055: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1024))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1055 << endl;
        exit(-1);
    }
    addrRel += 1024;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1056: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1043))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1056 << endl;
        exit(-1);
    }
    addrRel += 1043;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1057: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1057 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1058: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1060))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1058 << endl;
        exit(-1);
    }
    addrRel += 1060;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1059: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1070))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1059 << endl;
        exit(-1);
    }
    addrRel += 1070;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1060: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1060 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1061: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1062: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1063: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1064: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1065: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1065 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1066: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1067: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1068: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1069: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1070: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1070 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1071: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1072: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1073: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1073 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1074: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1074 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1075: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1076: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1076 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1077: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1078: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1079: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1079 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1080: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1081: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1082: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1082 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1083: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1083 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1084: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1084 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1085: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1086;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1085 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1086: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1086 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1087: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1087 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1088: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1089: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1090: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1091: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1091 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1092: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1101))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1092 << endl;
        exit(-1);
    }
    addrRel += 1101;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1093: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1094: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inGAS*GAS, where inGAS=-1
    op0 = fr.add(op0, fr.neg(GAS));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1095: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1095 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1096: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1096 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1097: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1098;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1097 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1098: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1098 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1099: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1101))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1099 << endl;
        exit(-1);
    }
    addrRel += 1101;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1100: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1101: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1102: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1103: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1103 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1104: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1104 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1105: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1105 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1106: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1107;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1106 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1107: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1107 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1108: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1108 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1109: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1110: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1111: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1111 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1112: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1112 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1113: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1114;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1113 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1114: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1114 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1115: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1115 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1116: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1117: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1118: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1119: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inGAS*GAS, where inGAS=-1
    op0 = fr.add(op0, fr.neg(GAS));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1120: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1120 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1121: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1121 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1122: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1122 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1123: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1124;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1123 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1124: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1124 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1125: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1125 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1126: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1127: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1128: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1128 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1129: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1129 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1130: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1131;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1130 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1131: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1131 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1132: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1132 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1133: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1134: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1135: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(65))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1135 << endl;
        exit(-1);
    }
    addrRel += 65;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1136: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1136 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1137: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(65))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1137 << endl;
        exit(-1);
    }
    addrRel += 65;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1138: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1139: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1141))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1139 << endl;
        exit(-1);
    }
    addrRel += 1141;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1140: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1141: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1142: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1143: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1144: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1145: //;; Set batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1146: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1146 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1147: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1147 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1148: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1149: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1149 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1150: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1150 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1151: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1151 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1152: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1169))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1152 << endl;
        exit(-1);
    }
    addrRel += 1169;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1153: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1153 << endl;
        exit(-1);
    }
    addrRel += 1209;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1154: //        ${eventLog(onStartBatch, C)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1162))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1154 << endl;
        exit(-1);
    }
    addrRel += 1162;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1155: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1156: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1157: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1157 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1158: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1159: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1159 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1160: //        

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1161: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1153))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1161 << endl;
        exit(-1);
    }
    addrRel += 1153;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1162: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1163: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1164: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1165;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1164 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1165: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1166;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1165 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1166: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1166 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1167: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1168: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1168 << endl;
        exit(-1);
    }
    addrRel += 1209;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1169: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1169 << endl;
        exit(-1);
    }
    addrRel += 1209;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1170: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1185))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1170 << endl;
        exit(-1);
    }
    addrRel += 1185;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1171: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1172: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1173: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1174: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1175;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1174 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1175: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1176: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1177: //;; Prepare transaction loop

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1178: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1179: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1180;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1179 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1180: //        0                                   :MSTORE(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1180 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1181: //        E                                   :MSTORE(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1182: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1182 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1183: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1184: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1169))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1184 << endl;
        exit(-1);
    }
    addrRel += 1169;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1185: //        $${var p = 0}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1195))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1185 << endl;
        exit(-1);
    }
    addrRel += 1195;
    addr = addrRel;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1186: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1187: //txLoopRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1188: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1189: //        A+1 => CTX      :MSTORE(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1190: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1191;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1190 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1191: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1192;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1191 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1192: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1192 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1193: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1194: //                        :JMP(endCheckRLP)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1209))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1194 << endl;
        exit(-1);
    }
    addrRel += 1209;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1195: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1196: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1197: //txLoop:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1198: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1199;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1198 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1199: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1200: //        A               :JMPN(processTxsEnd)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1201: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1202: //        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1203: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1204: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1205;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1204 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1205: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1206: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1207;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1206 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1207: //processTxEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1207 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1208: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1209: //processTxsEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1209 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1210: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1210 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1211: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1212: //        $ => A                          :SLOAD

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1212 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1213: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1213 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1214: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1214 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1215: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1216: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1217: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1218: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1223))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1218 << endl;
        exit(-1);
    }
    addrRel += 1223;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1219: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1220: //;; Check batchHashData

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1221;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1220 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1221: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1222: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1217))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1222 << endl;
        exit(-1);
    }
    addrRel += 1217;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1223: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1224: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1224 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1225: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1225 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1226: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1226 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1227: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1228: //        HASHPOS                         :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1228 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1229: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1229 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1230: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1230 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1231: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1231 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1232: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1232 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1233: //; Check Global Hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1233 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1234: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = fr.neg(1);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1259))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1234 << endl;
        exit(-1);
    }
    addrRel += 1259;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1235: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1236: //        ; Get position of the previous hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1237: //        $ => HASHPOS                    :MLOAD(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1238: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1239: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1240;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1239 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1240: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1241;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1240 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1241: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1242: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1242 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1243: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1244: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1245;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1244 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1245: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1246: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1247: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1248: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1249: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1250;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1249 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1250: //        ${eventLog(onFinishBatch)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1251;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1250 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1251: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1252: //        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1252 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1253: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1254: //finalWait:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1254 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1255: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1256: //                         : JMP(start)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1256 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1257: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1258: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1303))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1258 << endl;
        exit(-1);
    }
    addrRel += 1303;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1259: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1259 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1260: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1261: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1262: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1303))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1262 << endl;
        exit(-1);
    }
    addrRel += 1303;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1263: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1263 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1264: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1264 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1265: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1265 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1266: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1266 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1267: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1267 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1268: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1268 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1269: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1283))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1269 << endl;
        exit(-1);
    }
    addrRel += 1283;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1270: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1271: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1272: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1272 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1273: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1274;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1273 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1274: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1275: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1276: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1277: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1278;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1277 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1278: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1279;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1278 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1279: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1280: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1280 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1281: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1282: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1303))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1282 << endl;
        exit(-1);
    }
    addrRel += 1303;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1283: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1284: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1285: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1285 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1286: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1287;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1286 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1287: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1288: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1289: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1290: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1291;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1290 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1291: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1292;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1291 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1292: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1293: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1294: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1294 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1295: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1296;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1295 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1296: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1297: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1298: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1299: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1300;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1299 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1300: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1301: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1301 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1302: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1303: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1303 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1304: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1304 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1305: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1305 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1306: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1306 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1307: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1307 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1308: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1309: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1309 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1310: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1310 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1311: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1311 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1312: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1312 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1313: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1314: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1315: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1316: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1317: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1318: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1338))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1318 << endl;
        exit(-1);
    }
    addrRel += 1338;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1319: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1320: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1321: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1322: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1323: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1323 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1324: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1325: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1326: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1326 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1327: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1328: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1329: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1330;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1329 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1330: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1331: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1332: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1333: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1334: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1335;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1334 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1335: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1336: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1337: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1372))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1337 << endl;
        exit(-1);
    }
    addrRel += 1372;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1338: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1339: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1340: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1372))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1340 << endl;
        exit(-1);
    }
    addrRel += 1372;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1341: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1341 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1342: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1342 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1343: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1343 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1344: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1344 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1345: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1345 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1346: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1357))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1346 << endl;
        exit(-1);
    }
    addrRel += 1357;
    addr = addrRel;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1347: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1348: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1349: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1350: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1351: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1352;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1351 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1352: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1353: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1354;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1353 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1354: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1355;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1354 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1355: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1356: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1372))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1356 << endl;
        exit(-1);
    }
    addrRel += 1372;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1357: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1358: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1359: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1360: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1361;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1360 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1361: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1362: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1363: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }

RomLine1364: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1365: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1366: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1367;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1366 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1367: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1368: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1369;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1368 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1369: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1370: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1370 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1371: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1372: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1372 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1373: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1373 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1374: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1374 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1375: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1375 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1376: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1377: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1377 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1378: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1378 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1379: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1379 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1380: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1380 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1381: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1382: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1383: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1384: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1385: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1400))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1385 << endl;
        exit(-1);
    }
    addrRel += 1400;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1386: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1387: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1388: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1389: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1390: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1391: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1400))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1391 << endl;
        exit(-1);
    }
    addrRel += 1400;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1392: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1393: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1394: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1395: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1396: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1397: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1400))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1397 << endl;
        exit(-1);
    }
    addrRel += 1400;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1398: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1399: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1402))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1399 << endl;
        exit(-1);
    }
    addrRel += 1402;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1400: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1401: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1402))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1401 << endl;
        exit(-1);
    }
    addrRel += 1402;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1402: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1402 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1403: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1403 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1404: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1404 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1405: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1405 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1406: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1407: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1407 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1408: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1408 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1409: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1409 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1410: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1410 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1411: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1412: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1412 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1413: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1415))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1413 << endl;
        exit(-1);
    }
    addrRel += 1415;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1414: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1415: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1415 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1416: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1416 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1417: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1417 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1418: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1418 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1419: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1420: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1420 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1421: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1421 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1422: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1422 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1423: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1424: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1425: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-3
    op0 = fr.mul(-3, A0);
    op1 = fr.mul(-3, A1);
    op2 = fr.mul(-3, A2);
    op3 = fr.mul(-3, A3);
    op4 = fr.mul(-3, A4);
    op5 = fr.mul(-3, A5);
    op6 = fr.mul(-3, A6);
    op7 = fr.mul(-3, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1425 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1426: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=3
    op0 = fr.mul(3, B0);
    op1 = fr.mul(3, B1);
    op2 = fr.mul(3, B2);
    op3 = fr.mul(3, B3);
    op4 = fr.mul(3, B4);
    op5 = fr.mul(3, B5);
    op6 = fr.mul(3, B6);
    op7 = fr.mul(3, B7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1426 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1427: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1427 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1428: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1428 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1429: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1430: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1430 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1431: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1432;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1478))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1431 << endl;
        exit(-1);
    }
    addrRel += 1478;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1432: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1432 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1433: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1433 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1434: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1435: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1435 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1436: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1437;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1472))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1436 << endl;
        exit(-1);
    }
    addrRel += 1472;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1437: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1437 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1438: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1439: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1439 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1440: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1441;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1478))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1440 << endl;
        exit(-1);
    }
    addrRel += 1478;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1441: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1441 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1442: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1442 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1443: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1444: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1444 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1445: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1446;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1472))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1445 << endl;
        exit(-1);
    }
    addrRel += 1472;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1446: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1446 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1447: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1448: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1448 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1449: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1450;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1478))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1449 << endl;
        exit(-1);
    }
    addrRel += 1478;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1450: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1450 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1451: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1451 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1452: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1453: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1454: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1455: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1455 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1456: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1457;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1472))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1456 << endl;
        exit(-1);
    }
    addrRel += 1472;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1457: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1457 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1458: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1459: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1459 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1460: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1461;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1478))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1460 << endl;
        exit(-1);
    }
    addrRel += 1478;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1461: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1461 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1462: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1462 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1463: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1464: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1465: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1466: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1467: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1467 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1468: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1468 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1469: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1470;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1472))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1469 << endl;
        exit(-1);
    }
    addrRel += 1472;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1470: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1470 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1471: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1472: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1472 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1473: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1473 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1474: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1474 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1475: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1475 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1476: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1476 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1477: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1478: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1478 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1479: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1479 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1480: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1480 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1481: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1481 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1482: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1482 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1483: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1484: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1484 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1485: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1485 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1486: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1486 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1487: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1487 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1488: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1489: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1490: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1491: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1492: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1493: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1494: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1495: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1500))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1495 << endl;
        exit(-1);
    }
    addrRel += 1500;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1496: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1496 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1497: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1497 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1498: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1498 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1499: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1499 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1500: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1501: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1501 << endl;
        exit(-1);
    }
    addrRel += 1516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1502: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1503: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1504: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1505: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1505 << endl;
        exit(-1);
    }
    addrRel += 1515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1506: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1507: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1508: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1509: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1510: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1511: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1512: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1513: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1514: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1514 << endl;
        exit(-1);
    }
    addrRel += 1516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1515: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1516: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1516 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1517: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1517 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1518: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1518 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1519: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1519 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1520: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1521: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1521 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1522: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1522 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1523: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1523 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1524: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1524 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1525: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1526: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1527: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1528: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1529: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1530: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1531: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1532: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1537))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1532 << endl;
        exit(-1);
    }
    addrRel += 1537;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1533: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1533 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1534: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1534 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1535: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1535 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1536: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1536 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1537: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1538: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1539: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1540: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1565))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1540 << endl;
        exit(-1);
    }
    addrRel += 1565;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1541: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1542: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1543: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1544: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 256);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1558))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1544 << endl;
        exit(-1);
    }
    addrRel += 1558;
    addr = addrRel;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1545: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1546: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1547: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1548: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1549: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1550: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1551: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1552: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 256);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1553: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1554: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1560))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1554 << endl;
        exit(-1);
    }
    addrRel += 1560;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1555: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1556: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1557: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1565))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1557 << endl;
        exit(-1);
    }
    addrRel += 1565;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1558: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1559: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1565))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1559 << endl;
        exit(-1);
    }
    addrRel += 1565;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1560: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 256);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1561: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1562: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1563: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1564: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1565: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1566: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1566 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1567: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1567 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1568: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1568 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1569: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1569 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1570: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1571: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1571 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1572: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1572 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1573: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1574: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1581))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1574 << endl;
        exit(-1);
    }
    addrRel += 1581;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1575: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1576: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1576 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1577: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1577 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1578: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1578 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1579: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1580: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1580 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1581: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1582: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1118))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1582 << endl;
        exit(-1);
    }
    addrRel += 1118;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1583: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1583 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1584: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1584 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1585: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1586: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1593))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1586 << endl;
        exit(-1);
    }
    addrRel += 1593;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1587: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1588: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1588 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1589: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1589 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1590: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1590 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1591: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1592: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1592 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1593: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1594: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1118))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1594 << endl;
        exit(-1);
    }
    addrRel += 1118;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1595: //start:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1595 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1596: //; First of all, load The call Data.  The first A value is forced with the hash of the TX.

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1607))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1596 << endl;
        exit(-1);
    }
    addrRel += 1607;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1597: //        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1597 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1598: //        STEP => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1599: //        1                                   :ASSERT                                ; Ensure it is the begining of the execution

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1599 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1600: //        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1600 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1601: //        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1602: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1602 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1603: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1603 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1604: //        $ => A                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1605: //        A                                   :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1605 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1606: //        A => SR

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1606 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1607: //                                            :MSTORE(oldLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1607 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1608: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1608 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1609: //        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1610: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1611: //        ${getBatchHashData()}               :MSTORE(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1612: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1612 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1613: //        ${getNumBatch()}                    :MSTORE(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1613 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1614: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1615;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1614 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1615: //        ${getTimestamp()}                   :MSTORE(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1615 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1616: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1617: //        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1617 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1618: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1618 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1619: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1619 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1620: //        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1620 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1621: //        HASHPOS                             :MSTORE(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1622: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1623: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1624: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1624 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1625: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1625 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1626: //        32 => D ; //TODO: opt. no need set D to 32

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1627;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1626 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1627: //        $ => A                              :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1627 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1628: //        A - 1                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1629: //        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1629 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1630: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1630 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1631: //        $ => C                              :HASHKDIGEST(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1631 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1632: //        %ADDRESS_SYSTEM => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1632 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1633: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1634: //        $ => D                              :MLOAD(oldStateRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1635: //        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1636: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1636 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1637: //;; Set global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1637 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1638: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1639;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1439))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1638 << endl;
        exit(-1);
    }
    addrRel += 1439;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1639: //        ; A new hash with position 0 is started

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1639 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1640: //        0 => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1641: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1641 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1642: //        $ => E                              :MLOAD(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1642 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1643: //        E+1 => E                            :MSTORE(lastHashIdUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1643 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1644: //        A                                   :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1644 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1645: //        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1646: //        HASHPOS                             :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1647: //        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1648: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1648 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1649: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1649 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1650: //        $ => D                              :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1651;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1650 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1651: //        $ => SR                             :SSTORE

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1651 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1652: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1653: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1653 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1654: //;; Prepare transaction loop

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1654 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1655: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1655 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1656: //        E                                   :MSTORE(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1656 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1657: //        ; Store the lastHashIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1658: //        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1659: //        $ => A                              :MLOAD(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1660;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1659 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1660: //        A                                   :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1661: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1662: //        $${var p = 0}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1663: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1664;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1663 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1664: //txLoopRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1664 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1665: //        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1666: //        A+1 => CTX      :MSTORE(lastCtxUsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1667: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1668: //        $ => A          :MLOAD(batchL2DataLength)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1669: //        $ => C          :MLOAD(batchL2DataParsed)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1669 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1670: //        C - A           :JMPN(loadTx_rlp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1679))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1670 << endl;
        exit(-1);
    }
    addrRel += 1679;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1671: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1671 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1672: //endCheckRLP:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1672 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1673: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1674;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1673 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1674: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1674 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1675: //txLoop:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1676: //        $ => A          :MLOAD(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1676 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1677: //        A-1 => A        :MSTORE(pendingTxs)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1677 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1678: //        A               :JMPN(processTxsEnd)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1678 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1679: //        A+1 => CTX      :MSTORE(ctxTxToUse)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1680: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1681: //                        :JMP(processTx)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1682: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1683: //processTxEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1684: //        ${eventLog(onFinishTx)}

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1685: //                        :JMP(txLoop)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1686: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1686 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1687: //processTxsEnd:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1687 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1688: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1688 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1689: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1689 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1690: //        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1691: //        %SMT_KEY_SC_STORAGE => B

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1692: //        %LOCAL_EXIT_ROOT_STORAGE_POS => C                         ; Storage position of the local exit root

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1693: //        $                               :MLOAD(newLocalExitRoot), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1693 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1694: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1694 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1695: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1696;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1695 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1696: //;; Txs Size Verification

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1696 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1697: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1698: //        $ => A                          :MLOAD(batchHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1698 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1699: //        $                               :MLOAD(batchL2DataLength), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1699 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1700: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1700 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1701: //;;;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1701 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1702: //        A => HASHPOS

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1703: //        $ => E                          :MLOAD(batchHashDataId)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1704: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1705;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1704 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1705: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1706: //        $ => A                          :MLOAD(globalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1707: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1708: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1709;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1708 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1709: //        $ => A                          :MLOAD(timestamp)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1709 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1710: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1711: //        20 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1712: //        $ => A                          :MLOAD(sequencerAddr)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1713: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1713 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1714: //        8 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1723))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1714 << endl;
        exit(-1);
    }
    addrRel += 1723;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1715: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1715 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1716: //        $ => A                          :MLOAD(numBatch)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1716 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1717: //        A                               :HASHK(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1718;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1717 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1718: //        HASHPOS                         :HASHKLEN(E)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1718 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1719: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1720: //        $                               :HASHKDIGEST(E), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1720 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1721: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1721 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1722: //;;;;;;;

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1722 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1723: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1724: //        ; Get position of the previous hash

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1725: //        $ => HASHPOS                    :MLOAD(oldHashPos)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1726: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1727: //        32 => D

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1728: //        SR                              :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1729: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1730: //        $ => A                          :MLOAD(newLocalExitRoot)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1731: //        A                               :HASHK(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1731 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1732: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1732 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1733: //        $ => A                          :MLOAD(batchHashData)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1733 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1734: //        HASHPOS                         :HASHKLEN(0)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1734 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1735: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1736: //        $ => A                          :MLOAD(globalHash)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1737: //        $                               :HASHKDIGEST(0), ASSERT

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1738: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1738 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1739: //        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1739 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1740: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1741;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1740 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1741: //finalWait:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1741 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1742: //        ${beforeLast()}  : JMPN(finalWait)

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1743: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1743 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1744: //INCLUDE "loadtx_rlp.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1744 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1745: //INCLUDE "process_tx.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1746;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1745 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1746: //INCLUDE "opcodes.zkasm"

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1746 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1747: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1748: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1748 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1749: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1749 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1750: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1750 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1751: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1751 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1752: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1753: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1754: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1755: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1755 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1756: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1756 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1757: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1758;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1757 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1758: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1758 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1759: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1760: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1760 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1761: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1761 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1762: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1763;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1762 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1763: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1763 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1764: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1765: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1765 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1766: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1766 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1767: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1767 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1768: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1768 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1769: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1770: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1771: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1772: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1773: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1774: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1774 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1775: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1776;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1212))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1775 << endl;
        exit(-1);
    }
    addrRel += 1212;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1776: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-50
    op0 = fr.mul(-50, A0);
    op1 = fr.mul(-50, A1);
    op2 = fr.mul(-50, A2);
    op3 = fr.mul(-50, A3);
    op4 = fr.mul(-50, A4);
    op5 = fr.mul(-50, A5);
    op6 = fr.mul(-50, A6);
    op7 = fr.mul(-50, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1776 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1777: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1777 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1778: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1778 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1779: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1780: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1781: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1782: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 31;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1783: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1784: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1805))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1784 << endl;
        exit(-1);
    }
    addrRel += 1805;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1785: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1786: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1786 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1787: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 7;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1787 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1788: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1789;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1788 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1789: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1789 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1790: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1791: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1792: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1793: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1794: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1795: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1802))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1795 << endl;
        exit(-1);
    }
    addrRel += 1802;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1796: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1797: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1798: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1799: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1800: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1801: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1805))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1801 << endl;
        exit(-1);
    }
    addrRel += 1805;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1802: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1803: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1804: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1805: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1806: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1806 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1807: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1807 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1808: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1808 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1809: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1810: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1810 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1811: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1811 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1812: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1813: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1813 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1814: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1814 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1815: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1815 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1816: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1817: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1818: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1819: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1819 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1820: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1821: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1821 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1822: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1822 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1823: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1823 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1824: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1825: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1826: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1827: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1827 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1828: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1829: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1829 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1830: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1830 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1831: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1831 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1832: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1833: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1834: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1835: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1835 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1836: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1837: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1837 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1838: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1838 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1839: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1839 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1840: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1841: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1842: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1843: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1843 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1844: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1845: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1845 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1846: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1846 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1847: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1847 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1848: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1849: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1850: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1851: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1851 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1852: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1853: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1853 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1854: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1854 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1855: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1855 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1856: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1857: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1857 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1858: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1859: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1860: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1860 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1861: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1861 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1862: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1862 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1863: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1864: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1865: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1866: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1866 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1867: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1868: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1868 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1869: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1869 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1870: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1870 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1871: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1872: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1873: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1874: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1874 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1875: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1876: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1876 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1877: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1877 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1878: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1878 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1879: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1880: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1881: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1882: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1882 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1883: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1884: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1884 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1885: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1885 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1886: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1886 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1887: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1888: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1888 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1889: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1890: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1891: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1891 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1892: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1892 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1893: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1893 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1894: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1895: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1896: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1897: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1898: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1899;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1898 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1899: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1899 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1900: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1901: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1902: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1902 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1903: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1903 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1904: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1904 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1905: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1906: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1907: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1908: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1909;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1496))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1908 << endl;
        exit(-1);
    }
    addrRel += 1496;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1909: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1910: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1910 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1911: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1911 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1912: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1912 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1913: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1913 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1914: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1915: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1916: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1917: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1918;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1533))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1917 << endl;
        exit(-1);
    }
    addrRel += 1533;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1918: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1919: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1919 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1920: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1920 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1921: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1921 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1922: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1922 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1923: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1924: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1925: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1926: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1927: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1928: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1929: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1930: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1931: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1932: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1933: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1934;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1138))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1933 << endl;
        exit(-1);
    }
    addrRel += 1138;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1934: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1935;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1934 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1935: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1936: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1937: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1938: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1939: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1944))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1939 << endl;
        exit(-1);
    }
    addrRel += 1944;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1940: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1941: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1941 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1942: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1942 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1943: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1943 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1944: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1945: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1946: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1947: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1948: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1949: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1950: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1951: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1951 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1952: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1952 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1953: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1953 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1954: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1954 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1955: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1956: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1957: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1958: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1958 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1959: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(30));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1959 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1960: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1961: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1961 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1962: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1962 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1963: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1964;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1963 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1964: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1964 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1965: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 6;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1965 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1966: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1966 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1967: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1968;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1967 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1968: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1968 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1969: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1969 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine1970: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1970 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1971: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1971 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1972: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1973: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine1974: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1989))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1974 << endl;
        exit(-1);
    }
    addrRel += 1989;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1975: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1983))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1975 << endl;
        exit(-1);
    }
    addrRel += 1983;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1976: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1977;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1976 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1977: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1978: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1978 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1979: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1980: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1981: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1982: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1974))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1982 << endl;
        exit(-1);
    }
    addrRel += 1974;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1983: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1984;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1983 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1984: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1985: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1986;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1985 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1986: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1986 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1987: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1988: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1989: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1989 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1990: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1991: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1992: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1993: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1993 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1994: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1994 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1995: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1995 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1996: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1996 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1997: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1997 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1998: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1998 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine1999: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2002))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1999 << endl;
        exit(-1);
    }
    addrRel += 2002;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2000: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2000 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2001: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2003))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2001 << endl;
        exit(-1);
    }
    addrRel += 2003;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2002: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2002 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2003: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2004: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2004 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2005: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2005 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2006: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2006 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2007: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2007 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2008: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2009: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2010: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2011: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2012: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2012 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2013: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2014: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2014 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2015: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2015 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2016: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2016 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2017: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2018: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2018 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2019: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2019 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2020: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2020 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2021: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2021 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2022: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2023: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2023 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2024: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2024 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2025: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2025 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2026: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2026 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2027: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2028: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2028 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2029: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2029 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2030: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2030 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2031: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2031 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2032: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2033: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2033 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2034: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2034 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2035: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2036;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2035 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2036: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2036 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2037: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2037 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2038: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2047))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2038 << endl;
        exit(-1);
    }
    addrRel += 2047;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2039: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2040: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2041: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2042: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2043: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2044: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2044 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2045: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2045 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2046: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2046 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2047: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2048: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2049: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2050: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2051: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2052;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2051 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2052: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2053: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2054: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2055: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2056;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2055 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2056: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2057: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2058: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2058 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2059: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2059 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2060: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2060 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2061: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2061 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2062: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2063: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2063 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2064: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2064 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2065: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2065 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2066: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2066 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2067: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2068: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2069: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2070: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2071: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2071 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2072: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2072 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2073: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2073 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2074: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2074 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2075: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2076))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2075 << endl;
        exit(-1);
    }
    addrRel += 2076;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2076: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2124))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2076 << endl;
        exit(-1);
    }
    addrRel += 2124;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2077: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2100))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2077 << endl;
        exit(-1);
    }
    addrRel += 2100;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2078: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2078 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2079: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2079 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2080: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2081;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2080 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2081: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2081 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2082: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2082 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2083: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2084: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2085: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2086;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2085 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2086: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2087: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2087 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2088: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1025);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2089: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2090: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2091: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2092;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2091 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2092: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2092 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2093: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2094;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2093 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2094: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2094 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2095: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2096: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2097: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2098: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2099: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2076))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2099 << endl;
        exit(-1);
    }
    addrRel += 2076;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2100: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2101: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2102: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2103: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2104;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2103 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2104: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2104 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2105: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2106: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1025;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2107: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2108: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2119))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2108 << endl;
        exit(-1);
    }
    addrRel += 2119;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2109: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2110: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2111: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2112: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2113;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2112 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2113: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2114: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2115;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2114 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2115: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2116: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2116 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2117: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2118;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2117 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2118: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2124))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2118 << endl;
        exit(-1);
    }
    addrRel += 2124;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2119: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2120: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2121;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2120 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2121: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2122;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2121 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2122: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2122 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2123: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2124;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2123 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2124: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2124 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2125: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2125 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2126: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2126 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2127: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2127 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2128: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2128 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2129: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2129 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2130: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2140))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2130 << endl;
        exit(-1);
    }
    addrRel += 2140;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2131: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2131 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2132: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2133: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2134: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2135: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2136: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2137: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2137 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2138: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2138 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2139: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2139 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2140: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2140 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2141: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2142: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2142 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2143: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2143 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2144: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2144 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2145: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2145 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2146: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2146 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2147: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2066))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2147 << endl;
        exit(-1);
    }
    addrRel += 2066;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2148: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2148 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2149: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2150: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2151: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2152: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2153: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2154: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2155: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2156: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2156 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2157: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2157 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2158: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2158 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2159: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2172))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2159 << endl;
        exit(-1);
    }
    addrRel += 2172;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2160: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2167))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2160 << endl;
        exit(-1);
    }
    addrRel += 2167;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2161: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2162: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2162 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2163: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2164;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2163 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2164: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2165: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2166: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2159))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2166 << endl;
        exit(-1);
    }
    addrRel += 2159;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2167: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2168: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2169: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2170;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2169 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2170: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2170 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2171: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2172;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2171 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2172: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2172 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2173: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2173 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2174: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2174 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2175: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2175 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2176: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2176 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2177: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2178: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2178 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2179: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2179 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2180: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2180 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2181: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2181 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2182: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2183: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2184: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2185: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2186: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2187: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2188: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2189: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2189 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2190: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2190 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2191: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2191 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2192: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2192 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2193: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2194: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2195: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2196: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2197: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2198: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2199: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2200: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2201: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2202: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2202 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2203: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2203 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2204: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2204 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2205: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2218))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2205 << endl;
        exit(-1);
    }
    addrRel += 2218;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2206: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2213))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2206 << endl;
        exit(-1);
    }
    addrRel += 2213;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2207: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2208: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2208 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2209: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2210;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2209 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2210: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2211: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2212: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2205))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2212 << endl;
        exit(-1);
    }
    addrRel += 2205;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2213: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2214: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2215: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2216;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2215 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2216: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2216 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2217: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2218;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2217 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2218: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2218 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2219: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2219 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2220: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2220 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2221: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2221 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2222: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2222 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2223: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2224: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2224 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2225: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2225 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2226: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2226 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2227: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2227 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2228: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2229: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2230: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2231: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2231 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2232: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2233: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2234: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2234 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2235: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2236: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2236 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2237: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2237 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2238: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2239;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2238 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2239: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2239 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2240: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2240 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2241: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2241 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2242: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2243;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1448))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2242 << endl;
        exit(-1);
    }
    addrRel += 1448;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2243: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2243 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2244: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2244 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2245: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2245 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2246: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2246 << endl;
        exit(-1);
    }
    addrRel += 2263;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2247: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2257))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2247 << endl;
        exit(-1);
    }
    addrRel += 2257;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2248: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2249: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2250;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2249 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2250: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2251: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2252: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2252 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2253: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2254;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2253 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2254: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2255: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2256: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2246))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2256 << endl;
        exit(-1);
    }
    addrRel += 2246;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2257: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2258: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2259;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2258 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2259: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2260: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2261: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2261 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2262: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2263;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2262 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2263: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2263 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2264: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2264 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2265: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2265 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2266: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2266 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2267: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2267 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2268: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2269: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2270: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2270 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2271: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2272: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2273: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2274: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2275: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2275 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2276: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2276 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2277: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine2278: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2279: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2288))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2279 << endl;
        exit(-1);
    }
    addrRel += 2288;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2280: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2280 << endl;
        exit(-1);
    }
    addrRel += 2285;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2281: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2282: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2283: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2284: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2278))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2284 << endl;
        exit(-1);
    }
    addrRel += 2278;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2285: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2286: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2287: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2288: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2289: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2290: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2291: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2291 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2292: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2292 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2293: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2293 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2294: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(20));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2294 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2295: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2296: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2296 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2297: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2312))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2297 << endl;
        exit(-1);
    }
    addrRel += 2312;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2298: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2298 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2299: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2299 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2300: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;

RomLine2301: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2302: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2303: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2304: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2305: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2306: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2307: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2308: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2309: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2310: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2310 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2311: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2311 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2312: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2313: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2313 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2314: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2314 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2315: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2315 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2316: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2317: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2317 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2318: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2318 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2319: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2319 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2320: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2320 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2321: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2322: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2322 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2323: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2323 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2324: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2324 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2325: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2325 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2326: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2327: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2327 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2328: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2328 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2329: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2329 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2330: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2331: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2332: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2332 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2333: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2333 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2334: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2334 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2335: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 30000000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2336: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2337: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2337 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2338: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2338 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2339: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2339 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2340: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2341: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2342: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2342 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2343: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2343 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2344: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2344 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2345: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2345 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2346: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2347: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2348: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2349: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2349 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2350: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2350 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2351: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2351 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2352: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2352 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2353: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2353 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2354: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2354 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2355: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2355 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2356: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2357: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2358;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2357 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2358: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2359: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2359 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2360: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2360 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2361: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2361 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2362: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2362 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2363: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2363 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2364: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2364 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2365: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2366: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2367: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2368: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2368 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2369: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2370;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2369 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2370: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2370 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2371: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2371 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2372: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2372 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2373: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2373 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2374: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2375;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2374 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2375: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2375 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2376: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2376 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2377: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2378: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2379: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2380: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2381: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2382: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2383;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2382 << endl;
        exit(-1);
    }
    addrRel += 1521;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2383: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2383 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2384: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2385;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2384 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2385: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2385 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2386: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2386 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2387: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2387 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2388: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2388 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2389: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2389 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2390: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2391: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2391 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2392: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2393: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2394: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2395: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2395 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2396: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2397: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-2000
    op0 = fr.mul(-2000, A0);
    op1 = fr.mul(-2000, A1);
    op2 = fr.mul(-2000, A2);
    op3 = fr.mul(-2000, A3);
    op4 = fr.mul(-2000, A4);
    op5 = fr.mul(-2000, A5);
    op6 = fr.mul(-2000, A6);
    op7 = fr.mul(-2000, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2397 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2398: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2398 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2399: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2399 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2400: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2400 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2401: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2401 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2402: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2403: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2404: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2404 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2405: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2406: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2406 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2407: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2410))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2407 << endl;
        exit(-1);
    }
    addrRel += 2410;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2408: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2408 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2409: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2411))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2409 << endl;
        exit(-1);
    }
    addrRel += 2411;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2410: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2410 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2411: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2412: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2413: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2413 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2414: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2414 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2415: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2416: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2416 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2417: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2418: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2419: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-2100
    op0 = fr.mul(-2100, A0);
    op1 = fr.mul(-2100, A1);
    op2 = fr.mul(-2100, A2);
    op3 = fr.mul(-2100, A3);
    op4 = fr.mul(-2100, A4);
    op5 = fr.mul(-2100, A5);
    op6 = fr.mul(-2100, A6);
    op7 = fr.mul(-2100, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2419 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2420: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2421: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2422: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2423: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2426))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2423 << endl;
        exit(-1);
    }
    addrRel += 2426;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2424: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2424 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2425: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2425 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2426: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2427: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2428: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2429: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2436))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2429 << endl;
        exit(-1);
    }
    addrRel += 2436;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2430: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2431: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2432: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2433: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2468))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2433 << endl;
        exit(-1);
    }
    addrRel += 2468;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2434: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(20000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2434 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2435: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2435 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2436: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2436 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2437: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2438: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2439: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2440: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2451))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2440 << endl;
        exit(-1);
    }
    addrRel += 2451;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2441: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2442: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2443: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2444: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2444 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2445: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2446: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2447: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2465))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2447 << endl;
        exit(-1);
    }
    addrRel += 2465;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2448: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2448 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2449: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 19900);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2449 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2450: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2450 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2451: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2452: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2453: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2454: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2454 << endl;
        exit(-1);
    }
    addrRel += 2458;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2455: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2455 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2456: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2456 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2457: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2441))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2457 << endl;
        exit(-1);
    }
    addrRel += 2441;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2458: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2459: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2460: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2461: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2441))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2461 << endl;
        exit(-1);
    }
    addrRel += 2441;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2462: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2462 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2463: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15000);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2463 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2464: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2441))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2464 << endl;
        exit(-1);
    }
    addrRel += 2441;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2465: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2465 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2466: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 2800);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2466 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2467: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2467 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2468: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2900));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2468 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2469: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2470: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2471: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2472: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2472 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2473: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2473 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2474: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15000);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2474 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2475: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2476))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2475 << endl;
        exit(-1);
    }
    addrRel += 2476;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2476: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2476 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2477: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2480))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2477 << endl;
        exit(-1);
    }
    addrRel += 2480;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2478: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2478 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2479: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2481))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2479 << endl;
        exit(-1);
    }
    addrRel += 2481;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2480: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2480 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2481: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2482: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2482 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2483: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2484: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2485: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2485 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2486: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2486 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2487: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2488: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2489: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2489 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2490: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2490 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2491: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2491 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2492: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2493: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2493 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2494: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2495: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2496: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2496 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2497: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2498: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2499: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2500: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2500 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2501: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2501 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2502: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2503: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2503 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2504: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2504 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2505: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2505 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2506: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2506 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2507: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2508: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2508 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2509: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2509 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2510: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2510 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2511: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2512: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2512 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2513: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2513 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2514: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2514 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2515: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2515 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2516: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2517: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2518: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2518 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2519: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = fr.add(op0, PC);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2520: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2520 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2521: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2521 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2522: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2522 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2523: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2523 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2524: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2524 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2525: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2525 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2526: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2527;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1459))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2526 << endl;
        exit(-1);
    }
    addrRel += 1459;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2527: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2527 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2528: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2528 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2529: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = fr.add(op0, SP);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2530: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2539))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2530 << endl;
        exit(-1);
    }
    addrRel += 2539;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2531: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2532: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2532 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2533: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2534: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2535: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2535 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2536: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = fr.add(op0, PC);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2537: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2537 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2538: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2538 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2539: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2540: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2541: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2542: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2543: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2544: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = fr.add(op0, PC);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2545: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2546: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2547: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2548: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2549;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1484))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2548 << endl;
        exit(-1);
    }
    addrRel += 1484;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2549: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2549 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2550: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2551: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2551 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2552: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2552 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2553: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2553 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2554: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2555: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2555 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2556: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2556 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2557: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2557 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2558: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2559: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2559 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2560: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2560 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2561: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2561 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2562: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2563: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2563 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2564: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2564 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2565: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2565 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2566: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 4;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2567: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2567 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2568: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2568 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2569: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2569 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2570: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 5;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2571: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2571 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2572: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2572 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2573: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2573 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2574: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 6;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2575: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2575 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2576: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2576 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2577: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2577 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2578: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 7;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2579: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2579 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2580: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2580 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2581: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2581 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2582: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2583: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2583 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2584: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2584 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2585: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2585 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2586: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 9;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2587: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2587 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2588: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2588 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2589: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2589 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2590: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 10;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2591: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2591 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2592: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2592 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2593: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2593 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2594: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 11;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2595: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2595 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2596: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2596 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2597: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2597 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2598: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 12;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2599: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2599 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2600: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2600 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2601: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2601 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2602: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 13;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2603: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2603 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2604: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2604 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2605: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2605 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2606: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 14;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2607: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2607 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2608: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2608 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2609: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2609 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2610: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 15;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2611: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2611 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2612: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2612 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2613: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2613 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2614: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 16;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2615: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2615 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2616: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2616 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2617: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2617 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2618: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 17;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2619: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2619 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2620: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2620 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2621: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2621 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2622: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 18;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2623: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2623 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2624: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2624 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2625: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2625 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2626: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 19;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2627: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2627 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2628: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2628 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2629: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2629 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2630: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2631: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2631 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2632: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2632 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2633: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2633 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2634: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 21;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2635: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2635 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2636: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2636 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2637: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2637 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2638: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 22;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2639: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2639 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2640: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2640 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2641: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2641 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2642: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 23;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2643: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2643 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2644: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2644 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2645: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2645 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2646: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 24;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2647: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2647 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2648: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2648 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2649: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2649 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2650: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 25;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2651: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2651 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2652: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2652 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2653: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2653 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2654: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 26;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2655: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2655 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2656: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2656 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2657: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2657 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2658: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 27;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2659: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2659 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2660: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2660 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2661: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2661 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2662: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 28;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2663: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2663 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2664: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2664 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2665: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2665 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2666: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 29;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2667: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2667 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2668: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2668 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2669: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2669 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2670: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 30;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2671: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2671 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2672: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2672 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2673: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2673 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2674: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 31;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2675: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2675 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2676: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2676 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2677: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2677 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2678: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2679: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2679 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2680: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2522))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2680 << endl;
        exit(-1);
    }
    addrRel += 2522;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2681: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2516))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2681 << endl;
        exit(-1);
    }
    addrRel += 2516;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2682: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2682 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2683: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2684: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2684 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2685: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2686: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2686 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2687: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2687 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2688: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2688 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2689: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2689 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2690: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2691: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 2);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2692: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2693: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2693 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2694: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2694 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2695: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2695 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2696: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2696 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2697: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2698: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 3);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2699: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2700: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2700 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2701: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2701 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2702: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2702 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2703: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2703 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2704: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2705: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 4);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2706: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2707: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2707 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2708: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2708 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2709: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2709 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2710: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2710 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2711: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2712: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 5);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2713: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2714: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2714 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2715: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2715 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2716: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2716 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2717: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2717 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2718: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2719: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 6);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2720: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2721: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2721 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2722: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2722 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2723: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2723 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2724: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2724 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2725: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2726: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 7);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2727: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2728: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2728 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2729: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2729 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2730: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2730 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2731: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2731 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2732: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2733: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 8);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2734: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2735: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2735 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2736: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2736 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2737: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2737 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2738: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2738 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2739: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2740: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 9);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2741: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2742: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2742 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2743: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2743 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2744: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2744 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2745: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2745 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2746: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2747: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 10);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2748: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2749: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2749 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2750: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2750 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2751: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2751 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2752: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(11));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2752 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2753: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2754: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 11);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2755: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2756: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2756 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2757: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2757 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2758: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2758 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2759: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(12));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2759 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2760: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2761: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 12);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2762: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2763: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2763 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2764: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2764 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2765: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2765 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2766: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(13));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2766 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2767: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2768: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 13);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2769: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2770: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2770 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2771: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2771 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2772: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2772 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2773: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(14));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2773 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2774: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2775: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 14);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2776: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2777: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2777 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2778: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2778 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2779: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2779 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2780: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2780 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2781: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2782: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2783: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2784: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2784 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2785: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2785 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2786: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2786 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2787: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2787 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2788: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2789: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 16);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2790: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2791: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2791 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2792: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2792 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2793: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2793 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2794: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2794 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2795: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2796: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2797: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2798: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2799: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2799 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2800: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2801: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2801 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2802: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2802 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2803: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2803 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2804: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2804 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2805: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2806: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2807: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2808: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2809: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2810: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 2);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2811: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2812: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2812 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2813: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2813 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2814: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2814 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2815: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2815 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2816: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2817: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2818: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2819: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2820: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2821: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 3);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2822: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2823: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2823 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2824: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2824 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2825: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2825 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2826: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2826 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2827: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2828: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2829: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2830: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2831: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2832: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 4);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2833: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2834: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2834 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2835: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2835 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2836: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2836 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2837: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2837 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2838: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2839: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2840: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2841: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2842: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2843: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 5);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2844: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2845: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2845 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2846: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2846 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2847: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2847 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2848: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2848 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2849: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2850: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2851: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2852: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2853: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2854: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 6);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2855: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2856: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2856 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2857: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2857 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2858: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2858 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2859: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2859 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2860: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2861: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2862: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2863: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2864: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2865: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 7);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2866: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2867: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2867 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2868: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2868 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2869: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2869 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2870: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2870 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2871: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2872: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2873: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2874: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2875: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2876: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 8);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2877: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2878: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2878 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2879: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2879 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2880: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2880 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2881: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2881 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2882: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2883: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2884: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2885: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2886: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2887: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 9);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2888: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2889: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2889 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2890: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2890 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2891: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2891 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2892: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(11));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2892 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2893: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2894: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2895: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2896: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2897: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2898: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 10);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2899: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2900: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2900 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2901: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2901 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2902: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2902 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2903: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(12));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2903 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2904: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2905: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2906: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(11));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2907: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2908: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2909: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 11);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2910: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2911: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2911 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2912: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2912 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2913: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2913 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2914: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(13));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2914 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2915: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2916: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2917: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(12));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2918: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2919: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2920: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 12);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2921: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2922: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2922 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2923: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2923 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2924: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2924 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2925: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(14));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2925 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2926: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2927: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2928: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(13));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2929: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2930: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2931: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 13);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2932: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2933: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2933 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2934: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2934 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2935: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2935 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2936: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2936 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2937: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2938: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2939: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(14));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2940: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2941: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2942: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 14);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2943: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2944: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2944 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2945: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2945 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2946: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2946 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2947: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2947 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2948: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2949: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2950: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2951: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2952: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2953: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2954: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2955: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2955 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2956: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2956 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2957: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2957 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2958: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(17));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2958 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2959: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2960: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2961: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2962: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2963: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2964: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 16);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2965: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2966: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2966 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2967: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2967 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2968: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2968 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2969: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2969 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2970: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2970 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2971: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2971 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2972: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2973: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2974: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2975: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2975 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2976: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2976 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2977: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2977 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2978: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2978 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2979: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2979 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2980: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2980 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2981: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2981 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2982: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2982 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2983: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2983 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2984: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2984 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2985: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2986: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2987: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2988: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2988 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2989: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2989 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2990: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2990 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2991: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2991 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine2992: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2992 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2993: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2993 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2994: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2994 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2995: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2995 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2996: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2996 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2997: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2997 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2998: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine2999: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3000: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3001: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3001 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3002: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3002 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3003: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3003 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3004: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3004 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3005: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3005 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3006: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3006 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3007: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3007 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3008: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3008 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3009: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3009 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3010: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3010 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3011: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3012: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3013: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3014: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3014 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3015: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3015 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3016: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3016 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3017: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3017 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3018: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3018 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3019: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3019 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3020: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3020 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3021: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3021 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3022: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3022 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3023: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3023 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3024: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3025: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3026: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3027: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3027 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3028: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 4;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3028 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3029: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3029 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3030: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3030 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3031: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3031 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3032: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3032 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3033: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3033 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3034: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3042))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3034 << endl;
        exit(-1);
    }
    addrRel += 3042;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3035: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3040))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3035 << endl;
        exit(-1);
    }
    addrRel += 3040;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3036: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3037;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3036 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3037: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3038: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3039: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3034))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3039 << endl;
        exit(-1);
    }
    addrRel += 3034;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3040: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3041;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3040 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3041: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3042: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3042 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3043: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3050))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3043 << endl;
        exit(-1);
    }
    addrRel += 3050;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3044: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3044 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3045: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3045 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3046: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3047: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3048: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3049: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3043))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3049 << endl;
        exit(-1);
    }
    addrRel += 3043;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3050: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3050 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3051: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3051 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3052: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3052 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3053: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3053 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3054: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3054 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3055: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3055 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3056: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3056 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3057: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3058: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3059: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3059 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3060: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3061: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3061 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3062: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3063: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3063 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3064: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3064 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3065: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3065 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3066: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3066 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3067: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3067 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3068: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3068 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3069: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3069 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3070: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3070 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3071: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3071 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3072: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3072 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3073: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3073 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3074: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3074 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3075: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3075 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3076: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3076 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3077: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3078: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3079;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3078 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3079: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3079 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3080: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3080 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3081: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3081 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3082: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3083: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3083 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3084: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3084 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3085: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3086;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3085 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3086: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3087: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3088: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3089: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3090: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3090 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3091: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3092: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3093: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3094: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3095: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3095 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3096: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3097;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1212))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3096 << endl;
        exit(-1);
    }
    addrRel += 1212;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3097: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3097 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3098: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3098 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3099: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3099 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3100: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3100 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3101: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3101 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3102: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3102 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3103: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3103 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3104: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3105: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3105 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3106: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3107: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3107 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3108: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3109: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3109 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3110: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3111: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3111 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3112: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3112 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3113: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3115))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3113 << endl;
        exit(-1);
    }
    addrRel += 3115;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3114: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3114 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3115: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3116: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3116 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3117: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3118: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3118 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3119: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3120: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3121: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3121 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3122: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3123: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3123 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3124: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3125: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3126: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3128))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3126 << endl;
        exit(-1);
    }
    addrRel += 3128;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3127: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3128: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3129: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3129 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3130: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3132))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3130 << endl;
        exit(-1);
    }
    addrRel += 3132;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3131: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3132;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3131 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3132: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3132 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3133: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3133 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3134: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3134 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3135: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3135 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3136: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3136 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3137: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3137 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3138: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3138 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3139: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3139 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3140: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3140 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3141: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3141 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3142: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3142 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3143: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3143 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3144: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3145: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3145 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3146: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3146 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3147: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3147 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3148: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3149: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3149 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3150: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3150 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3151: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3151 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3152: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3153: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3155))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3153 << endl;
        exit(-1);
    }
    addrRel += 3155;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3154: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3154 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3155: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3156;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3155 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3156: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3156 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3157: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3157 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3158: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3158 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3159: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3160: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3160 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3161: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3161 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3162: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3162 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3163: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3163 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3164: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3165;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3164 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3165: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3165 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3166: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3166 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3167: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3168: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3168 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3169: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3170: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3170 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3171: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3172: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3172 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3173: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3174: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3174 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3175: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3176: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3176 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3177: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3178: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3178 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3179: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3180: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3181: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3181 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3182: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3183: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3183 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3184: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3185: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3186: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3188))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3186 << endl;
        exit(-1);
    }
    addrRel += 3188;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3187: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3188: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3189: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3189 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3190: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3192))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3190 << endl;
        exit(-1);
    }
    addrRel += 3192;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3191: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3192;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3191 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3192: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3192 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3193: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3193 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3194: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3194 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3195: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3195 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3196: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3196 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3197: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3197 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3198: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3198 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3199: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3199 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3200: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3200 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3201: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3201 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3202: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3202 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3203: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3203 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3204: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3204 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3205: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3205 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3206: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3206 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3207: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3208: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3208 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3209: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3209 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3210: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3211: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3211 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3212: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3212 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3213: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3213 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3214: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3216))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3214 << endl;
        exit(-1);
    }
    addrRel += 3216;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3215: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3215 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3216: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3217;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3216 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3217: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3217 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3218: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3218 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3219: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3219 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3220: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3221: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3221 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3222: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3222 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3223: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3223 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3224: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3224 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3225: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3226;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3225 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3226: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3226 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3227: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3227 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3228: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3229: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3230: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3231: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3231 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3232: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3232 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3233: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3276))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3233 << endl;
        exit(-1);
    }
    addrRel += 3276;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3234: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3234 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3235: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3272))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3235 << endl;
        exit(-1);
    }
    addrRel += 3272;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3236: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3236 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3237: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3237 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3238: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3238 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3239: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3239 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3240: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3240 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3241: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3241 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3242: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3242 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3243: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3243 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3244: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3244 << endl;
        exit(-1);
    }
    addrRel += 3263;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3245: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3257))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3245 << endl;
        exit(-1);
    }
    addrRel += 3257;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3246: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3247;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3246 << endl;
        exit(-1);
    }
    addrRel += 1309;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3247: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3248: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3248 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3249: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3250: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3250 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3251: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3252;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1228))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3251 << endl;
        exit(-1);
    }
    addrRel += 1228;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3252: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3253: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3254: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3255: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3255 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3256: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3244))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3256 << endl;
        exit(-1);
    }
    addrRel += 3244;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3257: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3258;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1341))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3257 << endl;
        exit(-1);
    }
    addrRel += 1341;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3258: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3258 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3259: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3260: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3260 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3261: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3262;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1263))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3261 << endl;
        exit(-1);
    }
    addrRel += 1263;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3262: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3262 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3263: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3263 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3264: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3264 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3265: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3265 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3266: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3267: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3267 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3268: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3268 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3269: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3269 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3270: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3270 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3271: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3271 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3272: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3272 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3273: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3273 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3274: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2374))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3274 << endl;
        exit(-1);
    }
    addrRel += 2374;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3275: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3275 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3276: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-200
    op0 = fr.mul(-200, C0);
    op1 = fr.mul(-200, C1);
    op2 = fr.mul(-200, C2);
    op3 = fr.mul(-200, C3);
    op4 = fr.mul(-200, C4);
    op5 = fr.mul(-200, C5);
    op6 = fr.mul(-200, C6);
    op7 = fr.mul(-200, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3276 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3277: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3277 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3278: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3280))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3278 << endl;
        exit(-1);
    }
    addrRel += 3280;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3279: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3279 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3280: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3280 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3281: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3281 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3282: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3282 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3283: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3283 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3284: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3284 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3285: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3285 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3286: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3286 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3287: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3287 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3288: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3288 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3289: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3289 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3290: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3290 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3291: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3292: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3293: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3294: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3295: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3296: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3297: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3298: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3299: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3299 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3300: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3301: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3322))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3301 << endl;
        exit(-1);
    }
    addrRel += 3322;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3302: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3302 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3303: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3304: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3305: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3305 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3306: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1136))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3306 << endl;
        exit(-1);
    }
    addrRel += 1136;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3307: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3308: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3308 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3309: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3310: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3311: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3311 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3312: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3313: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3314: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3314 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3315: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3315 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3316: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3316 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3317: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3318;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3317 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3318: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3318 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3319: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3319 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3320: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3321: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3322: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3322 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3323: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3323 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3324: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3325: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3325 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3326: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3326 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3327: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3328: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3328 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3329: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3329 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3330: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3330 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3331: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3332: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3332 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3333: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3334: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3334 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3335: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3336: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3336 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3337: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3338: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3338 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3339: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3340: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3340 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3341: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3342: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3343: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3343 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3344: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3345: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3345 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3346: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3347: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3348: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3350))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3348 << endl;
        exit(-1);
    }
    addrRel += 3350;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3349: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3350: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3351: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3351 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3352: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3354))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3352 << endl;
        exit(-1);
    }
    addrRel += 3354;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3353: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3354;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3353 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3354: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3354 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3355: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3355 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3356: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3356 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3357: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3357 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3358: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3358 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3359: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3359 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3360: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3360 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3361: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3361 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3362: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3362 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3363: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3363 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3364: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3364 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3365: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3365 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3366: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3366 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3367: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3367 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3368: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3368 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3369: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3370: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3370 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3371: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3371 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3372: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3372 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3373: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3374: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3374 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3375: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3376;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3375 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3376: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3376 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3377: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3377 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3378: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3378 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3379: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3380: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3380 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3381: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3381 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3382: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3382 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3383: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3383 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3384: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3385;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3384 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3385: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3385 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3386: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3386 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3387: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3387 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3388: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3388 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3389: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3390: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3391: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3391 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3392: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3393: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3393 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3394: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3395: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3395 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3396: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3397: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3397 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3398: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3398 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3399: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3399 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3400: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3400 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3401: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3401 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3402: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3402 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3403: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3403 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3404: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3404 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3405: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3405 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3406: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3406 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3407: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3407 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3408: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3408 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3409: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(36))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3409 << endl;
        exit(-1);
    }
    addrRel += 36;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3410: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3410 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3411: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3411 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3412: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3413: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3414;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3413 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3414: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3414 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3415: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3415 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3416: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3416 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3417: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3418: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3418 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3419: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3419 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3420: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3421;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3420 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3421: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3422: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3423: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3424: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3425: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3425 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3426: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3427: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3428: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3429: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3430: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3430 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3431: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3432;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1212))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3431 << endl;
        exit(-1);
    }
    addrRel += 1212;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3432: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3432 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3433: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3433 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3434: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3434 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3435: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3435 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3436: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3436 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3437: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3437 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3438: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3438 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3439: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3440: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3440 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3441: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3442: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3442 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3443: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3444: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3444 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3445: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3446: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3446 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3447: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3448: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3448 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3449: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3450: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3451: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3451 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3452: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3453: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3453 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3454: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3455: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3456: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3456 << endl;
        exit(-1);
    }
    addrRel += 3458;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3457: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3458: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3459: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3459 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3460: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3462))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3460 << endl;
        exit(-1);
    }
    addrRel += 3462;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3461: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3462;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1420))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3461 << endl;
        exit(-1);
    }
    addrRel += 1420;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3462: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3462 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3463: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3463 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3464: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3464 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3465: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3465 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3466: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3466 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3467: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3467 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3468: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3468 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3469: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3469 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3470: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3470 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3471: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3471 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3472: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3472 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3473: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3473 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3474: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3474 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3475: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3475 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3476: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3477: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3477 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3478: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3478 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3479: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3479 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3480: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3481: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3481 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3482: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3483;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1407))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3482 << endl;
        exit(-1);
    }
    addrRel += 1407;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3483: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3483 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3484: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3484 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3485: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3485 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3486: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3487: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3487 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3488: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3488 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3489: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3489 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3490: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3490 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3491: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3492;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1146))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3491 << endl;
        exit(-1);
    }
    addrRel += 1146;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3492: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(926))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3492 << endl;
        exit(-1);
    }
    addrRel += 926;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3493: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3493 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3494: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3494 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3495: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3496: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3497: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3498: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3498 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3499: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3508))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3499 << endl;
        exit(-1);
    }
    addrRel += 3508;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3500: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3501: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3501 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3502: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3502 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3503: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3503 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3504: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3504 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3505: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3506: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3506 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3507: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3507 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3508: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3508 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3509: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3509 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3510: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3547))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3510 << endl;
        exit(-1);
    }
    addrRel += 3547;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3511: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 24000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3511 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3512: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3512 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3513: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3513 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3514: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3515: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3516: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3517: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3518: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3519: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3520: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3521: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3522: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3522 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3523: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3524: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3525: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3526;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1377))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3525 << endl;
        exit(-1);
    }
    addrRel += 1377;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3526: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=-25000
    op0 = fr.mul(-25000, E0);
    op1 = fr.mul(-25000, E1);
    op2 = fr.mul(-25000, E2);
    op3 = fr.mul(-25000, E3);
    op4 = fr.mul(-25000, E4);
    op5 = fr.mul(-25000, E5);
    op6 = fr.mul(-25000, E6);
    op7 = fr.mul(-25000, E7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3526 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3527: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3528: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=-2600
    op0 = fr.mul(-2600, E0);
    op1 = fr.mul(-2600, E1);
    op2 = fr.mul(-2600, E2);
    op3 = fr.mul(-2600, E3);
    op4 = fr.mul(-2600, E4);
    op5 = fr.mul(-2600, E5);
    op6 = fr.mul(-2600, E6);
    op7 = fr.mul(-2600, E7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1571))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3528 << endl;
        exit(-1);
    }
    addrRel += 1571;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3529: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3530: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3531: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3531 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3532: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3532 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3533: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3534;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1430))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3533 << endl;
        exit(-1);
    }
    addrRel += 1430;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3534: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3534 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3535: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3536: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3537: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3538: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3538 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3539: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3540: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3540 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3541: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3541 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3542: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3543: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3543 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3544: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3544 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3545: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3545 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3546: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1057))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3546 << endl;
        exit(-1);
    }
    addrRel += 1057;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3547: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3547 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3548: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3548 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3549: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op

RomLine3550: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3550 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3551: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3551 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3552: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3553: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1583))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3553 << endl;
        exit(-1);
    }
    addrRel += 1583;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

RomLine3554: //

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1054))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3554 << endl;
        exit(-1);
    }
    addrRel += 1054;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;

}
