#include "main_exec_generated_fast.hpp"

#define MEM_OFFSET 0x30000
#define STACK_OFFSET 0x20000
#define CODE_OFFSET 0x10000
#define CTX_OFFSET 0x40000

vector<void *> main_exec_generated_fast_labels;
void main_exec_generated_fast (FiniteField &fr, const Input &input, Database &db, Counters &counters)
{
    // opN are local, uncommitted polynomials
    FieldElement op0, op1, op2, op3, op4, op5, op6, op7;
    FieldElement A0, A1, A2, A3, A4, A5, A6, A7;
    A7 = A6 = A5 = A4 = A3 = A2 = A1 = A0 = fr.zero();
    FieldElement B0, B1, B2, B3, B4, B5, B6, B7;
    B7 = B6 = B5 = B4 = B3 = B2 = B1 = B0 = fr.zero();
    FieldElement C0, C1, C2, C3, C4, C5, C6, C7;
    C7 = C6 = C5 = C4 = C3 = C2 = C1 = C0 = fr.zero();
    FieldElement D0, D1, D2, D3, D4, D5, D6, D7;
    D7 = D6 = D5 = D4 = D3 = D2 = D1 = D0 = fr.zero();
    FieldElement E0, E1, E2, E3, E4, E5, E6, E7;
    E7 = E6 = E5 = E4 = E3 = E2 = E1 = E0 = fr.zero();
    FieldElement SR0, SR1, SR2, SR3, SR4, SR5, SR6, SR7;
    SR7 = SR6 = SR5 = SR4 = SR3 = SR2 = SR1 = SR0 = fr.zero();
    FieldElement HASHPOS, GAS, CTX, PC, SP, RR, carry, MAXMEM;
    HASHPOS = GAS = CTX = PC = SP = RR = carry = MAXMEM = fr.zero();
     uint32_t addrRel = 0; // Relative and absolute address auxiliary variables
     uint64_t addr = 0;
     int64_t i=-1; // Number of this evaluation
    int64_t N=1<<23;
    int64_t o;
    int64_t maxMemCalculated;
    int64_t mm;
    int64_t incHashPos = 0;

   if (main_exec_generated_fast_labels.size()==0)
    {
        main_exec_generated_fast_labels.push_back(&&RomLine0);
        main_exec_generated_fast_labels.push_back(&&RomLine1);
        main_exec_generated_fast_labels.push_back(&&RomLine2);
        main_exec_generated_fast_labels.push_back(&&RomLine3);
        main_exec_generated_fast_labels.push_back(&&RomLine4);
        main_exec_generated_fast_labels.push_back(&&RomLine5);
        main_exec_generated_fast_labels.push_back(&&RomLine6);
        main_exec_generated_fast_labels.push_back(&&RomLine7);
        main_exec_generated_fast_labels.push_back(&&RomLine8);
        main_exec_generated_fast_labels.push_back(&&RomLine9);
        main_exec_generated_fast_labels.push_back(&&RomLine10);
        main_exec_generated_fast_labels.push_back(&&RomLine11);
        main_exec_generated_fast_labels.push_back(&&RomLine12);
        main_exec_generated_fast_labels.push_back(&&RomLine13);
        main_exec_generated_fast_labels.push_back(&&RomLine14);
        main_exec_generated_fast_labels.push_back(&&RomLine15);
        main_exec_generated_fast_labels.push_back(&&RomLine16);
        main_exec_generated_fast_labels.push_back(&&RomLine17);
        main_exec_generated_fast_labels.push_back(&&RomLine18);
        main_exec_generated_fast_labels.push_back(&&RomLine19);
        main_exec_generated_fast_labels.push_back(&&RomLine20);
        main_exec_generated_fast_labels.push_back(&&RomLine21);
        main_exec_generated_fast_labels.push_back(&&RomLine22);
        main_exec_generated_fast_labels.push_back(&&RomLine23);
        main_exec_generated_fast_labels.push_back(&&RomLine24);
        main_exec_generated_fast_labels.push_back(&&RomLine25);
        main_exec_generated_fast_labels.push_back(&&RomLine26);
        main_exec_generated_fast_labels.push_back(&&RomLine27);
        main_exec_generated_fast_labels.push_back(&&RomLine28);
        main_exec_generated_fast_labels.push_back(&&RomLine29);
        main_exec_generated_fast_labels.push_back(&&RomLine30);
        main_exec_generated_fast_labels.push_back(&&RomLine31);
        main_exec_generated_fast_labels.push_back(&&RomLine32);
        main_exec_generated_fast_labels.push_back(&&RomLine33);
        main_exec_generated_fast_labels.push_back(&&RomLine34);
        main_exec_generated_fast_labels.push_back(&&RomLine35);
        main_exec_generated_fast_labels.push_back(&&RomLine36);
        main_exec_generated_fast_labels.push_back(&&RomLine37);
        main_exec_generated_fast_labels.push_back(&&RomLine38);
        main_exec_generated_fast_labels.push_back(&&RomLine39);
        main_exec_generated_fast_labels.push_back(&&RomLine40);
        main_exec_generated_fast_labels.push_back(&&RomLine41);
        main_exec_generated_fast_labels.push_back(&&RomLine42);
        main_exec_generated_fast_labels.push_back(&&RomLine43);
        main_exec_generated_fast_labels.push_back(&&RomLine44);
        main_exec_generated_fast_labels.push_back(&&RomLine45);
        main_exec_generated_fast_labels.push_back(&&RomLine46);
        main_exec_generated_fast_labels.push_back(&&RomLine47);
        main_exec_generated_fast_labels.push_back(&&RomLine48);
        main_exec_generated_fast_labels.push_back(&&RomLine49);
        main_exec_generated_fast_labels.push_back(&&RomLine50);
        main_exec_generated_fast_labels.push_back(&&RomLine51);
        main_exec_generated_fast_labels.push_back(&&RomLine52);
        main_exec_generated_fast_labels.push_back(&&RomLine53);
        main_exec_generated_fast_labels.push_back(&&RomLine54);
        main_exec_generated_fast_labels.push_back(&&RomLine55);
        main_exec_generated_fast_labels.push_back(&&RomLine56);
        main_exec_generated_fast_labels.push_back(&&RomLine57);
        main_exec_generated_fast_labels.push_back(&&RomLine58);
        main_exec_generated_fast_labels.push_back(&&RomLine59);
        main_exec_generated_fast_labels.push_back(&&RomLine60);
        main_exec_generated_fast_labels.push_back(&&RomLine61);
        main_exec_generated_fast_labels.push_back(&&RomLine62);
        main_exec_generated_fast_labels.push_back(&&RomLine63);
        main_exec_generated_fast_labels.push_back(&&RomLine64);
        main_exec_generated_fast_labels.push_back(&&RomLine65);
        main_exec_generated_fast_labels.push_back(&&RomLine66);
        main_exec_generated_fast_labels.push_back(&&RomLine67);
        main_exec_generated_fast_labels.push_back(&&RomLine68);
        main_exec_generated_fast_labels.push_back(&&RomLine69);
        main_exec_generated_fast_labels.push_back(&&RomLine70);
        main_exec_generated_fast_labels.push_back(&&RomLine71);
        main_exec_generated_fast_labels.push_back(&&RomLine72);
        main_exec_generated_fast_labels.push_back(&&RomLine73);
        main_exec_generated_fast_labels.push_back(&&RomLine74);
        main_exec_generated_fast_labels.push_back(&&RomLine75);
        main_exec_generated_fast_labels.push_back(&&RomLine76);
        main_exec_generated_fast_labels.push_back(&&RomLine77);
        main_exec_generated_fast_labels.push_back(&&RomLine78);
        main_exec_generated_fast_labels.push_back(&&RomLine79);
        main_exec_generated_fast_labels.push_back(&&RomLine80);
        main_exec_generated_fast_labels.push_back(&&RomLine81);
        main_exec_generated_fast_labels.push_back(&&RomLine82);
        main_exec_generated_fast_labels.push_back(&&RomLine83);
        main_exec_generated_fast_labels.push_back(&&RomLine84);
        main_exec_generated_fast_labels.push_back(&&RomLine85);
        main_exec_generated_fast_labels.push_back(&&RomLine86);
        main_exec_generated_fast_labels.push_back(&&RomLine87);
        main_exec_generated_fast_labels.push_back(&&RomLine88);
        main_exec_generated_fast_labels.push_back(&&RomLine89);
        main_exec_generated_fast_labels.push_back(&&RomLine90);
        main_exec_generated_fast_labels.push_back(&&RomLine91);
        main_exec_generated_fast_labels.push_back(&&RomLine92);
        main_exec_generated_fast_labels.push_back(&&RomLine93);
        main_exec_generated_fast_labels.push_back(&&RomLine94);
        main_exec_generated_fast_labels.push_back(&&RomLine95);
        main_exec_generated_fast_labels.push_back(&&RomLine96);
        main_exec_generated_fast_labels.push_back(&&RomLine97);
        main_exec_generated_fast_labels.push_back(&&RomLine98);
        main_exec_generated_fast_labels.push_back(&&RomLine99);
        main_exec_generated_fast_labels.push_back(&&RomLine100);
        main_exec_generated_fast_labels.push_back(&&RomLine101);
        main_exec_generated_fast_labels.push_back(&&RomLine102);
        main_exec_generated_fast_labels.push_back(&&RomLine103);
        main_exec_generated_fast_labels.push_back(&&RomLine104);
        main_exec_generated_fast_labels.push_back(&&RomLine105);
        main_exec_generated_fast_labels.push_back(&&RomLine106);
        main_exec_generated_fast_labels.push_back(&&RomLine107);
        main_exec_generated_fast_labels.push_back(&&RomLine108);
        main_exec_generated_fast_labels.push_back(&&RomLine109);
        main_exec_generated_fast_labels.push_back(&&RomLine110);
        main_exec_generated_fast_labels.push_back(&&RomLine111);
        main_exec_generated_fast_labels.push_back(&&RomLine112);
        main_exec_generated_fast_labels.push_back(&&RomLine113);
        main_exec_generated_fast_labels.push_back(&&RomLine114);
        main_exec_generated_fast_labels.push_back(&&RomLine115);
        main_exec_generated_fast_labels.push_back(&&RomLine116);
        main_exec_generated_fast_labels.push_back(&&RomLine117);
        main_exec_generated_fast_labels.push_back(&&RomLine118);
        main_exec_generated_fast_labels.push_back(&&RomLine119);
        main_exec_generated_fast_labels.push_back(&&RomLine120);
        main_exec_generated_fast_labels.push_back(&&RomLine121);
        main_exec_generated_fast_labels.push_back(&&RomLine122);
        main_exec_generated_fast_labels.push_back(&&RomLine123);
        main_exec_generated_fast_labels.push_back(&&RomLine124);
        main_exec_generated_fast_labels.push_back(&&RomLine125);
        main_exec_generated_fast_labels.push_back(&&RomLine126);
        main_exec_generated_fast_labels.push_back(&&RomLine127);
        main_exec_generated_fast_labels.push_back(&&RomLine128);
        main_exec_generated_fast_labels.push_back(&&RomLine129);
        main_exec_generated_fast_labels.push_back(&&RomLine130);
        main_exec_generated_fast_labels.push_back(&&RomLine131);
        main_exec_generated_fast_labels.push_back(&&RomLine132);
        main_exec_generated_fast_labels.push_back(&&RomLine133);
        main_exec_generated_fast_labels.push_back(&&RomLine134);
        main_exec_generated_fast_labels.push_back(&&RomLine135);
        main_exec_generated_fast_labels.push_back(&&RomLine136);
        main_exec_generated_fast_labels.push_back(&&RomLine137);
        main_exec_generated_fast_labels.push_back(&&RomLine138);
        main_exec_generated_fast_labels.push_back(&&RomLine139);
        main_exec_generated_fast_labels.push_back(&&RomLine140);
        main_exec_generated_fast_labels.push_back(&&RomLine141);
        main_exec_generated_fast_labels.push_back(&&RomLine142);
        main_exec_generated_fast_labels.push_back(&&RomLine143);
        main_exec_generated_fast_labels.push_back(&&RomLine144);
        main_exec_generated_fast_labels.push_back(&&RomLine145);
        main_exec_generated_fast_labels.push_back(&&RomLine146);
        main_exec_generated_fast_labels.push_back(&&RomLine147);
        main_exec_generated_fast_labels.push_back(&&RomLine148);
        main_exec_generated_fast_labels.push_back(&&RomLine149);
        main_exec_generated_fast_labels.push_back(&&RomLine150);
        main_exec_generated_fast_labels.push_back(&&RomLine151);
        main_exec_generated_fast_labels.push_back(&&RomLine152);
        main_exec_generated_fast_labels.push_back(&&RomLine153);
        main_exec_generated_fast_labels.push_back(&&RomLine154);
        main_exec_generated_fast_labels.push_back(&&RomLine155);
        main_exec_generated_fast_labels.push_back(&&RomLine156);
        main_exec_generated_fast_labels.push_back(&&RomLine157);
        main_exec_generated_fast_labels.push_back(&&RomLine158);
        main_exec_generated_fast_labels.push_back(&&RomLine159);
        main_exec_generated_fast_labels.push_back(&&RomLine160);
        main_exec_generated_fast_labels.push_back(&&RomLine161);
        main_exec_generated_fast_labels.push_back(&&RomLine162);
        main_exec_generated_fast_labels.push_back(&&RomLine163);
        main_exec_generated_fast_labels.push_back(&&RomLine164);
        main_exec_generated_fast_labels.push_back(&&RomLine165);
        main_exec_generated_fast_labels.push_back(&&RomLine166);
        main_exec_generated_fast_labels.push_back(&&RomLine167);
        main_exec_generated_fast_labels.push_back(&&RomLine168);
        main_exec_generated_fast_labels.push_back(&&RomLine169);
        main_exec_generated_fast_labels.push_back(&&RomLine170);
        main_exec_generated_fast_labels.push_back(&&RomLine171);
        main_exec_generated_fast_labels.push_back(&&RomLine172);
        main_exec_generated_fast_labels.push_back(&&RomLine173);
        main_exec_generated_fast_labels.push_back(&&RomLine174);
        main_exec_generated_fast_labels.push_back(&&RomLine175);
        main_exec_generated_fast_labels.push_back(&&RomLine176);
        main_exec_generated_fast_labels.push_back(&&RomLine177);
        main_exec_generated_fast_labels.push_back(&&RomLine178);
        main_exec_generated_fast_labels.push_back(&&RomLine179);
        main_exec_generated_fast_labels.push_back(&&RomLine180);
        main_exec_generated_fast_labels.push_back(&&RomLine181);
        main_exec_generated_fast_labels.push_back(&&RomLine182);
        main_exec_generated_fast_labels.push_back(&&RomLine183);
        main_exec_generated_fast_labels.push_back(&&RomLine184);
        main_exec_generated_fast_labels.push_back(&&RomLine185);
        main_exec_generated_fast_labels.push_back(&&RomLine186);
        main_exec_generated_fast_labels.push_back(&&RomLine187);
        main_exec_generated_fast_labels.push_back(&&RomLine188);
        main_exec_generated_fast_labels.push_back(&&RomLine189);
        main_exec_generated_fast_labels.push_back(&&RomLine190);
        main_exec_generated_fast_labels.push_back(&&RomLine191);
        main_exec_generated_fast_labels.push_back(&&RomLine192);
        main_exec_generated_fast_labels.push_back(&&RomLine193);
        main_exec_generated_fast_labels.push_back(&&RomLine194);
        main_exec_generated_fast_labels.push_back(&&RomLine195);
        main_exec_generated_fast_labels.push_back(&&RomLine196);
        main_exec_generated_fast_labels.push_back(&&RomLine197);
        main_exec_generated_fast_labels.push_back(&&RomLine198);
        main_exec_generated_fast_labels.push_back(&&RomLine199);
        main_exec_generated_fast_labels.push_back(&&RomLine200);
        main_exec_generated_fast_labels.push_back(&&RomLine201);
        main_exec_generated_fast_labels.push_back(&&RomLine202);
        main_exec_generated_fast_labels.push_back(&&RomLine203);
        main_exec_generated_fast_labels.push_back(&&RomLine204);
        main_exec_generated_fast_labels.push_back(&&RomLine205);
        main_exec_generated_fast_labels.push_back(&&RomLine206);
        main_exec_generated_fast_labels.push_back(&&RomLine207);
        main_exec_generated_fast_labels.push_back(&&RomLine208);
        main_exec_generated_fast_labels.push_back(&&RomLine209);
        main_exec_generated_fast_labels.push_back(&&RomLine210);
        main_exec_generated_fast_labels.push_back(&&RomLine211);
        main_exec_generated_fast_labels.push_back(&&RomLine212);
        main_exec_generated_fast_labels.push_back(&&RomLine213);
        main_exec_generated_fast_labels.push_back(&&RomLine214);
        main_exec_generated_fast_labels.push_back(&&RomLine215);
        main_exec_generated_fast_labels.push_back(&&RomLine216);
        main_exec_generated_fast_labels.push_back(&&RomLine217);
        main_exec_generated_fast_labels.push_back(&&RomLine218);
        main_exec_generated_fast_labels.push_back(&&RomLine219);
        main_exec_generated_fast_labels.push_back(&&RomLine220);
        main_exec_generated_fast_labels.push_back(&&RomLine221);
        main_exec_generated_fast_labels.push_back(&&RomLine222);
        main_exec_generated_fast_labels.push_back(&&RomLine223);
        main_exec_generated_fast_labels.push_back(&&RomLine224);
        main_exec_generated_fast_labels.push_back(&&RomLine225);
        main_exec_generated_fast_labels.push_back(&&RomLine226);
        main_exec_generated_fast_labels.push_back(&&RomLine227);
        main_exec_generated_fast_labels.push_back(&&RomLine228);
        main_exec_generated_fast_labels.push_back(&&RomLine229);
        main_exec_generated_fast_labels.push_back(&&RomLine230);
        main_exec_generated_fast_labels.push_back(&&RomLine231);
        main_exec_generated_fast_labels.push_back(&&RomLine232);
        main_exec_generated_fast_labels.push_back(&&RomLine233);
        main_exec_generated_fast_labels.push_back(&&RomLine234);
        main_exec_generated_fast_labels.push_back(&&RomLine235);
        main_exec_generated_fast_labels.push_back(&&RomLine236);
        main_exec_generated_fast_labels.push_back(&&RomLine237);
        main_exec_generated_fast_labels.push_back(&&RomLine238);
        main_exec_generated_fast_labels.push_back(&&RomLine239);
        main_exec_generated_fast_labels.push_back(&&RomLine240);
        main_exec_generated_fast_labels.push_back(&&RomLine241);
        main_exec_generated_fast_labels.push_back(&&RomLine242);
        main_exec_generated_fast_labels.push_back(&&RomLine243);
        main_exec_generated_fast_labels.push_back(&&RomLine244);
        main_exec_generated_fast_labels.push_back(&&RomLine245);
        main_exec_generated_fast_labels.push_back(&&RomLine246);
        main_exec_generated_fast_labels.push_back(&&RomLine247);
        main_exec_generated_fast_labels.push_back(&&RomLine248);
        main_exec_generated_fast_labels.push_back(&&RomLine249);
        main_exec_generated_fast_labels.push_back(&&RomLine250);
        main_exec_generated_fast_labels.push_back(&&RomLine251);
        main_exec_generated_fast_labels.push_back(&&RomLine252);
        main_exec_generated_fast_labels.push_back(&&RomLine253);
        main_exec_generated_fast_labels.push_back(&&RomLine254);
        main_exec_generated_fast_labels.push_back(&&RomLine255);
        main_exec_generated_fast_labels.push_back(&&RomLine256);
        main_exec_generated_fast_labels.push_back(&&RomLine257);
        main_exec_generated_fast_labels.push_back(&&RomLine258);
        main_exec_generated_fast_labels.push_back(&&RomLine259);
        main_exec_generated_fast_labels.push_back(&&RomLine260);
        main_exec_generated_fast_labels.push_back(&&RomLine261);
        main_exec_generated_fast_labels.push_back(&&RomLine262);
        main_exec_generated_fast_labels.push_back(&&RomLine263);
        main_exec_generated_fast_labels.push_back(&&RomLine264);
        main_exec_generated_fast_labels.push_back(&&RomLine265);
        main_exec_generated_fast_labels.push_back(&&RomLine266);
        main_exec_generated_fast_labels.push_back(&&RomLine267);
        main_exec_generated_fast_labels.push_back(&&RomLine268);
        main_exec_generated_fast_labels.push_back(&&RomLine269);
        main_exec_generated_fast_labels.push_back(&&RomLine270);
        main_exec_generated_fast_labels.push_back(&&RomLine271);
        main_exec_generated_fast_labels.push_back(&&RomLine272);
        main_exec_generated_fast_labels.push_back(&&RomLine273);
        main_exec_generated_fast_labels.push_back(&&RomLine274);
        main_exec_generated_fast_labels.push_back(&&RomLine275);
        main_exec_generated_fast_labels.push_back(&&RomLine276);
        main_exec_generated_fast_labels.push_back(&&RomLine277);
        main_exec_generated_fast_labels.push_back(&&RomLine278);
        main_exec_generated_fast_labels.push_back(&&RomLine279);
        main_exec_generated_fast_labels.push_back(&&RomLine280);
        main_exec_generated_fast_labels.push_back(&&RomLine281);
        main_exec_generated_fast_labels.push_back(&&RomLine282);
        main_exec_generated_fast_labels.push_back(&&RomLine283);
        main_exec_generated_fast_labels.push_back(&&RomLine284);
        main_exec_generated_fast_labels.push_back(&&RomLine285);
        main_exec_generated_fast_labels.push_back(&&RomLine286);
        main_exec_generated_fast_labels.push_back(&&RomLine287);
        main_exec_generated_fast_labels.push_back(&&RomLine288);
        main_exec_generated_fast_labels.push_back(&&RomLine289);
        main_exec_generated_fast_labels.push_back(&&RomLine290);
        main_exec_generated_fast_labels.push_back(&&RomLine291);
        main_exec_generated_fast_labels.push_back(&&RomLine292);
        main_exec_generated_fast_labels.push_back(&&RomLine293);
        main_exec_generated_fast_labels.push_back(&&RomLine294);
        main_exec_generated_fast_labels.push_back(&&RomLine295);
        main_exec_generated_fast_labels.push_back(&&RomLine296);
        main_exec_generated_fast_labels.push_back(&&RomLine297);
        main_exec_generated_fast_labels.push_back(&&RomLine298);
        main_exec_generated_fast_labels.push_back(&&RomLine299);
        main_exec_generated_fast_labels.push_back(&&RomLine300);
        main_exec_generated_fast_labels.push_back(&&RomLine301);
        main_exec_generated_fast_labels.push_back(&&RomLine302);
        main_exec_generated_fast_labels.push_back(&&RomLine303);
        main_exec_generated_fast_labels.push_back(&&RomLine304);
        main_exec_generated_fast_labels.push_back(&&RomLine305);
        main_exec_generated_fast_labels.push_back(&&RomLine306);
        main_exec_generated_fast_labels.push_back(&&RomLine307);
        main_exec_generated_fast_labels.push_back(&&RomLine308);
        main_exec_generated_fast_labels.push_back(&&RomLine309);
        main_exec_generated_fast_labels.push_back(&&RomLine310);
        main_exec_generated_fast_labels.push_back(&&RomLine311);
        main_exec_generated_fast_labels.push_back(&&RomLine312);
        main_exec_generated_fast_labels.push_back(&&RomLine313);
        main_exec_generated_fast_labels.push_back(&&RomLine314);
        main_exec_generated_fast_labels.push_back(&&RomLine315);
        main_exec_generated_fast_labels.push_back(&&RomLine316);
        main_exec_generated_fast_labels.push_back(&&RomLine317);
        main_exec_generated_fast_labels.push_back(&&RomLine318);
        main_exec_generated_fast_labels.push_back(&&RomLine319);
        main_exec_generated_fast_labels.push_back(&&RomLine320);
        main_exec_generated_fast_labels.push_back(&&RomLine321);
        main_exec_generated_fast_labels.push_back(&&RomLine322);
        main_exec_generated_fast_labels.push_back(&&RomLine323);
        main_exec_generated_fast_labels.push_back(&&RomLine324);
        main_exec_generated_fast_labels.push_back(&&RomLine325);
        main_exec_generated_fast_labels.push_back(&&RomLine326);
        main_exec_generated_fast_labels.push_back(&&RomLine327);
        main_exec_generated_fast_labels.push_back(&&RomLine328);
        main_exec_generated_fast_labels.push_back(&&RomLine329);
        main_exec_generated_fast_labels.push_back(&&RomLine330);
        main_exec_generated_fast_labels.push_back(&&RomLine331);
        main_exec_generated_fast_labels.push_back(&&RomLine332);
        main_exec_generated_fast_labels.push_back(&&RomLine333);
        main_exec_generated_fast_labels.push_back(&&RomLine334);
        main_exec_generated_fast_labels.push_back(&&RomLine335);
        main_exec_generated_fast_labels.push_back(&&RomLine336);
        main_exec_generated_fast_labels.push_back(&&RomLine337);
        main_exec_generated_fast_labels.push_back(&&RomLine338);
        main_exec_generated_fast_labels.push_back(&&RomLine339);
        main_exec_generated_fast_labels.push_back(&&RomLine340);
        main_exec_generated_fast_labels.push_back(&&RomLine341);
        main_exec_generated_fast_labels.push_back(&&RomLine342);
        main_exec_generated_fast_labels.push_back(&&RomLine343);
        main_exec_generated_fast_labels.push_back(&&RomLine344);
        main_exec_generated_fast_labels.push_back(&&RomLine345);
        main_exec_generated_fast_labels.push_back(&&RomLine346);
        main_exec_generated_fast_labels.push_back(&&RomLine347);
        main_exec_generated_fast_labels.push_back(&&RomLine348);
        main_exec_generated_fast_labels.push_back(&&RomLine349);
        main_exec_generated_fast_labels.push_back(&&RomLine350);
        main_exec_generated_fast_labels.push_back(&&RomLine351);
        main_exec_generated_fast_labels.push_back(&&RomLine352);
        main_exec_generated_fast_labels.push_back(&&RomLine353);
        main_exec_generated_fast_labels.push_back(&&RomLine354);
        main_exec_generated_fast_labels.push_back(&&RomLine355);
        main_exec_generated_fast_labels.push_back(&&RomLine356);
        main_exec_generated_fast_labels.push_back(&&RomLine357);
        main_exec_generated_fast_labels.push_back(&&RomLine358);
        main_exec_generated_fast_labels.push_back(&&RomLine359);
        main_exec_generated_fast_labels.push_back(&&RomLine360);
        main_exec_generated_fast_labels.push_back(&&RomLine361);
        main_exec_generated_fast_labels.push_back(&&RomLine362);
        main_exec_generated_fast_labels.push_back(&&RomLine363);
        main_exec_generated_fast_labels.push_back(&&RomLine364);
        main_exec_generated_fast_labels.push_back(&&RomLine365);
        main_exec_generated_fast_labels.push_back(&&RomLine366);
        main_exec_generated_fast_labels.push_back(&&RomLine367);
        main_exec_generated_fast_labels.push_back(&&RomLine368);
        main_exec_generated_fast_labels.push_back(&&RomLine369);
        main_exec_generated_fast_labels.push_back(&&RomLine370);
        main_exec_generated_fast_labels.push_back(&&RomLine371);
        main_exec_generated_fast_labels.push_back(&&RomLine372);
        main_exec_generated_fast_labels.push_back(&&RomLine373);
        main_exec_generated_fast_labels.push_back(&&RomLine374);
        main_exec_generated_fast_labels.push_back(&&RomLine375);
        main_exec_generated_fast_labels.push_back(&&RomLine376);
        main_exec_generated_fast_labels.push_back(&&RomLine377);
        main_exec_generated_fast_labels.push_back(&&RomLine378);
        main_exec_generated_fast_labels.push_back(&&RomLine379);
        main_exec_generated_fast_labels.push_back(&&RomLine380);
        main_exec_generated_fast_labels.push_back(&&RomLine381);
        main_exec_generated_fast_labels.push_back(&&RomLine382);
        main_exec_generated_fast_labels.push_back(&&RomLine383);
        main_exec_generated_fast_labels.push_back(&&RomLine384);
        main_exec_generated_fast_labels.push_back(&&RomLine385);
        main_exec_generated_fast_labels.push_back(&&RomLine386);
        main_exec_generated_fast_labels.push_back(&&RomLine387);
        main_exec_generated_fast_labels.push_back(&&RomLine388);
        main_exec_generated_fast_labels.push_back(&&RomLine389);
        main_exec_generated_fast_labels.push_back(&&RomLine390);
        main_exec_generated_fast_labels.push_back(&&RomLine391);
        main_exec_generated_fast_labels.push_back(&&RomLine392);
        main_exec_generated_fast_labels.push_back(&&RomLine393);
        main_exec_generated_fast_labels.push_back(&&RomLine394);
        main_exec_generated_fast_labels.push_back(&&RomLine395);
        main_exec_generated_fast_labels.push_back(&&RomLine396);
        main_exec_generated_fast_labels.push_back(&&RomLine397);
        main_exec_generated_fast_labels.push_back(&&RomLine398);
        main_exec_generated_fast_labels.push_back(&&RomLine399);
        main_exec_generated_fast_labels.push_back(&&RomLine400);
        main_exec_generated_fast_labels.push_back(&&RomLine401);
        main_exec_generated_fast_labels.push_back(&&RomLine402);
        main_exec_generated_fast_labels.push_back(&&RomLine403);
        main_exec_generated_fast_labels.push_back(&&RomLine404);
        main_exec_generated_fast_labels.push_back(&&RomLine405);
        main_exec_generated_fast_labels.push_back(&&RomLine406);
        main_exec_generated_fast_labels.push_back(&&RomLine407);
        main_exec_generated_fast_labels.push_back(&&RomLine408);
        main_exec_generated_fast_labels.push_back(&&RomLine409);
        main_exec_generated_fast_labels.push_back(&&RomLine410);
        main_exec_generated_fast_labels.push_back(&&RomLine411);
        main_exec_generated_fast_labels.push_back(&&RomLine412);
        main_exec_generated_fast_labels.push_back(&&RomLine413);
        main_exec_generated_fast_labels.push_back(&&RomLine414);
        main_exec_generated_fast_labels.push_back(&&RomLine415);
        main_exec_generated_fast_labels.push_back(&&RomLine416);
        main_exec_generated_fast_labels.push_back(&&RomLine417);
        main_exec_generated_fast_labels.push_back(&&RomLine418);
        main_exec_generated_fast_labels.push_back(&&RomLine419);
        main_exec_generated_fast_labels.push_back(&&RomLine420);
        main_exec_generated_fast_labels.push_back(&&RomLine421);
        main_exec_generated_fast_labels.push_back(&&RomLine422);
        main_exec_generated_fast_labels.push_back(&&RomLine423);
        main_exec_generated_fast_labels.push_back(&&RomLine424);
        main_exec_generated_fast_labels.push_back(&&RomLine425);
        main_exec_generated_fast_labels.push_back(&&RomLine426);
        main_exec_generated_fast_labels.push_back(&&RomLine427);
        main_exec_generated_fast_labels.push_back(&&RomLine428);
        main_exec_generated_fast_labels.push_back(&&RomLine429);
        main_exec_generated_fast_labels.push_back(&&RomLine430);
        main_exec_generated_fast_labels.push_back(&&RomLine431);
        main_exec_generated_fast_labels.push_back(&&RomLine432);
        main_exec_generated_fast_labels.push_back(&&RomLine433);
        main_exec_generated_fast_labels.push_back(&&RomLine434);
        main_exec_generated_fast_labels.push_back(&&RomLine435);
        main_exec_generated_fast_labels.push_back(&&RomLine436);
        main_exec_generated_fast_labels.push_back(&&RomLine437);
        main_exec_generated_fast_labels.push_back(&&RomLine438);
        main_exec_generated_fast_labels.push_back(&&RomLine439);
        main_exec_generated_fast_labels.push_back(&&RomLine440);
        main_exec_generated_fast_labels.push_back(&&RomLine441);
        main_exec_generated_fast_labels.push_back(&&RomLine442);
        main_exec_generated_fast_labels.push_back(&&RomLine443);
        main_exec_generated_fast_labels.push_back(&&RomLine444);
        main_exec_generated_fast_labels.push_back(&&RomLine445);
        main_exec_generated_fast_labels.push_back(&&RomLine446);
        main_exec_generated_fast_labels.push_back(&&RomLine447);
        main_exec_generated_fast_labels.push_back(&&RomLine448);
        main_exec_generated_fast_labels.push_back(&&RomLine449);
        main_exec_generated_fast_labels.push_back(&&RomLine450);
        main_exec_generated_fast_labels.push_back(&&RomLine451);
        main_exec_generated_fast_labels.push_back(&&RomLine452);
        main_exec_generated_fast_labels.push_back(&&RomLine453);
        main_exec_generated_fast_labels.push_back(&&RomLine454);
        main_exec_generated_fast_labels.push_back(&&RomLine455);
        main_exec_generated_fast_labels.push_back(&&RomLine456);
        main_exec_generated_fast_labels.push_back(&&RomLine457);
        main_exec_generated_fast_labels.push_back(&&RomLine458);
        main_exec_generated_fast_labels.push_back(&&RomLine459);
        main_exec_generated_fast_labels.push_back(&&RomLine460);
        main_exec_generated_fast_labels.push_back(&&RomLine461);
        main_exec_generated_fast_labels.push_back(&&RomLine462);
        main_exec_generated_fast_labels.push_back(&&RomLine463);
        main_exec_generated_fast_labels.push_back(&&RomLine464);
        main_exec_generated_fast_labels.push_back(&&RomLine465);
        main_exec_generated_fast_labels.push_back(&&RomLine466);
        main_exec_generated_fast_labels.push_back(&&RomLine467);
        main_exec_generated_fast_labels.push_back(&&RomLine468);
        main_exec_generated_fast_labels.push_back(&&RomLine469);
        main_exec_generated_fast_labels.push_back(&&RomLine470);
        main_exec_generated_fast_labels.push_back(&&RomLine471);
        main_exec_generated_fast_labels.push_back(&&RomLine472);
        main_exec_generated_fast_labels.push_back(&&RomLine473);
        main_exec_generated_fast_labels.push_back(&&RomLine474);
        main_exec_generated_fast_labels.push_back(&&RomLine475);
        main_exec_generated_fast_labels.push_back(&&RomLine476);
        main_exec_generated_fast_labels.push_back(&&RomLine477);
        main_exec_generated_fast_labels.push_back(&&RomLine478);
        main_exec_generated_fast_labels.push_back(&&RomLine479);
        main_exec_generated_fast_labels.push_back(&&RomLine480);
        main_exec_generated_fast_labels.push_back(&&RomLine481);
        main_exec_generated_fast_labels.push_back(&&RomLine482);
        main_exec_generated_fast_labels.push_back(&&RomLine483);
        main_exec_generated_fast_labels.push_back(&&RomLine484);
        main_exec_generated_fast_labels.push_back(&&RomLine485);
        main_exec_generated_fast_labels.push_back(&&RomLine486);
        main_exec_generated_fast_labels.push_back(&&RomLine487);
        main_exec_generated_fast_labels.push_back(&&RomLine488);
        main_exec_generated_fast_labels.push_back(&&RomLine489);
        main_exec_generated_fast_labels.push_back(&&RomLine490);
        main_exec_generated_fast_labels.push_back(&&RomLine491);
        main_exec_generated_fast_labels.push_back(&&RomLine492);
        main_exec_generated_fast_labels.push_back(&&RomLine493);
        main_exec_generated_fast_labels.push_back(&&RomLine494);
        main_exec_generated_fast_labels.push_back(&&RomLine495);
        main_exec_generated_fast_labels.push_back(&&RomLine496);
        main_exec_generated_fast_labels.push_back(&&RomLine497);
        main_exec_generated_fast_labels.push_back(&&RomLine498);
        main_exec_generated_fast_labels.push_back(&&RomLine499);
        main_exec_generated_fast_labels.push_back(&&RomLine500);
        main_exec_generated_fast_labels.push_back(&&RomLine501);
        main_exec_generated_fast_labels.push_back(&&RomLine502);
        main_exec_generated_fast_labels.push_back(&&RomLine503);
        main_exec_generated_fast_labels.push_back(&&RomLine504);
        main_exec_generated_fast_labels.push_back(&&RomLine505);
        main_exec_generated_fast_labels.push_back(&&RomLine506);
        main_exec_generated_fast_labels.push_back(&&RomLine507);
        main_exec_generated_fast_labels.push_back(&&RomLine508);
        main_exec_generated_fast_labels.push_back(&&RomLine509);
        main_exec_generated_fast_labels.push_back(&&RomLine510);
        main_exec_generated_fast_labels.push_back(&&RomLine511);
        main_exec_generated_fast_labels.push_back(&&RomLine512);
        main_exec_generated_fast_labels.push_back(&&RomLine513);
        main_exec_generated_fast_labels.push_back(&&RomLine514);
        main_exec_generated_fast_labels.push_back(&&RomLine515);
        main_exec_generated_fast_labels.push_back(&&RomLine516);
        main_exec_generated_fast_labels.push_back(&&RomLine517);
        main_exec_generated_fast_labels.push_back(&&RomLine518);
        main_exec_generated_fast_labels.push_back(&&RomLine519);
        main_exec_generated_fast_labels.push_back(&&RomLine520);
        main_exec_generated_fast_labels.push_back(&&RomLine521);
        main_exec_generated_fast_labels.push_back(&&RomLine522);
        main_exec_generated_fast_labels.push_back(&&RomLine523);
        main_exec_generated_fast_labels.push_back(&&RomLine524);
        main_exec_generated_fast_labels.push_back(&&RomLine525);
        main_exec_generated_fast_labels.push_back(&&RomLine526);
        main_exec_generated_fast_labels.push_back(&&RomLine527);
        main_exec_generated_fast_labels.push_back(&&RomLine528);
        main_exec_generated_fast_labels.push_back(&&RomLine529);
        main_exec_generated_fast_labels.push_back(&&RomLine530);
        main_exec_generated_fast_labels.push_back(&&RomLine531);
        main_exec_generated_fast_labels.push_back(&&RomLine532);
        main_exec_generated_fast_labels.push_back(&&RomLine533);
        main_exec_generated_fast_labels.push_back(&&RomLine534);
        main_exec_generated_fast_labels.push_back(&&RomLine535);
        main_exec_generated_fast_labels.push_back(&&RomLine536);
        main_exec_generated_fast_labels.push_back(&&RomLine537);
        main_exec_generated_fast_labels.push_back(&&RomLine538);
        main_exec_generated_fast_labels.push_back(&&RomLine539);
        main_exec_generated_fast_labels.push_back(&&RomLine540);
        main_exec_generated_fast_labels.push_back(&&RomLine541);
        main_exec_generated_fast_labels.push_back(&&RomLine542);
        main_exec_generated_fast_labels.push_back(&&RomLine543);
        main_exec_generated_fast_labels.push_back(&&RomLine544);
        main_exec_generated_fast_labels.push_back(&&RomLine545);
        main_exec_generated_fast_labels.push_back(&&RomLine546);
        main_exec_generated_fast_labels.push_back(&&RomLine547);
        main_exec_generated_fast_labels.push_back(&&RomLine548);
        main_exec_generated_fast_labels.push_back(&&RomLine549);
        main_exec_generated_fast_labels.push_back(&&RomLine550);
        main_exec_generated_fast_labels.push_back(&&RomLine551);
        main_exec_generated_fast_labels.push_back(&&RomLine552);
        main_exec_generated_fast_labels.push_back(&&RomLine553);
        main_exec_generated_fast_labels.push_back(&&RomLine554);
        main_exec_generated_fast_labels.push_back(&&RomLine555);
        main_exec_generated_fast_labels.push_back(&&RomLine556);
        main_exec_generated_fast_labels.push_back(&&RomLine557);
        main_exec_generated_fast_labels.push_back(&&RomLine558);
        main_exec_generated_fast_labels.push_back(&&RomLine559);
        main_exec_generated_fast_labels.push_back(&&RomLine560);
        main_exec_generated_fast_labels.push_back(&&RomLine561);
        main_exec_generated_fast_labels.push_back(&&RomLine562);
        main_exec_generated_fast_labels.push_back(&&RomLine563);
        main_exec_generated_fast_labels.push_back(&&RomLine564);
        main_exec_generated_fast_labels.push_back(&&RomLine565);
        main_exec_generated_fast_labels.push_back(&&RomLine566);
        main_exec_generated_fast_labels.push_back(&&RomLine567);
        main_exec_generated_fast_labels.push_back(&&RomLine568);
        main_exec_generated_fast_labels.push_back(&&RomLine569);
        main_exec_generated_fast_labels.push_back(&&RomLine570);
        main_exec_generated_fast_labels.push_back(&&RomLine571);
        main_exec_generated_fast_labels.push_back(&&RomLine572);
        main_exec_generated_fast_labels.push_back(&&RomLine573);
        main_exec_generated_fast_labels.push_back(&&RomLine574);
        main_exec_generated_fast_labels.push_back(&&RomLine575);
        main_exec_generated_fast_labels.push_back(&&RomLine576);
        main_exec_generated_fast_labels.push_back(&&RomLine577);
        main_exec_generated_fast_labels.push_back(&&RomLine578);
        main_exec_generated_fast_labels.push_back(&&RomLine579);
        main_exec_generated_fast_labels.push_back(&&RomLine580);
        main_exec_generated_fast_labels.push_back(&&RomLine581);
        main_exec_generated_fast_labels.push_back(&&RomLine582);
        main_exec_generated_fast_labels.push_back(&&RomLine583);
        main_exec_generated_fast_labels.push_back(&&RomLine584);
        main_exec_generated_fast_labels.push_back(&&RomLine585);
        main_exec_generated_fast_labels.push_back(&&RomLine586);
        main_exec_generated_fast_labels.push_back(&&RomLine587);
        main_exec_generated_fast_labels.push_back(&&RomLine588);
        main_exec_generated_fast_labels.push_back(&&RomLine589);
        main_exec_generated_fast_labels.push_back(&&RomLine590);
        main_exec_generated_fast_labels.push_back(&&RomLine591);
        main_exec_generated_fast_labels.push_back(&&RomLine592);
        main_exec_generated_fast_labels.push_back(&&RomLine593);
        main_exec_generated_fast_labels.push_back(&&RomLine594);
        main_exec_generated_fast_labels.push_back(&&RomLine595);
        main_exec_generated_fast_labels.push_back(&&RomLine596);
        main_exec_generated_fast_labels.push_back(&&RomLine597);
        main_exec_generated_fast_labels.push_back(&&RomLine598);
        main_exec_generated_fast_labels.push_back(&&RomLine599);
        main_exec_generated_fast_labels.push_back(&&RomLine600);
        main_exec_generated_fast_labels.push_back(&&RomLine601);
        main_exec_generated_fast_labels.push_back(&&RomLine602);
        main_exec_generated_fast_labels.push_back(&&RomLine603);
        main_exec_generated_fast_labels.push_back(&&RomLine604);
        main_exec_generated_fast_labels.push_back(&&RomLine605);
        main_exec_generated_fast_labels.push_back(&&RomLine606);
        main_exec_generated_fast_labels.push_back(&&RomLine607);
        main_exec_generated_fast_labels.push_back(&&RomLine608);
        main_exec_generated_fast_labels.push_back(&&RomLine609);
        main_exec_generated_fast_labels.push_back(&&RomLine610);
        main_exec_generated_fast_labels.push_back(&&RomLine611);
        main_exec_generated_fast_labels.push_back(&&RomLine612);
        main_exec_generated_fast_labels.push_back(&&RomLine613);
        main_exec_generated_fast_labels.push_back(&&RomLine614);
        main_exec_generated_fast_labels.push_back(&&RomLine615);
        main_exec_generated_fast_labels.push_back(&&RomLine616);
        main_exec_generated_fast_labels.push_back(&&RomLine617);
        main_exec_generated_fast_labels.push_back(&&RomLine618);
        main_exec_generated_fast_labels.push_back(&&RomLine619);
        main_exec_generated_fast_labels.push_back(&&RomLine620);
        main_exec_generated_fast_labels.push_back(&&RomLine621);
        main_exec_generated_fast_labels.push_back(&&RomLine622);
        main_exec_generated_fast_labels.push_back(&&RomLine623);
        main_exec_generated_fast_labels.push_back(&&RomLine624);
        main_exec_generated_fast_labels.push_back(&&RomLine625);
        main_exec_generated_fast_labels.push_back(&&RomLine626);
        main_exec_generated_fast_labels.push_back(&&RomLine627);
        main_exec_generated_fast_labels.push_back(&&RomLine628);
        main_exec_generated_fast_labels.push_back(&&RomLine629);
        main_exec_generated_fast_labels.push_back(&&RomLine630);
        main_exec_generated_fast_labels.push_back(&&RomLine631);
        main_exec_generated_fast_labels.push_back(&&RomLine632);
        main_exec_generated_fast_labels.push_back(&&RomLine633);
        main_exec_generated_fast_labels.push_back(&&RomLine634);
        main_exec_generated_fast_labels.push_back(&&RomLine635);
        main_exec_generated_fast_labels.push_back(&&RomLine636);
        main_exec_generated_fast_labels.push_back(&&RomLine637);
        main_exec_generated_fast_labels.push_back(&&RomLine638);
        main_exec_generated_fast_labels.push_back(&&RomLine639);
        main_exec_generated_fast_labels.push_back(&&RomLine640);
        main_exec_generated_fast_labels.push_back(&&RomLine641);
        main_exec_generated_fast_labels.push_back(&&RomLine642);
        main_exec_generated_fast_labels.push_back(&&RomLine643);
        main_exec_generated_fast_labels.push_back(&&RomLine644);
        main_exec_generated_fast_labels.push_back(&&RomLine645);
        main_exec_generated_fast_labels.push_back(&&RomLine646);
        main_exec_generated_fast_labels.push_back(&&RomLine647);
        main_exec_generated_fast_labels.push_back(&&RomLine648);
        main_exec_generated_fast_labels.push_back(&&RomLine649);
        main_exec_generated_fast_labels.push_back(&&RomLine650);
        main_exec_generated_fast_labels.push_back(&&RomLine651);
        main_exec_generated_fast_labels.push_back(&&RomLine652);
        main_exec_generated_fast_labels.push_back(&&RomLine653);
        main_exec_generated_fast_labels.push_back(&&RomLine654);
        main_exec_generated_fast_labels.push_back(&&RomLine655);
        main_exec_generated_fast_labels.push_back(&&RomLine656);
        main_exec_generated_fast_labels.push_back(&&RomLine657);
        main_exec_generated_fast_labels.push_back(&&RomLine658);
        main_exec_generated_fast_labels.push_back(&&RomLine659);
        main_exec_generated_fast_labels.push_back(&&RomLine660);
        main_exec_generated_fast_labels.push_back(&&RomLine661);
        main_exec_generated_fast_labels.push_back(&&RomLine662);
        main_exec_generated_fast_labels.push_back(&&RomLine663);
        main_exec_generated_fast_labels.push_back(&&RomLine664);
        main_exec_generated_fast_labels.push_back(&&RomLine665);
        main_exec_generated_fast_labels.push_back(&&RomLine666);
        main_exec_generated_fast_labels.push_back(&&RomLine667);
        main_exec_generated_fast_labels.push_back(&&RomLine668);
        main_exec_generated_fast_labels.push_back(&&RomLine669);
        main_exec_generated_fast_labels.push_back(&&RomLine670);
        main_exec_generated_fast_labels.push_back(&&RomLine671);
        main_exec_generated_fast_labels.push_back(&&RomLine672);
        main_exec_generated_fast_labels.push_back(&&RomLine673);
        main_exec_generated_fast_labels.push_back(&&RomLine674);
        main_exec_generated_fast_labels.push_back(&&RomLine675);
        main_exec_generated_fast_labels.push_back(&&RomLine676);
        main_exec_generated_fast_labels.push_back(&&RomLine677);
        main_exec_generated_fast_labels.push_back(&&RomLine678);
        main_exec_generated_fast_labels.push_back(&&RomLine679);
        main_exec_generated_fast_labels.push_back(&&RomLine680);
        main_exec_generated_fast_labels.push_back(&&RomLine681);
        main_exec_generated_fast_labels.push_back(&&RomLine682);
        main_exec_generated_fast_labels.push_back(&&RomLine683);
        main_exec_generated_fast_labels.push_back(&&RomLine684);
        main_exec_generated_fast_labels.push_back(&&RomLine685);
        main_exec_generated_fast_labels.push_back(&&RomLine686);
        main_exec_generated_fast_labels.push_back(&&RomLine687);
        main_exec_generated_fast_labels.push_back(&&RomLine688);
        main_exec_generated_fast_labels.push_back(&&RomLine689);
        main_exec_generated_fast_labels.push_back(&&RomLine690);
        main_exec_generated_fast_labels.push_back(&&RomLine691);
        main_exec_generated_fast_labels.push_back(&&RomLine692);
        main_exec_generated_fast_labels.push_back(&&RomLine693);
        main_exec_generated_fast_labels.push_back(&&RomLine694);
        main_exec_generated_fast_labels.push_back(&&RomLine695);
        main_exec_generated_fast_labels.push_back(&&RomLine696);
        main_exec_generated_fast_labels.push_back(&&RomLine697);
        main_exec_generated_fast_labels.push_back(&&RomLine698);
        main_exec_generated_fast_labels.push_back(&&RomLine699);
        main_exec_generated_fast_labels.push_back(&&RomLine700);
        main_exec_generated_fast_labels.push_back(&&RomLine701);
        main_exec_generated_fast_labels.push_back(&&RomLine702);
        main_exec_generated_fast_labels.push_back(&&RomLine703);
        main_exec_generated_fast_labels.push_back(&&RomLine704);
        main_exec_generated_fast_labels.push_back(&&RomLine705);
        main_exec_generated_fast_labels.push_back(&&RomLine706);
        main_exec_generated_fast_labels.push_back(&&RomLine707);
        main_exec_generated_fast_labels.push_back(&&RomLine708);
        main_exec_generated_fast_labels.push_back(&&RomLine709);
        main_exec_generated_fast_labels.push_back(&&RomLine710);
        main_exec_generated_fast_labels.push_back(&&RomLine711);
        main_exec_generated_fast_labels.push_back(&&RomLine712);
        main_exec_generated_fast_labels.push_back(&&RomLine713);
        main_exec_generated_fast_labels.push_back(&&RomLine714);
        main_exec_generated_fast_labels.push_back(&&RomLine715);
        main_exec_generated_fast_labels.push_back(&&RomLine716);
        main_exec_generated_fast_labels.push_back(&&RomLine717);
        main_exec_generated_fast_labels.push_back(&&RomLine718);
        main_exec_generated_fast_labels.push_back(&&RomLine719);
        main_exec_generated_fast_labels.push_back(&&RomLine720);
        main_exec_generated_fast_labels.push_back(&&RomLine721);
        main_exec_generated_fast_labels.push_back(&&RomLine722);
        main_exec_generated_fast_labels.push_back(&&RomLine723);
        main_exec_generated_fast_labels.push_back(&&RomLine724);
        main_exec_generated_fast_labels.push_back(&&RomLine725);
        main_exec_generated_fast_labels.push_back(&&RomLine726);
        main_exec_generated_fast_labels.push_back(&&RomLine727);
        main_exec_generated_fast_labels.push_back(&&RomLine728);
        main_exec_generated_fast_labels.push_back(&&RomLine729);
        main_exec_generated_fast_labels.push_back(&&RomLine730);
        main_exec_generated_fast_labels.push_back(&&RomLine731);
        main_exec_generated_fast_labels.push_back(&&RomLine732);
        main_exec_generated_fast_labels.push_back(&&RomLine733);
        main_exec_generated_fast_labels.push_back(&&RomLine734);
        main_exec_generated_fast_labels.push_back(&&RomLine735);
        main_exec_generated_fast_labels.push_back(&&RomLine736);
        main_exec_generated_fast_labels.push_back(&&RomLine737);
        main_exec_generated_fast_labels.push_back(&&RomLine738);
        main_exec_generated_fast_labels.push_back(&&RomLine739);
        main_exec_generated_fast_labels.push_back(&&RomLine740);
        main_exec_generated_fast_labels.push_back(&&RomLine741);
        main_exec_generated_fast_labels.push_back(&&RomLine742);
        main_exec_generated_fast_labels.push_back(&&RomLine743);
        main_exec_generated_fast_labels.push_back(&&RomLine744);
        main_exec_generated_fast_labels.push_back(&&RomLine745);
        main_exec_generated_fast_labels.push_back(&&RomLine746);
        main_exec_generated_fast_labels.push_back(&&RomLine747);
        main_exec_generated_fast_labels.push_back(&&RomLine748);
        main_exec_generated_fast_labels.push_back(&&RomLine749);
        main_exec_generated_fast_labels.push_back(&&RomLine750);
        main_exec_generated_fast_labels.push_back(&&RomLine751);
        main_exec_generated_fast_labels.push_back(&&RomLine752);
        main_exec_generated_fast_labels.push_back(&&RomLine753);
        main_exec_generated_fast_labels.push_back(&&RomLine754);
        main_exec_generated_fast_labels.push_back(&&RomLine755);
        main_exec_generated_fast_labels.push_back(&&RomLine756);
        main_exec_generated_fast_labels.push_back(&&RomLine757);
        main_exec_generated_fast_labels.push_back(&&RomLine758);
        main_exec_generated_fast_labels.push_back(&&RomLine759);
        main_exec_generated_fast_labels.push_back(&&RomLine760);
        main_exec_generated_fast_labels.push_back(&&RomLine761);
        main_exec_generated_fast_labels.push_back(&&RomLine762);
        main_exec_generated_fast_labels.push_back(&&RomLine763);
        main_exec_generated_fast_labels.push_back(&&RomLine764);
        main_exec_generated_fast_labels.push_back(&&RomLine765);
        main_exec_generated_fast_labels.push_back(&&RomLine766);
        main_exec_generated_fast_labels.push_back(&&RomLine767);
        main_exec_generated_fast_labels.push_back(&&RomLine768);
        main_exec_generated_fast_labels.push_back(&&RomLine769);
        main_exec_generated_fast_labels.push_back(&&RomLine770);
        main_exec_generated_fast_labels.push_back(&&RomLine771);
        main_exec_generated_fast_labels.push_back(&&RomLine772);
        main_exec_generated_fast_labels.push_back(&&RomLine773);
        main_exec_generated_fast_labels.push_back(&&RomLine774);
        main_exec_generated_fast_labels.push_back(&&RomLine775);
        main_exec_generated_fast_labels.push_back(&&RomLine776);
        main_exec_generated_fast_labels.push_back(&&RomLine777);
        main_exec_generated_fast_labels.push_back(&&RomLine778);
        main_exec_generated_fast_labels.push_back(&&RomLine779);
        main_exec_generated_fast_labels.push_back(&&RomLine780);
        main_exec_generated_fast_labels.push_back(&&RomLine781);
        main_exec_generated_fast_labels.push_back(&&RomLine782);
        main_exec_generated_fast_labels.push_back(&&RomLine783);
        main_exec_generated_fast_labels.push_back(&&RomLine784);
        main_exec_generated_fast_labels.push_back(&&RomLine785);
        main_exec_generated_fast_labels.push_back(&&RomLine786);
        main_exec_generated_fast_labels.push_back(&&RomLine787);
        main_exec_generated_fast_labels.push_back(&&RomLine788);
        main_exec_generated_fast_labels.push_back(&&RomLine789);
        main_exec_generated_fast_labels.push_back(&&RomLine790);
        main_exec_generated_fast_labels.push_back(&&RomLine791);
        main_exec_generated_fast_labels.push_back(&&RomLine792);
        main_exec_generated_fast_labels.push_back(&&RomLine793);
        main_exec_generated_fast_labels.push_back(&&RomLine794);
        main_exec_generated_fast_labels.push_back(&&RomLine795);
        main_exec_generated_fast_labels.push_back(&&RomLine796);
        main_exec_generated_fast_labels.push_back(&&RomLine797);
        main_exec_generated_fast_labels.push_back(&&RomLine798);
        main_exec_generated_fast_labels.push_back(&&RomLine799);
        main_exec_generated_fast_labels.push_back(&&RomLine800);
        main_exec_generated_fast_labels.push_back(&&RomLine801);
        main_exec_generated_fast_labels.push_back(&&RomLine802);
        main_exec_generated_fast_labels.push_back(&&RomLine803);
        main_exec_generated_fast_labels.push_back(&&RomLine804);
        main_exec_generated_fast_labels.push_back(&&RomLine805);
        main_exec_generated_fast_labels.push_back(&&RomLine806);
        main_exec_generated_fast_labels.push_back(&&RomLine807);
        main_exec_generated_fast_labels.push_back(&&RomLine808);
        main_exec_generated_fast_labels.push_back(&&RomLine809);
        main_exec_generated_fast_labels.push_back(&&RomLine810);
        main_exec_generated_fast_labels.push_back(&&RomLine811);
        main_exec_generated_fast_labels.push_back(&&RomLine812);
        main_exec_generated_fast_labels.push_back(&&RomLine813);
        main_exec_generated_fast_labels.push_back(&&RomLine814);
        main_exec_generated_fast_labels.push_back(&&RomLine815);
        main_exec_generated_fast_labels.push_back(&&RomLine816);
        main_exec_generated_fast_labels.push_back(&&RomLine817);
        main_exec_generated_fast_labels.push_back(&&RomLine818);
        main_exec_generated_fast_labels.push_back(&&RomLine819);
        main_exec_generated_fast_labels.push_back(&&RomLine820);
        main_exec_generated_fast_labels.push_back(&&RomLine821);
        main_exec_generated_fast_labels.push_back(&&RomLine822);
        main_exec_generated_fast_labels.push_back(&&RomLine823);
        main_exec_generated_fast_labels.push_back(&&RomLine824);
        main_exec_generated_fast_labels.push_back(&&RomLine825);
        main_exec_generated_fast_labels.push_back(&&RomLine826);
        main_exec_generated_fast_labels.push_back(&&RomLine827);
        main_exec_generated_fast_labels.push_back(&&RomLine828);
        main_exec_generated_fast_labels.push_back(&&RomLine829);
        main_exec_generated_fast_labels.push_back(&&RomLine830);
        main_exec_generated_fast_labels.push_back(&&RomLine831);
        main_exec_generated_fast_labels.push_back(&&RomLine832);
        main_exec_generated_fast_labels.push_back(&&RomLine833);
        main_exec_generated_fast_labels.push_back(&&RomLine834);
        main_exec_generated_fast_labels.push_back(&&RomLine835);
        main_exec_generated_fast_labels.push_back(&&RomLine836);
        main_exec_generated_fast_labels.push_back(&&RomLine837);
        main_exec_generated_fast_labels.push_back(&&RomLine838);
        main_exec_generated_fast_labels.push_back(&&RomLine839);
        main_exec_generated_fast_labels.push_back(&&RomLine840);
        main_exec_generated_fast_labels.push_back(&&RomLine841);
        main_exec_generated_fast_labels.push_back(&&RomLine842);
        main_exec_generated_fast_labels.push_back(&&RomLine843);
        main_exec_generated_fast_labels.push_back(&&RomLine844);
        main_exec_generated_fast_labels.push_back(&&RomLine845);
        main_exec_generated_fast_labels.push_back(&&RomLine846);
        main_exec_generated_fast_labels.push_back(&&RomLine847);
        main_exec_generated_fast_labels.push_back(&&RomLine848);
        main_exec_generated_fast_labels.push_back(&&RomLine849);
        main_exec_generated_fast_labels.push_back(&&RomLine850);
        main_exec_generated_fast_labels.push_back(&&RomLine851);
        main_exec_generated_fast_labels.push_back(&&RomLine852);
        main_exec_generated_fast_labels.push_back(&&RomLine853);
        main_exec_generated_fast_labels.push_back(&&RomLine854);
        main_exec_generated_fast_labels.push_back(&&RomLine855);
        main_exec_generated_fast_labels.push_back(&&RomLine856);
        main_exec_generated_fast_labels.push_back(&&RomLine857);
        main_exec_generated_fast_labels.push_back(&&RomLine858);
        main_exec_generated_fast_labels.push_back(&&RomLine859);
        main_exec_generated_fast_labels.push_back(&&RomLine860);
        main_exec_generated_fast_labels.push_back(&&RomLine861);
        main_exec_generated_fast_labels.push_back(&&RomLine862);
        main_exec_generated_fast_labels.push_back(&&RomLine863);
        main_exec_generated_fast_labels.push_back(&&RomLine864);
        main_exec_generated_fast_labels.push_back(&&RomLine865);
        main_exec_generated_fast_labels.push_back(&&RomLine866);
        main_exec_generated_fast_labels.push_back(&&RomLine867);
        main_exec_generated_fast_labels.push_back(&&RomLine868);
        main_exec_generated_fast_labels.push_back(&&RomLine869);
        main_exec_generated_fast_labels.push_back(&&RomLine870);
        main_exec_generated_fast_labels.push_back(&&RomLine871);
        main_exec_generated_fast_labels.push_back(&&RomLine872);
        main_exec_generated_fast_labels.push_back(&&RomLine873);
        main_exec_generated_fast_labels.push_back(&&RomLine874);
        main_exec_generated_fast_labels.push_back(&&RomLine875);
        main_exec_generated_fast_labels.push_back(&&RomLine876);
        main_exec_generated_fast_labels.push_back(&&RomLine877);
        main_exec_generated_fast_labels.push_back(&&RomLine878);
        main_exec_generated_fast_labels.push_back(&&RomLine879);
        main_exec_generated_fast_labels.push_back(&&RomLine880);
        main_exec_generated_fast_labels.push_back(&&RomLine881);
        main_exec_generated_fast_labels.push_back(&&RomLine882);
        main_exec_generated_fast_labels.push_back(&&RomLine883);
        main_exec_generated_fast_labels.push_back(&&RomLine884);
        main_exec_generated_fast_labels.push_back(&&RomLine885);
        main_exec_generated_fast_labels.push_back(&&RomLine886);
        main_exec_generated_fast_labels.push_back(&&RomLine887);
        main_exec_generated_fast_labels.push_back(&&RomLine888);
        main_exec_generated_fast_labels.push_back(&&RomLine889);
        main_exec_generated_fast_labels.push_back(&&RomLine890);
        main_exec_generated_fast_labels.push_back(&&RomLine891);
        main_exec_generated_fast_labels.push_back(&&RomLine892);
        main_exec_generated_fast_labels.push_back(&&RomLine893);
        main_exec_generated_fast_labels.push_back(&&RomLine894);
        main_exec_generated_fast_labels.push_back(&&RomLine895);
        main_exec_generated_fast_labels.push_back(&&RomLine896);
        main_exec_generated_fast_labels.push_back(&&RomLine897);
        main_exec_generated_fast_labels.push_back(&&RomLine898);
        main_exec_generated_fast_labels.push_back(&&RomLine899);
        main_exec_generated_fast_labels.push_back(&&RomLine900);
        main_exec_generated_fast_labels.push_back(&&RomLine901);
        main_exec_generated_fast_labels.push_back(&&RomLine902);
        main_exec_generated_fast_labels.push_back(&&RomLine903);
        main_exec_generated_fast_labels.push_back(&&RomLine904);
        main_exec_generated_fast_labels.push_back(&&RomLine905);
        main_exec_generated_fast_labels.push_back(&&RomLine906);
        main_exec_generated_fast_labels.push_back(&&RomLine907);
        main_exec_generated_fast_labels.push_back(&&RomLine908);
        main_exec_generated_fast_labels.push_back(&&RomLine909);
        main_exec_generated_fast_labels.push_back(&&RomLine910);
        main_exec_generated_fast_labels.push_back(&&RomLine911);
        main_exec_generated_fast_labels.push_back(&&RomLine912);
        main_exec_generated_fast_labels.push_back(&&RomLine913);
        main_exec_generated_fast_labels.push_back(&&RomLine914);
        main_exec_generated_fast_labels.push_back(&&RomLine915);
        main_exec_generated_fast_labels.push_back(&&RomLine916);
        main_exec_generated_fast_labels.push_back(&&RomLine917);
        main_exec_generated_fast_labels.push_back(&&RomLine918);
        main_exec_generated_fast_labels.push_back(&&RomLine919);
        main_exec_generated_fast_labels.push_back(&&RomLine920);
        main_exec_generated_fast_labels.push_back(&&RomLine921);
        main_exec_generated_fast_labels.push_back(&&RomLine922);
        main_exec_generated_fast_labels.push_back(&&RomLine923);
        main_exec_generated_fast_labels.push_back(&&RomLine924);
        main_exec_generated_fast_labels.push_back(&&RomLine925);
        main_exec_generated_fast_labels.push_back(&&RomLine926);
        main_exec_generated_fast_labels.push_back(&&RomLine927);
        main_exec_generated_fast_labels.push_back(&&RomLine928);
        main_exec_generated_fast_labels.push_back(&&RomLine929);
        main_exec_generated_fast_labels.push_back(&&RomLine930);
        main_exec_generated_fast_labels.push_back(&&RomLine931);
        main_exec_generated_fast_labels.push_back(&&RomLine932);
        main_exec_generated_fast_labels.push_back(&&RomLine933);
        main_exec_generated_fast_labels.push_back(&&RomLine934);
        main_exec_generated_fast_labels.push_back(&&RomLine935);
        main_exec_generated_fast_labels.push_back(&&RomLine936);
        main_exec_generated_fast_labels.push_back(&&RomLine937);
        main_exec_generated_fast_labels.push_back(&&RomLine938);
        main_exec_generated_fast_labels.push_back(&&RomLine939);
        main_exec_generated_fast_labels.push_back(&&RomLine940);
        main_exec_generated_fast_labels.push_back(&&RomLine941);
        main_exec_generated_fast_labels.push_back(&&RomLine942);
        main_exec_generated_fast_labels.push_back(&&RomLine943);
        main_exec_generated_fast_labels.push_back(&&RomLine944);
        main_exec_generated_fast_labels.push_back(&&RomLine945);
        main_exec_generated_fast_labels.push_back(&&RomLine946);
        main_exec_generated_fast_labels.push_back(&&RomLine947);
        main_exec_generated_fast_labels.push_back(&&RomLine948);
        main_exec_generated_fast_labels.push_back(&&RomLine949);
        main_exec_generated_fast_labels.push_back(&&RomLine950);
        main_exec_generated_fast_labels.push_back(&&RomLine951);
        main_exec_generated_fast_labels.push_back(&&RomLine952);
        main_exec_generated_fast_labels.push_back(&&RomLine953);
        main_exec_generated_fast_labels.push_back(&&RomLine954);
        main_exec_generated_fast_labels.push_back(&&RomLine955);
        main_exec_generated_fast_labels.push_back(&&RomLine956);
        main_exec_generated_fast_labels.push_back(&&RomLine957);
        main_exec_generated_fast_labels.push_back(&&RomLine958);
        main_exec_generated_fast_labels.push_back(&&RomLine959);
        main_exec_generated_fast_labels.push_back(&&RomLine960);
        main_exec_generated_fast_labels.push_back(&&RomLine961);
        main_exec_generated_fast_labels.push_back(&&RomLine962);
        main_exec_generated_fast_labels.push_back(&&RomLine963);
        main_exec_generated_fast_labels.push_back(&&RomLine964);
        main_exec_generated_fast_labels.push_back(&&RomLine965);
        main_exec_generated_fast_labels.push_back(&&RomLine966);
        main_exec_generated_fast_labels.push_back(&&RomLine967);
        main_exec_generated_fast_labels.push_back(&&RomLine968);
        main_exec_generated_fast_labels.push_back(&&RomLine969);
        main_exec_generated_fast_labels.push_back(&&RomLine970);
        main_exec_generated_fast_labels.push_back(&&RomLine971);
        main_exec_generated_fast_labels.push_back(&&RomLine972);
        main_exec_generated_fast_labels.push_back(&&RomLine973);
        main_exec_generated_fast_labels.push_back(&&RomLine974);
        main_exec_generated_fast_labels.push_back(&&RomLine975);
        main_exec_generated_fast_labels.push_back(&&RomLine976);
        main_exec_generated_fast_labels.push_back(&&RomLine977);
        main_exec_generated_fast_labels.push_back(&&RomLine978);
        main_exec_generated_fast_labels.push_back(&&RomLine979);
        main_exec_generated_fast_labels.push_back(&&RomLine980);
        main_exec_generated_fast_labels.push_back(&&RomLine981);
        main_exec_generated_fast_labels.push_back(&&RomLine982);
        main_exec_generated_fast_labels.push_back(&&RomLine983);
        main_exec_generated_fast_labels.push_back(&&RomLine984);
        main_exec_generated_fast_labels.push_back(&&RomLine985);
        main_exec_generated_fast_labels.push_back(&&RomLine986);
        main_exec_generated_fast_labels.push_back(&&RomLine987);
        main_exec_generated_fast_labels.push_back(&&RomLine988);
        main_exec_generated_fast_labels.push_back(&&RomLine989);
        main_exec_generated_fast_labels.push_back(&&RomLine990);
        main_exec_generated_fast_labels.push_back(&&RomLine991);
        main_exec_generated_fast_labels.push_back(&&RomLine992);
        main_exec_generated_fast_labels.push_back(&&RomLine993);
        main_exec_generated_fast_labels.push_back(&&RomLine994);
        main_exec_generated_fast_labels.push_back(&&RomLine995);
        main_exec_generated_fast_labels.push_back(&&RomLine996);
        main_exec_generated_fast_labels.push_back(&&RomLine997);
        main_exec_generated_fast_labels.push_back(&&RomLine998);
        main_exec_generated_fast_labels.push_back(&&RomLine999);
        main_exec_generated_fast_labels.push_back(&&RomLine1000);
        main_exec_generated_fast_labels.push_back(&&RomLine1001);
        main_exec_generated_fast_labels.push_back(&&RomLine1002);
        main_exec_generated_fast_labels.push_back(&&RomLine1003);
        main_exec_generated_fast_labels.push_back(&&RomLine1004);
        main_exec_generated_fast_labels.push_back(&&RomLine1005);
        main_exec_generated_fast_labels.push_back(&&RomLine1006);
        main_exec_generated_fast_labels.push_back(&&RomLine1007);
        main_exec_generated_fast_labels.push_back(&&RomLine1008);
        main_exec_generated_fast_labels.push_back(&&RomLine1009);
        main_exec_generated_fast_labels.push_back(&&RomLine1010);
        main_exec_generated_fast_labels.push_back(&&RomLine1011);
        main_exec_generated_fast_labels.push_back(&&RomLine1012);
        main_exec_generated_fast_labels.push_back(&&RomLine1013);
        main_exec_generated_fast_labels.push_back(&&RomLine1014);
        main_exec_generated_fast_labels.push_back(&&RomLine1015);
        main_exec_generated_fast_labels.push_back(&&RomLine1016);
        main_exec_generated_fast_labels.push_back(&&RomLine1017);
        main_exec_generated_fast_labels.push_back(&&RomLine1018);
        main_exec_generated_fast_labels.push_back(&&RomLine1019);
        main_exec_generated_fast_labels.push_back(&&RomLine1020);
        main_exec_generated_fast_labels.push_back(&&RomLine1021);
        main_exec_generated_fast_labels.push_back(&&RomLine1022);
        main_exec_generated_fast_labels.push_back(&&RomLine1023);
        main_exec_generated_fast_labels.push_back(&&RomLine1024);
        main_exec_generated_fast_labels.push_back(&&RomLine1025);
        main_exec_generated_fast_labels.push_back(&&RomLine1026);
        main_exec_generated_fast_labels.push_back(&&RomLine1027);
        main_exec_generated_fast_labels.push_back(&&RomLine1028);
        main_exec_generated_fast_labels.push_back(&&RomLine1029);
        main_exec_generated_fast_labels.push_back(&&RomLine1030);
        main_exec_generated_fast_labels.push_back(&&RomLine1031);
        main_exec_generated_fast_labels.push_back(&&RomLine1032);
        main_exec_generated_fast_labels.push_back(&&RomLine1033);
        main_exec_generated_fast_labels.push_back(&&RomLine1034);
        main_exec_generated_fast_labels.push_back(&&RomLine1035);
        main_exec_generated_fast_labels.push_back(&&RomLine1036);
        main_exec_generated_fast_labels.push_back(&&RomLine1037);
        main_exec_generated_fast_labels.push_back(&&RomLine1038);
        main_exec_generated_fast_labels.push_back(&&RomLine1039);
        main_exec_generated_fast_labels.push_back(&&RomLine1040);
        main_exec_generated_fast_labels.push_back(&&RomLine1041);
        main_exec_generated_fast_labels.push_back(&&RomLine1042);
        main_exec_generated_fast_labels.push_back(&&RomLine1043);
        main_exec_generated_fast_labels.push_back(&&RomLine1044);
        main_exec_generated_fast_labels.push_back(&&RomLine1045);
        main_exec_generated_fast_labels.push_back(&&RomLine1046);
        main_exec_generated_fast_labels.push_back(&&RomLine1047);
        main_exec_generated_fast_labels.push_back(&&RomLine1048);
        main_exec_generated_fast_labels.push_back(&&RomLine1049);
        main_exec_generated_fast_labels.push_back(&&RomLine1050);
        main_exec_generated_fast_labels.push_back(&&RomLine1051);
        main_exec_generated_fast_labels.push_back(&&RomLine1052);
        main_exec_generated_fast_labels.push_back(&&RomLine1053);
        main_exec_generated_fast_labels.push_back(&&RomLine1054);
        main_exec_generated_fast_labels.push_back(&&RomLine1055);
        main_exec_generated_fast_labels.push_back(&&RomLine1056);
        main_exec_generated_fast_labels.push_back(&&RomLine1057);
        main_exec_generated_fast_labels.push_back(&&RomLine1058);
        main_exec_generated_fast_labels.push_back(&&RomLine1059);
        main_exec_generated_fast_labels.push_back(&&RomLine1060);
        main_exec_generated_fast_labels.push_back(&&RomLine1061);
        main_exec_generated_fast_labels.push_back(&&RomLine1062);
        main_exec_generated_fast_labels.push_back(&&RomLine1063);
        main_exec_generated_fast_labels.push_back(&&RomLine1064);
        main_exec_generated_fast_labels.push_back(&&RomLine1065);
        main_exec_generated_fast_labels.push_back(&&RomLine1066);
        main_exec_generated_fast_labels.push_back(&&RomLine1067);
        main_exec_generated_fast_labels.push_back(&&RomLine1068);
        main_exec_generated_fast_labels.push_back(&&RomLine1069);
        main_exec_generated_fast_labels.push_back(&&RomLine1070);
        main_exec_generated_fast_labels.push_back(&&RomLine1071);
        main_exec_generated_fast_labels.push_back(&&RomLine1072);
        main_exec_generated_fast_labels.push_back(&&RomLine1073);
        main_exec_generated_fast_labels.push_back(&&RomLine1074);
        main_exec_generated_fast_labels.push_back(&&RomLine1075);
        main_exec_generated_fast_labels.push_back(&&RomLine1076);
        main_exec_generated_fast_labels.push_back(&&RomLine1077);
        main_exec_generated_fast_labels.push_back(&&RomLine1078);
        main_exec_generated_fast_labels.push_back(&&RomLine1079);
        main_exec_generated_fast_labels.push_back(&&RomLine1080);
        main_exec_generated_fast_labels.push_back(&&RomLine1081);
        main_exec_generated_fast_labels.push_back(&&RomLine1082);
        main_exec_generated_fast_labels.push_back(&&RomLine1083);
        main_exec_generated_fast_labels.push_back(&&RomLine1084);
        main_exec_generated_fast_labels.push_back(&&RomLine1085);
        main_exec_generated_fast_labels.push_back(&&RomLine1086);
        main_exec_generated_fast_labels.push_back(&&RomLine1087);
        main_exec_generated_fast_labels.push_back(&&RomLine1088);
        main_exec_generated_fast_labels.push_back(&&RomLine1089);
        main_exec_generated_fast_labels.push_back(&&RomLine1090);
        main_exec_generated_fast_labels.push_back(&&RomLine1091);
        main_exec_generated_fast_labels.push_back(&&RomLine1092);
        main_exec_generated_fast_labels.push_back(&&RomLine1093);
        main_exec_generated_fast_labels.push_back(&&RomLine1094);
        main_exec_generated_fast_labels.push_back(&&RomLine1095);
        main_exec_generated_fast_labels.push_back(&&RomLine1096);
        main_exec_generated_fast_labels.push_back(&&RomLine1097);
        main_exec_generated_fast_labels.push_back(&&RomLine1098);
        main_exec_generated_fast_labels.push_back(&&RomLine1099);
        main_exec_generated_fast_labels.push_back(&&RomLine1100);
        main_exec_generated_fast_labels.push_back(&&RomLine1101);
        main_exec_generated_fast_labels.push_back(&&RomLine1102);
        main_exec_generated_fast_labels.push_back(&&RomLine1103);
        main_exec_generated_fast_labels.push_back(&&RomLine1104);
        main_exec_generated_fast_labels.push_back(&&RomLine1105);
        main_exec_generated_fast_labels.push_back(&&RomLine1106);
        main_exec_generated_fast_labels.push_back(&&RomLine1107);
        main_exec_generated_fast_labels.push_back(&&RomLine1108);
        main_exec_generated_fast_labels.push_back(&&RomLine1109);
        main_exec_generated_fast_labels.push_back(&&RomLine1110);
        main_exec_generated_fast_labels.push_back(&&RomLine1111);
        main_exec_generated_fast_labels.push_back(&&RomLine1112);
        main_exec_generated_fast_labels.push_back(&&RomLine1113);
        main_exec_generated_fast_labels.push_back(&&RomLine1114);
        main_exec_generated_fast_labels.push_back(&&RomLine1115);
        main_exec_generated_fast_labels.push_back(&&RomLine1116);
        main_exec_generated_fast_labels.push_back(&&RomLine1117);
        main_exec_generated_fast_labels.push_back(&&RomLine1118);
        main_exec_generated_fast_labels.push_back(&&RomLine1119);
        main_exec_generated_fast_labels.push_back(&&RomLine1120);
        main_exec_generated_fast_labels.push_back(&&RomLine1121);
        main_exec_generated_fast_labels.push_back(&&RomLine1122);
        main_exec_generated_fast_labels.push_back(&&RomLine1123);
        main_exec_generated_fast_labels.push_back(&&RomLine1124);
        main_exec_generated_fast_labels.push_back(&&RomLine1125);
        main_exec_generated_fast_labels.push_back(&&RomLine1126);
        main_exec_generated_fast_labels.push_back(&&RomLine1127);
        main_exec_generated_fast_labels.push_back(&&RomLine1128);
        main_exec_generated_fast_labels.push_back(&&RomLine1129);
        main_exec_generated_fast_labels.push_back(&&RomLine1130);
        main_exec_generated_fast_labels.push_back(&&RomLine1131);
        main_exec_generated_fast_labels.push_back(&&RomLine1132);
        main_exec_generated_fast_labels.push_back(&&RomLine1133);
        main_exec_generated_fast_labels.push_back(&&RomLine1134);
        main_exec_generated_fast_labels.push_back(&&RomLine1135);
        main_exec_generated_fast_labels.push_back(&&RomLine1136);
        main_exec_generated_fast_labels.push_back(&&RomLine1137);
        main_exec_generated_fast_labels.push_back(&&RomLine1138);
        main_exec_generated_fast_labels.push_back(&&RomLine1139);
        main_exec_generated_fast_labels.push_back(&&RomLine1140);
        main_exec_generated_fast_labels.push_back(&&RomLine1141);
        main_exec_generated_fast_labels.push_back(&&RomLine1142);
        main_exec_generated_fast_labels.push_back(&&RomLine1143);
        main_exec_generated_fast_labels.push_back(&&RomLine1144);
        main_exec_generated_fast_labels.push_back(&&RomLine1145);
        main_exec_generated_fast_labels.push_back(&&RomLine1146);
        main_exec_generated_fast_labels.push_back(&&RomLine1147);
        main_exec_generated_fast_labels.push_back(&&RomLine1148);
        main_exec_generated_fast_labels.push_back(&&RomLine1149);
        main_exec_generated_fast_labels.push_back(&&RomLine1150);
        main_exec_generated_fast_labels.push_back(&&RomLine1151);
        main_exec_generated_fast_labels.push_back(&&RomLine1152);
        main_exec_generated_fast_labels.push_back(&&RomLine1153);
        main_exec_generated_fast_labels.push_back(&&RomLine1154);
        main_exec_generated_fast_labels.push_back(&&RomLine1155);
        main_exec_generated_fast_labels.push_back(&&RomLine1156);
        main_exec_generated_fast_labels.push_back(&&RomLine1157);
        main_exec_generated_fast_labels.push_back(&&RomLine1158);
        main_exec_generated_fast_labels.push_back(&&RomLine1159);
        main_exec_generated_fast_labels.push_back(&&RomLine1160);
        main_exec_generated_fast_labels.push_back(&&RomLine1161);
        main_exec_generated_fast_labels.push_back(&&RomLine1162);
        main_exec_generated_fast_labels.push_back(&&RomLine1163);
        main_exec_generated_fast_labels.push_back(&&RomLine1164);
        main_exec_generated_fast_labels.push_back(&&RomLine1165);
        main_exec_generated_fast_labels.push_back(&&RomLine1166);
        main_exec_generated_fast_labels.push_back(&&RomLine1167);
        main_exec_generated_fast_labels.push_back(&&RomLine1168);
        main_exec_generated_fast_labels.push_back(&&RomLine1169);
        main_exec_generated_fast_labels.push_back(&&RomLine1170);
        main_exec_generated_fast_labels.push_back(&&RomLine1171);
        main_exec_generated_fast_labels.push_back(&&RomLine1172);
        main_exec_generated_fast_labels.push_back(&&RomLine1173);
        main_exec_generated_fast_labels.push_back(&&RomLine1174);
        main_exec_generated_fast_labels.push_back(&&RomLine1175);
        main_exec_generated_fast_labels.push_back(&&RomLine1176);
        main_exec_generated_fast_labels.push_back(&&RomLine1177);
        main_exec_generated_fast_labels.push_back(&&RomLine1178);
        main_exec_generated_fast_labels.push_back(&&RomLine1179);
        main_exec_generated_fast_labels.push_back(&&RomLine1180);
        main_exec_generated_fast_labels.push_back(&&RomLine1181);
        main_exec_generated_fast_labels.push_back(&&RomLine1182);
        main_exec_generated_fast_labels.push_back(&&RomLine1183);
        main_exec_generated_fast_labels.push_back(&&RomLine1184);
        main_exec_generated_fast_labels.push_back(&&RomLine1185);
        main_exec_generated_fast_labels.push_back(&&RomLine1186);
        main_exec_generated_fast_labels.push_back(&&RomLine1187);
        main_exec_generated_fast_labels.push_back(&&RomLine1188);
        main_exec_generated_fast_labels.push_back(&&RomLine1189);
        main_exec_generated_fast_labels.push_back(&&RomLine1190);
        main_exec_generated_fast_labels.push_back(&&RomLine1191);
        main_exec_generated_fast_labels.push_back(&&RomLine1192);
        main_exec_generated_fast_labels.push_back(&&RomLine1193);
        main_exec_generated_fast_labels.push_back(&&RomLine1194);
        main_exec_generated_fast_labels.push_back(&&RomLine1195);
        main_exec_generated_fast_labels.push_back(&&RomLine1196);
        main_exec_generated_fast_labels.push_back(&&RomLine1197);
        main_exec_generated_fast_labels.push_back(&&RomLine1198);
        main_exec_generated_fast_labels.push_back(&&RomLine1199);
        main_exec_generated_fast_labels.push_back(&&RomLine1200);
        main_exec_generated_fast_labels.push_back(&&RomLine1201);
        main_exec_generated_fast_labels.push_back(&&RomLine1202);
        main_exec_generated_fast_labels.push_back(&&RomLine1203);
        main_exec_generated_fast_labels.push_back(&&RomLine1204);
        main_exec_generated_fast_labels.push_back(&&RomLine1205);
        main_exec_generated_fast_labels.push_back(&&RomLine1206);
        main_exec_generated_fast_labels.push_back(&&RomLine1207);
        main_exec_generated_fast_labels.push_back(&&RomLine1208);
        main_exec_generated_fast_labels.push_back(&&RomLine1209);
        main_exec_generated_fast_labels.push_back(&&RomLine1210);
        main_exec_generated_fast_labels.push_back(&&RomLine1211);
        main_exec_generated_fast_labels.push_back(&&RomLine1212);
        main_exec_generated_fast_labels.push_back(&&RomLine1213);
        main_exec_generated_fast_labels.push_back(&&RomLine1214);
        main_exec_generated_fast_labels.push_back(&&RomLine1215);
        main_exec_generated_fast_labels.push_back(&&RomLine1216);
        main_exec_generated_fast_labels.push_back(&&RomLine1217);
        main_exec_generated_fast_labels.push_back(&&RomLine1218);
        main_exec_generated_fast_labels.push_back(&&RomLine1219);
        main_exec_generated_fast_labels.push_back(&&RomLine1220);
        main_exec_generated_fast_labels.push_back(&&RomLine1221);
        main_exec_generated_fast_labels.push_back(&&RomLine1222);
        main_exec_generated_fast_labels.push_back(&&RomLine1223);
        main_exec_generated_fast_labels.push_back(&&RomLine1224);
        main_exec_generated_fast_labels.push_back(&&RomLine1225);
        main_exec_generated_fast_labels.push_back(&&RomLine1226);
        main_exec_generated_fast_labels.push_back(&&RomLine1227);
        main_exec_generated_fast_labels.push_back(&&RomLine1228);
        main_exec_generated_fast_labels.push_back(&&RomLine1229);
        main_exec_generated_fast_labels.push_back(&&RomLine1230);
        main_exec_generated_fast_labels.push_back(&&RomLine1231);
        main_exec_generated_fast_labels.push_back(&&RomLine1232);
        main_exec_generated_fast_labels.push_back(&&RomLine1233);
        main_exec_generated_fast_labels.push_back(&&RomLine1234);
        main_exec_generated_fast_labels.push_back(&&RomLine1235);
        main_exec_generated_fast_labels.push_back(&&RomLine1236);
        main_exec_generated_fast_labels.push_back(&&RomLine1237);
        main_exec_generated_fast_labels.push_back(&&RomLine1238);
        main_exec_generated_fast_labels.push_back(&&RomLine1239);
        main_exec_generated_fast_labels.push_back(&&RomLine1240);
        main_exec_generated_fast_labels.push_back(&&RomLine1241);
        main_exec_generated_fast_labels.push_back(&&RomLine1242);
        main_exec_generated_fast_labels.push_back(&&RomLine1243);
        main_exec_generated_fast_labels.push_back(&&RomLine1244);
        main_exec_generated_fast_labels.push_back(&&RomLine1245);
        main_exec_generated_fast_labels.push_back(&&RomLine1246);
        main_exec_generated_fast_labels.push_back(&&RomLine1247);
        main_exec_generated_fast_labels.push_back(&&RomLine1248);
        main_exec_generated_fast_labels.push_back(&&RomLine1249);
        main_exec_generated_fast_labels.push_back(&&RomLine1250);
        main_exec_generated_fast_labels.push_back(&&RomLine1251);
        main_exec_generated_fast_labels.push_back(&&RomLine1252);
        main_exec_generated_fast_labels.push_back(&&RomLine1253);
        main_exec_generated_fast_labels.push_back(&&RomLine1254);
        main_exec_generated_fast_labels.push_back(&&RomLine1255);
        main_exec_generated_fast_labels.push_back(&&RomLine1256);
        main_exec_generated_fast_labels.push_back(&&RomLine1257);
        main_exec_generated_fast_labels.push_back(&&RomLine1258);
        main_exec_generated_fast_labels.push_back(&&RomLine1259);
        main_exec_generated_fast_labels.push_back(&&RomLine1260);
        main_exec_generated_fast_labels.push_back(&&RomLine1261);
        main_exec_generated_fast_labels.push_back(&&RomLine1262);
        main_exec_generated_fast_labels.push_back(&&RomLine1263);
        main_exec_generated_fast_labels.push_back(&&RomLine1264);
        main_exec_generated_fast_labels.push_back(&&RomLine1265);
        main_exec_generated_fast_labels.push_back(&&RomLine1266);
        main_exec_generated_fast_labels.push_back(&&RomLine1267);
        main_exec_generated_fast_labels.push_back(&&RomLine1268);
        main_exec_generated_fast_labels.push_back(&&RomLine1269);
        main_exec_generated_fast_labels.push_back(&&RomLine1270);
        main_exec_generated_fast_labels.push_back(&&RomLine1271);
        main_exec_generated_fast_labels.push_back(&&RomLine1272);
        main_exec_generated_fast_labels.push_back(&&RomLine1273);
        main_exec_generated_fast_labels.push_back(&&RomLine1274);
        main_exec_generated_fast_labels.push_back(&&RomLine1275);
        main_exec_generated_fast_labels.push_back(&&RomLine1276);
        main_exec_generated_fast_labels.push_back(&&RomLine1277);
        main_exec_generated_fast_labels.push_back(&&RomLine1278);
        main_exec_generated_fast_labels.push_back(&&RomLine1279);
        main_exec_generated_fast_labels.push_back(&&RomLine1280);
        main_exec_generated_fast_labels.push_back(&&RomLine1281);
        main_exec_generated_fast_labels.push_back(&&RomLine1282);
        main_exec_generated_fast_labels.push_back(&&RomLine1283);
        main_exec_generated_fast_labels.push_back(&&RomLine1284);
        main_exec_generated_fast_labels.push_back(&&RomLine1285);
        main_exec_generated_fast_labels.push_back(&&RomLine1286);
        main_exec_generated_fast_labels.push_back(&&RomLine1287);
        main_exec_generated_fast_labels.push_back(&&RomLine1288);
        main_exec_generated_fast_labels.push_back(&&RomLine1289);
        main_exec_generated_fast_labels.push_back(&&RomLine1290);
        main_exec_generated_fast_labels.push_back(&&RomLine1291);
        main_exec_generated_fast_labels.push_back(&&RomLine1292);
        main_exec_generated_fast_labels.push_back(&&RomLine1293);
        main_exec_generated_fast_labels.push_back(&&RomLine1294);
        main_exec_generated_fast_labels.push_back(&&RomLine1295);
        main_exec_generated_fast_labels.push_back(&&RomLine1296);
        main_exec_generated_fast_labels.push_back(&&RomLine1297);
        main_exec_generated_fast_labels.push_back(&&RomLine1298);
        main_exec_generated_fast_labels.push_back(&&RomLine1299);
        main_exec_generated_fast_labels.push_back(&&RomLine1300);
        main_exec_generated_fast_labels.push_back(&&RomLine1301);
        main_exec_generated_fast_labels.push_back(&&RomLine1302);
        main_exec_generated_fast_labels.push_back(&&RomLine1303);
        main_exec_generated_fast_labels.push_back(&&RomLine1304);
        main_exec_generated_fast_labels.push_back(&&RomLine1305);
        main_exec_generated_fast_labels.push_back(&&RomLine1306);
        main_exec_generated_fast_labels.push_back(&&RomLine1307);
        main_exec_generated_fast_labels.push_back(&&RomLine1308);
        main_exec_generated_fast_labels.push_back(&&RomLine1309);
        main_exec_generated_fast_labels.push_back(&&RomLine1310);
        main_exec_generated_fast_labels.push_back(&&RomLine1311);
        main_exec_generated_fast_labels.push_back(&&RomLine1312);
        main_exec_generated_fast_labels.push_back(&&RomLine1313);
        main_exec_generated_fast_labels.push_back(&&RomLine1314);
        main_exec_generated_fast_labels.push_back(&&RomLine1315);
        main_exec_generated_fast_labels.push_back(&&RomLine1316);
        main_exec_generated_fast_labels.push_back(&&RomLine1317);
        main_exec_generated_fast_labels.push_back(&&RomLine1318);
        main_exec_generated_fast_labels.push_back(&&RomLine1319);
        main_exec_generated_fast_labels.push_back(&&RomLine1320);
        main_exec_generated_fast_labels.push_back(&&RomLine1321);
        main_exec_generated_fast_labels.push_back(&&RomLine1322);
        main_exec_generated_fast_labels.push_back(&&RomLine1323);
        main_exec_generated_fast_labels.push_back(&&RomLine1324);
        main_exec_generated_fast_labels.push_back(&&RomLine1325);
        main_exec_generated_fast_labels.push_back(&&RomLine1326);
        main_exec_generated_fast_labels.push_back(&&RomLine1327);
        main_exec_generated_fast_labels.push_back(&&RomLine1328);
        main_exec_generated_fast_labels.push_back(&&RomLine1329);
        main_exec_generated_fast_labels.push_back(&&RomLine1330);
        main_exec_generated_fast_labels.push_back(&&RomLine1331);
        main_exec_generated_fast_labels.push_back(&&RomLine1332);
        main_exec_generated_fast_labels.push_back(&&RomLine1333);
        main_exec_generated_fast_labels.push_back(&&RomLine1334);
        main_exec_generated_fast_labels.push_back(&&RomLine1335);
        main_exec_generated_fast_labels.push_back(&&RomLine1336);
        main_exec_generated_fast_labels.push_back(&&RomLine1337);
        main_exec_generated_fast_labels.push_back(&&RomLine1338);
        main_exec_generated_fast_labels.push_back(&&RomLine1339);
        main_exec_generated_fast_labels.push_back(&&RomLine1340);
        main_exec_generated_fast_labels.push_back(&&RomLine1341);
        main_exec_generated_fast_labels.push_back(&&RomLine1342);
        main_exec_generated_fast_labels.push_back(&&RomLine1343);
        main_exec_generated_fast_labels.push_back(&&RomLine1344);
        main_exec_generated_fast_labels.push_back(&&RomLine1345);
        main_exec_generated_fast_labels.push_back(&&RomLine1346);
        main_exec_generated_fast_labels.push_back(&&RomLine1347);
        main_exec_generated_fast_labels.push_back(&&RomLine1348);
        main_exec_generated_fast_labels.push_back(&&RomLine1349);
        main_exec_generated_fast_labels.push_back(&&RomLine1350);
        main_exec_generated_fast_labels.push_back(&&RomLine1351);
        main_exec_generated_fast_labels.push_back(&&RomLine1352);
        main_exec_generated_fast_labels.push_back(&&RomLine1353);
        main_exec_generated_fast_labels.push_back(&&RomLine1354);
        main_exec_generated_fast_labels.push_back(&&RomLine1355);
        main_exec_generated_fast_labels.push_back(&&RomLine1356);
        main_exec_generated_fast_labels.push_back(&&RomLine1357);
        main_exec_generated_fast_labels.push_back(&&RomLine1358);
        main_exec_generated_fast_labels.push_back(&&RomLine1359);
        main_exec_generated_fast_labels.push_back(&&RomLine1360);
        main_exec_generated_fast_labels.push_back(&&RomLine1361);
        main_exec_generated_fast_labels.push_back(&&RomLine1362);
        main_exec_generated_fast_labels.push_back(&&RomLine1363);
        main_exec_generated_fast_labels.push_back(&&RomLine1364);
        main_exec_generated_fast_labels.push_back(&&RomLine1365);
        main_exec_generated_fast_labels.push_back(&&RomLine1366);
        main_exec_generated_fast_labels.push_back(&&RomLine1367);
        main_exec_generated_fast_labels.push_back(&&RomLine1368);
        main_exec_generated_fast_labels.push_back(&&RomLine1369);
        main_exec_generated_fast_labels.push_back(&&RomLine1370);
        main_exec_generated_fast_labels.push_back(&&RomLine1371);
        main_exec_generated_fast_labels.push_back(&&RomLine1372);
        main_exec_generated_fast_labels.push_back(&&RomLine1373);
        main_exec_generated_fast_labels.push_back(&&RomLine1374);
        main_exec_generated_fast_labels.push_back(&&RomLine1375);
        main_exec_generated_fast_labels.push_back(&&RomLine1376);
        main_exec_generated_fast_labels.push_back(&&RomLine1377);
        main_exec_generated_fast_labels.push_back(&&RomLine1378);
        main_exec_generated_fast_labels.push_back(&&RomLine1379);
        main_exec_generated_fast_labels.push_back(&&RomLine1380);
        main_exec_generated_fast_labels.push_back(&&RomLine1381);
        main_exec_generated_fast_labels.push_back(&&RomLine1382);
        main_exec_generated_fast_labels.push_back(&&RomLine1383);
        main_exec_generated_fast_labels.push_back(&&RomLine1384);
        main_exec_generated_fast_labels.push_back(&&RomLine1385);
        main_exec_generated_fast_labels.push_back(&&RomLine1386);
        main_exec_generated_fast_labels.push_back(&&RomLine1387);
        main_exec_generated_fast_labels.push_back(&&RomLine1388);
        main_exec_generated_fast_labels.push_back(&&RomLine1389);
        main_exec_generated_fast_labels.push_back(&&RomLine1390);
        main_exec_generated_fast_labels.push_back(&&RomLine1391);
        main_exec_generated_fast_labels.push_back(&&RomLine1392);
        main_exec_generated_fast_labels.push_back(&&RomLine1393);
        main_exec_generated_fast_labels.push_back(&&RomLine1394);
        main_exec_generated_fast_labels.push_back(&&RomLine1395);
        main_exec_generated_fast_labels.push_back(&&RomLine1396);
        main_exec_generated_fast_labels.push_back(&&RomLine1397);
        main_exec_generated_fast_labels.push_back(&&RomLine1398);
        main_exec_generated_fast_labels.push_back(&&RomLine1399);
        main_exec_generated_fast_labels.push_back(&&RomLine1400);
        main_exec_generated_fast_labels.push_back(&&RomLine1401);
        main_exec_generated_fast_labels.push_back(&&RomLine1402);
        main_exec_generated_fast_labels.push_back(&&RomLine1403);
        main_exec_generated_fast_labels.push_back(&&RomLine1404);
        main_exec_generated_fast_labels.push_back(&&RomLine1405);
        main_exec_generated_fast_labels.push_back(&&RomLine1406);
        main_exec_generated_fast_labels.push_back(&&RomLine1407);
        main_exec_generated_fast_labels.push_back(&&RomLine1408);
        main_exec_generated_fast_labels.push_back(&&RomLine1409);
        main_exec_generated_fast_labels.push_back(&&RomLine1410);
        main_exec_generated_fast_labels.push_back(&&RomLine1411);
        main_exec_generated_fast_labels.push_back(&&RomLine1412);
        main_exec_generated_fast_labels.push_back(&&RomLine1413);
        main_exec_generated_fast_labels.push_back(&&RomLine1414);
        main_exec_generated_fast_labels.push_back(&&RomLine1415);
        main_exec_generated_fast_labels.push_back(&&RomLine1416);
        main_exec_generated_fast_labels.push_back(&&RomLine1417);
        main_exec_generated_fast_labels.push_back(&&RomLine1418);
        main_exec_generated_fast_labels.push_back(&&RomLine1419);
        main_exec_generated_fast_labels.push_back(&&RomLine1420);
        main_exec_generated_fast_labels.push_back(&&RomLine1421);
        main_exec_generated_fast_labels.push_back(&&RomLine1422);
        main_exec_generated_fast_labels.push_back(&&RomLine1423);
        main_exec_generated_fast_labels.push_back(&&RomLine1424);
        main_exec_generated_fast_labels.push_back(&&RomLine1425);
        main_exec_generated_fast_labels.push_back(&&RomLine1426);
        main_exec_generated_fast_labels.push_back(&&RomLine1427);
        main_exec_generated_fast_labels.push_back(&&RomLine1428);
        main_exec_generated_fast_labels.push_back(&&RomLine1429);
        main_exec_generated_fast_labels.push_back(&&RomLine1430);
        main_exec_generated_fast_labels.push_back(&&RomLine1431);
        main_exec_generated_fast_labels.push_back(&&RomLine1432);
        main_exec_generated_fast_labels.push_back(&&RomLine1433);
        main_exec_generated_fast_labels.push_back(&&RomLine1434);
        main_exec_generated_fast_labels.push_back(&&RomLine1435);
        main_exec_generated_fast_labels.push_back(&&RomLine1436);
        main_exec_generated_fast_labels.push_back(&&RomLine1437);
        main_exec_generated_fast_labels.push_back(&&RomLine1438);
        main_exec_generated_fast_labels.push_back(&&RomLine1439);
        main_exec_generated_fast_labels.push_back(&&RomLine1440);
        main_exec_generated_fast_labels.push_back(&&RomLine1441);
        main_exec_generated_fast_labels.push_back(&&RomLine1442);
        main_exec_generated_fast_labels.push_back(&&RomLine1443);
        main_exec_generated_fast_labels.push_back(&&RomLine1444);
        main_exec_generated_fast_labels.push_back(&&RomLine1445);
        main_exec_generated_fast_labels.push_back(&&RomLine1446);
        main_exec_generated_fast_labels.push_back(&&RomLine1447);
        main_exec_generated_fast_labels.push_back(&&RomLine1448);
        main_exec_generated_fast_labels.push_back(&&RomLine1449);
        main_exec_generated_fast_labels.push_back(&&RomLine1450);
        main_exec_generated_fast_labels.push_back(&&RomLine1451);
        main_exec_generated_fast_labels.push_back(&&RomLine1452);
        main_exec_generated_fast_labels.push_back(&&RomLine1453);
        main_exec_generated_fast_labels.push_back(&&RomLine1454);
        main_exec_generated_fast_labels.push_back(&&RomLine1455);
        main_exec_generated_fast_labels.push_back(&&RomLine1456);
        main_exec_generated_fast_labels.push_back(&&RomLine1457);
        main_exec_generated_fast_labels.push_back(&&RomLine1458);
        main_exec_generated_fast_labels.push_back(&&RomLine1459);
        main_exec_generated_fast_labels.push_back(&&RomLine1460);
        main_exec_generated_fast_labels.push_back(&&RomLine1461);
        main_exec_generated_fast_labels.push_back(&&RomLine1462);
        main_exec_generated_fast_labels.push_back(&&RomLine1463);
        main_exec_generated_fast_labels.push_back(&&RomLine1464);
        main_exec_generated_fast_labels.push_back(&&RomLine1465);
        main_exec_generated_fast_labels.push_back(&&RomLine1466);
        main_exec_generated_fast_labels.push_back(&&RomLine1467);
        main_exec_generated_fast_labels.push_back(&&RomLine1468);
        main_exec_generated_fast_labels.push_back(&&RomLine1469);
        main_exec_generated_fast_labels.push_back(&&RomLine1470);
        main_exec_generated_fast_labels.push_back(&&RomLine1471);
        main_exec_generated_fast_labels.push_back(&&RomLine1472);
        main_exec_generated_fast_labels.push_back(&&RomLine1473);
        main_exec_generated_fast_labels.push_back(&&RomLine1474);
        main_exec_generated_fast_labels.push_back(&&RomLine1475);
        main_exec_generated_fast_labels.push_back(&&RomLine1476);
        main_exec_generated_fast_labels.push_back(&&RomLine1477);
        main_exec_generated_fast_labels.push_back(&&RomLine1478);
        main_exec_generated_fast_labels.push_back(&&RomLine1479);
        main_exec_generated_fast_labels.push_back(&&RomLine1480);
        main_exec_generated_fast_labels.push_back(&&RomLine1481);
        main_exec_generated_fast_labels.push_back(&&RomLine1482);
        main_exec_generated_fast_labels.push_back(&&RomLine1483);
        main_exec_generated_fast_labels.push_back(&&RomLine1484);
        main_exec_generated_fast_labels.push_back(&&RomLine1485);
        main_exec_generated_fast_labels.push_back(&&RomLine1486);
        main_exec_generated_fast_labels.push_back(&&RomLine1487);
        main_exec_generated_fast_labels.push_back(&&RomLine1488);
        main_exec_generated_fast_labels.push_back(&&RomLine1489);
        main_exec_generated_fast_labels.push_back(&&RomLine1490);
        main_exec_generated_fast_labels.push_back(&&RomLine1491);
        main_exec_generated_fast_labels.push_back(&&RomLine1492);
        main_exec_generated_fast_labels.push_back(&&RomLine1493);
        main_exec_generated_fast_labels.push_back(&&RomLine1494);
        main_exec_generated_fast_labels.push_back(&&RomLine1495);
        main_exec_generated_fast_labels.push_back(&&RomLine1496);
        main_exec_generated_fast_labels.push_back(&&RomLine1497);
        main_exec_generated_fast_labels.push_back(&&RomLine1498);
        main_exec_generated_fast_labels.push_back(&&RomLine1499);
        main_exec_generated_fast_labels.push_back(&&RomLine1500);
        main_exec_generated_fast_labels.push_back(&&RomLine1501);
        main_exec_generated_fast_labels.push_back(&&RomLine1502);
        main_exec_generated_fast_labels.push_back(&&RomLine1503);
        main_exec_generated_fast_labels.push_back(&&RomLine1504);
        main_exec_generated_fast_labels.push_back(&&RomLine1505);
        main_exec_generated_fast_labels.push_back(&&RomLine1506);
        main_exec_generated_fast_labels.push_back(&&RomLine1507);
        main_exec_generated_fast_labels.push_back(&&RomLine1508);
        main_exec_generated_fast_labels.push_back(&&RomLine1509);
        main_exec_generated_fast_labels.push_back(&&RomLine1510);
        main_exec_generated_fast_labels.push_back(&&RomLine1511);
        main_exec_generated_fast_labels.push_back(&&RomLine1512);
        main_exec_generated_fast_labels.push_back(&&RomLine1513);
        main_exec_generated_fast_labels.push_back(&&RomLine1514);
        main_exec_generated_fast_labels.push_back(&&RomLine1515);
        main_exec_generated_fast_labels.push_back(&&RomLine1516);
        main_exec_generated_fast_labels.push_back(&&RomLine1517);
        main_exec_generated_fast_labels.push_back(&&RomLine1518);
        main_exec_generated_fast_labels.push_back(&&RomLine1519);
        main_exec_generated_fast_labels.push_back(&&RomLine1520);
        main_exec_generated_fast_labels.push_back(&&RomLine1521);
        main_exec_generated_fast_labels.push_back(&&RomLine1522);
        main_exec_generated_fast_labels.push_back(&&RomLine1523);
        main_exec_generated_fast_labels.push_back(&&RomLine1524);
        main_exec_generated_fast_labels.push_back(&&RomLine1525);
        main_exec_generated_fast_labels.push_back(&&RomLine1526);
        main_exec_generated_fast_labels.push_back(&&RomLine1527);
        main_exec_generated_fast_labels.push_back(&&RomLine1528);
        main_exec_generated_fast_labels.push_back(&&RomLine1529);
        main_exec_generated_fast_labels.push_back(&&RomLine1530);
        main_exec_generated_fast_labels.push_back(&&RomLine1531);
        main_exec_generated_fast_labels.push_back(&&RomLine1532);
        main_exec_generated_fast_labels.push_back(&&RomLine1533);
        main_exec_generated_fast_labels.push_back(&&RomLine1534);
        main_exec_generated_fast_labels.push_back(&&RomLine1535);
        main_exec_generated_fast_labels.push_back(&&RomLine1536);
        main_exec_generated_fast_labels.push_back(&&RomLine1537);
        main_exec_generated_fast_labels.push_back(&&RomLine1538);
        main_exec_generated_fast_labels.push_back(&&RomLine1539);
        main_exec_generated_fast_labels.push_back(&&RomLine1540);
        main_exec_generated_fast_labels.push_back(&&RomLine1541);
        main_exec_generated_fast_labels.push_back(&&RomLine1542);
        main_exec_generated_fast_labels.push_back(&&RomLine1543);
        main_exec_generated_fast_labels.push_back(&&RomLine1544);
        main_exec_generated_fast_labels.push_back(&&RomLine1545);
        main_exec_generated_fast_labels.push_back(&&RomLine1546);
        main_exec_generated_fast_labels.push_back(&&RomLine1547);
        main_exec_generated_fast_labels.push_back(&&RomLine1548);
        main_exec_generated_fast_labels.push_back(&&RomLine1549);
        main_exec_generated_fast_labels.push_back(&&RomLine1550);
        main_exec_generated_fast_labels.push_back(&&RomLine1551);
        main_exec_generated_fast_labels.push_back(&&RomLine1552);
        main_exec_generated_fast_labels.push_back(&&RomLine1553);
        main_exec_generated_fast_labels.push_back(&&RomLine1554);
        main_exec_generated_fast_labels.push_back(&&RomLine1555);
        main_exec_generated_fast_labels.push_back(&&RomLine1556);
        main_exec_generated_fast_labels.push_back(&&RomLine1557);
        main_exec_generated_fast_labels.push_back(&&RomLine1558);
        main_exec_generated_fast_labels.push_back(&&RomLine1559);
        main_exec_generated_fast_labels.push_back(&&RomLine1560);
        main_exec_generated_fast_labels.push_back(&&RomLine1561);
        main_exec_generated_fast_labels.push_back(&&RomLine1562);
        main_exec_generated_fast_labels.push_back(&&RomLine1563);
        main_exec_generated_fast_labels.push_back(&&RomLine1564);
        main_exec_generated_fast_labels.push_back(&&RomLine1565);
        main_exec_generated_fast_labels.push_back(&&RomLine1566);
        main_exec_generated_fast_labels.push_back(&&RomLine1567);
        main_exec_generated_fast_labels.push_back(&&RomLine1568);
        main_exec_generated_fast_labels.push_back(&&RomLine1569);
        main_exec_generated_fast_labels.push_back(&&RomLine1570);
        main_exec_generated_fast_labels.push_back(&&RomLine1571);
        main_exec_generated_fast_labels.push_back(&&RomLine1572);
        main_exec_generated_fast_labels.push_back(&&RomLine1573);
        main_exec_generated_fast_labels.push_back(&&RomLine1574);
        main_exec_generated_fast_labels.push_back(&&RomLine1575);
        main_exec_generated_fast_labels.push_back(&&RomLine1576);
        main_exec_generated_fast_labels.push_back(&&RomLine1577);
        main_exec_generated_fast_labels.push_back(&&RomLine1578);
        main_exec_generated_fast_labels.push_back(&&RomLine1579);
        main_exec_generated_fast_labels.push_back(&&RomLine1580);
        main_exec_generated_fast_labels.push_back(&&RomLine1581);
        main_exec_generated_fast_labels.push_back(&&RomLine1582);
        main_exec_generated_fast_labels.push_back(&&RomLine1583);
        main_exec_generated_fast_labels.push_back(&&RomLine1584);
        main_exec_generated_fast_labels.push_back(&&RomLine1585);
        main_exec_generated_fast_labels.push_back(&&RomLine1586);
        main_exec_generated_fast_labels.push_back(&&RomLine1587);
        main_exec_generated_fast_labels.push_back(&&RomLine1588);
        main_exec_generated_fast_labels.push_back(&&RomLine1589);
        main_exec_generated_fast_labels.push_back(&&RomLine1590);
        main_exec_generated_fast_labels.push_back(&&RomLine1591);
        main_exec_generated_fast_labels.push_back(&&RomLine1592);
        main_exec_generated_fast_labels.push_back(&&RomLine1593);
        main_exec_generated_fast_labels.push_back(&&RomLine1594);
        main_exec_generated_fast_labels.push_back(&&RomLine1595);
        main_exec_generated_fast_labels.push_back(&&RomLine1596);
        main_exec_generated_fast_labels.push_back(&&RomLine1597);
        main_exec_generated_fast_labels.push_back(&&RomLine1598);
        main_exec_generated_fast_labels.push_back(&&RomLine1599);
        main_exec_generated_fast_labels.push_back(&&RomLine1600);
        main_exec_generated_fast_labels.push_back(&&RomLine1601);
        main_exec_generated_fast_labels.push_back(&&RomLine1602);
        main_exec_generated_fast_labels.push_back(&&RomLine1603);
        main_exec_generated_fast_labels.push_back(&&RomLine1604);
        main_exec_generated_fast_labels.push_back(&&RomLine1605);
        main_exec_generated_fast_labels.push_back(&&RomLine1606);
        main_exec_generated_fast_labels.push_back(&&RomLine1607);
        main_exec_generated_fast_labels.push_back(&&RomLine1608);
        main_exec_generated_fast_labels.push_back(&&RomLine1609);
        main_exec_generated_fast_labels.push_back(&&RomLine1610);
        main_exec_generated_fast_labels.push_back(&&RomLine1611);
        main_exec_generated_fast_labels.push_back(&&RomLine1612);
        main_exec_generated_fast_labels.push_back(&&RomLine1613);
        main_exec_generated_fast_labels.push_back(&&RomLine1614);
        main_exec_generated_fast_labels.push_back(&&RomLine1615);
        main_exec_generated_fast_labels.push_back(&&RomLine1616);
        main_exec_generated_fast_labels.push_back(&&RomLine1617);
        main_exec_generated_fast_labels.push_back(&&RomLine1618);
        main_exec_generated_fast_labels.push_back(&&RomLine1619);
        main_exec_generated_fast_labels.push_back(&&RomLine1620);
        main_exec_generated_fast_labels.push_back(&&RomLine1621);
        main_exec_generated_fast_labels.push_back(&&RomLine1622);
        main_exec_generated_fast_labels.push_back(&&RomLine1623);
        main_exec_generated_fast_labels.push_back(&&RomLine1624);
        main_exec_generated_fast_labels.push_back(&&RomLine1625);
        main_exec_generated_fast_labels.push_back(&&RomLine1626);
        main_exec_generated_fast_labels.push_back(&&RomLine1627);
        main_exec_generated_fast_labels.push_back(&&RomLine1628);
        main_exec_generated_fast_labels.push_back(&&RomLine1629);
        main_exec_generated_fast_labels.push_back(&&RomLine1630);
        main_exec_generated_fast_labels.push_back(&&RomLine1631);
        main_exec_generated_fast_labels.push_back(&&RomLine1632);
        main_exec_generated_fast_labels.push_back(&&RomLine1633);
        main_exec_generated_fast_labels.push_back(&&RomLine1634);
        main_exec_generated_fast_labels.push_back(&&RomLine1635);
        main_exec_generated_fast_labels.push_back(&&RomLine1636);
        main_exec_generated_fast_labels.push_back(&&RomLine1637);
        main_exec_generated_fast_labels.push_back(&&RomLine1638);
        main_exec_generated_fast_labels.push_back(&&RomLine1639);
        main_exec_generated_fast_labels.push_back(&&RomLine1640);
        main_exec_generated_fast_labels.push_back(&&RomLine1641);
        main_exec_generated_fast_labels.push_back(&&RomLine1642);
        main_exec_generated_fast_labels.push_back(&&RomLine1643);
        main_exec_generated_fast_labels.push_back(&&RomLine1644);
        main_exec_generated_fast_labels.push_back(&&RomLine1645);
        main_exec_generated_fast_labels.push_back(&&RomLine1646);
        main_exec_generated_fast_labels.push_back(&&RomLine1647);
        main_exec_generated_fast_labels.push_back(&&RomLine1648);
        main_exec_generated_fast_labels.push_back(&&RomLine1649);
        main_exec_generated_fast_labels.push_back(&&RomLine1650);
        main_exec_generated_fast_labels.push_back(&&RomLine1651);
        main_exec_generated_fast_labels.push_back(&&RomLine1652);
        main_exec_generated_fast_labels.push_back(&&RomLine1653);
        main_exec_generated_fast_labels.push_back(&&RomLine1654);
        main_exec_generated_fast_labels.push_back(&&RomLine1655);
        main_exec_generated_fast_labels.push_back(&&RomLine1656);
        main_exec_generated_fast_labels.push_back(&&RomLine1657);
        main_exec_generated_fast_labels.push_back(&&RomLine1658);
        main_exec_generated_fast_labels.push_back(&&RomLine1659);
        main_exec_generated_fast_labels.push_back(&&RomLine1660);
        main_exec_generated_fast_labels.push_back(&&RomLine1661);
        main_exec_generated_fast_labels.push_back(&&RomLine1662);
        main_exec_generated_fast_labels.push_back(&&RomLine1663);
        main_exec_generated_fast_labels.push_back(&&RomLine1664);
        main_exec_generated_fast_labels.push_back(&&RomLine1665);
        main_exec_generated_fast_labels.push_back(&&RomLine1666);
        main_exec_generated_fast_labels.push_back(&&RomLine1667);
        main_exec_generated_fast_labels.push_back(&&RomLine1668);
        main_exec_generated_fast_labels.push_back(&&RomLine1669);
        main_exec_generated_fast_labels.push_back(&&RomLine1670);
        main_exec_generated_fast_labels.push_back(&&RomLine1671);
        main_exec_generated_fast_labels.push_back(&&RomLine1672);
        main_exec_generated_fast_labels.push_back(&&RomLine1673);
        main_exec_generated_fast_labels.push_back(&&RomLine1674);
        main_exec_generated_fast_labels.push_back(&&RomLine1675);
        main_exec_generated_fast_labels.push_back(&&RomLine1676);
        main_exec_generated_fast_labels.push_back(&&RomLine1677);
        main_exec_generated_fast_labels.push_back(&&RomLine1678);
        main_exec_generated_fast_labels.push_back(&&RomLine1679);
        main_exec_generated_fast_labels.push_back(&&RomLine1680);
        main_exec_generated_fast_labels.push_back(&&RomLine1681);
        main_exec_generated_fast_labels.push_back(&&RomLine1682);
        main_exec_generated_fast_labels.push_back(&&RomLine1683);
        main_exec_generated_fast_labels.push_back(&&RomLine1684);
        main_exec_generated_fast_labels.push_back(&&RomLine1685);
        main_exec_generated_fast_labels.push_back(&&RomLine1686);
        main_exec_generated_fast_labels.push_back(&&RomLine1687);
        main_exec_generated_fast_labels.push_back(&&RomLine1688);
        main_exec_generated_fast_labels.push_back(&&RomLine1689);
        main_exec_generated_fast_labels.push_back(&&RomLine1690);
        main_exec_generated_fast_labels.push_back(&&RomLine1691);
        main_exec_generated_fast_labels.push_back(&&RomLine1692);
        main_exec_generated_fast_labels.push_back(&&RomLine1693);
        main_exec_generated_fast_labels.push_back(&&RomLine1694);
        main_exec_generated_fast_labels.push_back(&&RomLine1695);
        main_exec_generated_fast_labels.push_back(&&RomLine1696);
        main_exec_generated_fast_labels.push_back(&&RomLine1697);
        main_exec_generated_fast_labels.push_back(&&RomLine1698);
        main_exec_generated_fast_labels.push_back(&&RomLine1699);
        main_exec_generated_fast_labels.push_back(&&RomLine1700);
        main_exec_generated_fast_labels.push_back(&&RomLine1701);
        main_exec_generated_fast_labels.push_back(&&RomLine1702);
        main_exec_generated_fast_labels.push_back(&&RomLine1703);
        main_exec_generated_fast_labels.push_back(&&RomLine1704);
        main_exec_generated_fast_labels.push_back(&&RomLine1705);
        main_exec_generated_fast_labels.push_back(&&RomLine1706);
        main_exec_generated_fast_labels.push_back(&&RomLine1707);
        main_exec_generated_fast_labels.push_back(&&RomLine1708);
        main_exec_generated_fast_labels.push_back(&&RomLine1709);
        main_exec_generated_fast_labels.push_back(&&RomLine1710);
        main_exec_generated_fast_labels.push_back(&&RomLine1711);
        main_exec_generated_fast_labels.push_back(&&RomLine1712);
        main_exec_generated_fast_labels.push_back(&&RomLine1713);
        main_exec_generated_fast_labels.push_back(&&RomLine1714);
        main_exec_generated_fast_labels.push_back(&&RomLine1715);
        main_exec_generated_fast_labels.push_back(&&RomLine1716);
        main_exec_generated_fast_labels.push_back(&&RomLine1717);
        main_exec_generated_fast_labels.push_back(&&RomLine1718);
        main_exec_generated_fast_labels.push_back(&&RomLine1719);
        main_exec_generated_fast_labels.push_back(&&RomLine1720);
        main_exec_generated_fast_labels.push_back(&&RomLine1721);
        main_exec_generated_fast_labels.push_back(&&RomLine1722);
        main_exec_generated_fast_labels.push_back(&&RomLine1723);
        main_exec_generated_fast_labels.push_back(&&RomLine1724);
        main_exec_generated_fast_labels.push_back(&&RomLine1725);
        main_exec_generated_fast_labels.push_back(&&RomLine1726);
        main_exec_generated_fast_labels.push_back(&&RomLine1727);
        main_exec_generated_fast_labels.push_back(&&RomLine1728);
        main_exec_generated_fast_labels.push_back(&&RomLine1729);
        main_exec_generated_fast_labels.push_back(&&RomLine1730);
        main_exec_generated_fast_labels.push_back(&&RomLine1731);
        main_exec_generated_fast_labels.push_back(&&RomLine1732);
        main_exec_generated_fast_labels.push_back(&&RomLine1733);
        main_exec_generated_fast_labels.push_back(&&RomLine1734);
        main_exec_generated_fast_labels.push_back(&&RomLine1735);
        main_exec_generated_fast_labels.push_back(&&RomLine1736);
        main_exec_generated_fast_labels.push_back(&&RomLine1737);
        main_exec_generated_fast_labels.push_back(&&RomLine1738);
        main_exec_generated_fast_labels.push_back(&&RomLine1739);
        main_exec_generated_fast_labels.push_back(&&RomLine1740);
        main_exec_generated_fast_labels.push_back(&&RomLine1741);
        main_exec_generated_fast_labels.push_back(&&RomLine1742);
        main_exec_generated_fast_labels.push_back(&&RomLine1743);
        main_exec_generated_fast_labels.push_back(&&RomLine1744);
        main_exec_generated_fast_labels.push_back(&&RomLine1745);
        main_exec_generated_fast_labels.push_back(&&RomLine1746);
        main_exec_generated_fast_labels.push_back(&&RomLine1747);
        main_exec_generated_fast_labels.push_back(&&RomLine1748);
        main_exec_generated_fast_labels.push_back(&&RomLine1749);
        main_exec_generated_fast_labels.push_back(&&RomLine1750);
        main_exec_generated_fast_labels.push_back(&&RomLine1751);
        main_exec_generated_fast_labels.push_back(&&RomLine1752);
        main_exec_generated_fast_labels.push_back(&&RomLine1753);
        main_exec_generated_fast_labels.push_back(&&RomLine1754);
        main_exec_generated_fast_labels.push_back(&&RomLine1755);
        main_exec_generated_fast_labels.push_back(&&RomLine1756);
        main_exec_generated_fast_labels.push_back(&&RomLine1757);
        main_exec_generated_fast_labels.push_back(&&RomLine1758);
        main_exec_generated_fast_labels.push_back(&&RomLine1759);
        main_exec_generated_fast_labels.push_back(&&RomLine1760);
        main_exec_generated_fast_labels.push_back(&&RomLine1761);
        main_exec_generated_fast_labels.push_back(&&RomLine1762);
        main_exec_generated_fast_labels.push_back(&&RomLine1763);
        main_exec_generated_fast_labels.push_back(&&RomLine1764);
        main_exec_generated_fast_labels.push_back(&&RomLine1765);
        main_exec_generated_fast_labels.push_back(&&RomLine1766);
        main_exec_generated_fast_labels.push_back(&&RomLine1767);
        main_exec_generated_fast_labels.push_back(&&RomLine1768);
        main_exec_generated_fast_labels.push_back(&&RomLine1769);
        main_exec_generated_fast_labels.push_back(&&RomLine1770);
        main_exec_generated_fast_labels.push_back(&&RomLine1771);
        main_exec_generated_fast_labels.push_back(&&RomLine1772);
        main_exec_generated_fast_labels.push_back(&&RomLine1773);
        main_exec_generated_fast_labels.push_back(&&RomLine1774);
        main_exec_generated_fast_labels.push_back(&&RomLine1775);
        main_exec_generated_fast_labels.push_back(&&RomLine1776);
        main_exec_generated_fast_labels.push_back(&&RomLine1777);
        main_exec_generated_fast_labels.push_back(&&RomLine1778);
        main_exec_generated_fast_labels.push_back(&&RomLine1779);
        main_exec_generated_fast_labels.push_back(&&RomLine1780);
        main_exec_generated_fast_labels.push_back(&&RomLine1781);
        main_exec_generated_fast_labels.push_back(&&RomLine1782);
        main_exec_generated_fast_labels.push_back(&&RomLine1783);
        main_exec_generated_fast_labels.push_back(&&RomLine1784);
        main_exec_generated_fast_labels.push_back(&&RomLine1785);
        main_exec_generated_fast_labels.push_back(&&RomLine1786);
        main_exec_generated_fast_labels.push_back(&&RomLine1787);
        main_exec_generated_fast_labels.push_back(&&RomLine1788);
        main_exec_generated_fast_labels.push_back(&&RomLine1789);
        main_exec_generated_fast_labels.push_back(&&RomLine1790);
        main_exec_generated_fast_labels.push_back(&&RomLine1791);
        main_exec_generated_fast_labels.push_back(&&RomLine1792);
        main_exec_generated_fast_labels.push_back(&&RomLine1793);
        main_exec_generated_fast_labels.push_back(&&RomLine1794);
        main_exec_generated_fast_labels.push_back(&&RomLine1795);
        main_exec_generated_fast_labels.push_back(&&RomLine1796);
        main_exec_generated_fast_labels.push_back(&&RomLine1797);
        main_exec_generated_fast_labels.push_back(&&RomLine1798);
        main_exec_generated_fast_labels.push_back(&&RomLine1799);
        main_exec_generated_fast_labels.push_back(&&RomLine1800);
        main_exec_generated_fast_labels.push_back(&&RomLine1801);
        main_exec_generated_fast_labels.push_back(&&RomLine1802);
        main_exec_generated_fast_labels.push_back(&&RomLine1803);
        main_exec_generated_fast_labels.push_back(&&RomLine1804);
        main_exec_generated_fast_labels.push_back(&&RomLine1805);
        main_exec_generated_fast_labels.push_back(&&RomLine1806);
        main_exec_generated_fast_labels.push_back(&&RomLine1807);
        main_exec_generated_fast_labels.push_back(&&RomLine1808);
        main_exec_generated_fast_labels.push_back(&&RomLine1809);
        main_exec_generated_fast_labels.push_back(&&RomLine1810);
        main_exec_generated_fast_labels.push_back(&&RomLine1811);
        main_exec_generated_fast_labels.push_back(&&RomLine1812);
        main_exec_generated_fast_labels.push_back(&&RomLine1813);
        main_exec_generated_fast_labels.push_back(&&RomLine1814);
        main_exec_generated_fast_labels.push_back(&&RomLine1815);
        main_exec_generated_fast_labels.push_back(&&RomLine1816);
        main_exec_generated_fast_labels.push_back(&&RomLine1817);
        main_exec_generated_fast_labels.push_back(&&RomLine1818);
        main_exec_generated_fast_labels.push_back(&&RomLine1819);
        main_exec_generated_fast_labels.push_back(&&RomLine1820);
        main_exec_generated_fast_labels.push_back(&&RomLine1821);
        main_exec_generated_fast_labels.push_back(&&RomLine1822);
        main_exec_generated_fast_labels.push_back(&&RomLine1823);
        main_exec_generated_fast_labels.push_back(&&RomLine1824);
        main_exec_generated_fast_labels.push_back(&&RomLine1825);
        main_exec_generated_fast_labels.push_back(&&RomLine1826);
        main_exec_generated_fast_labels.push_back(&&RomLine1827);
        main_exec_generated_fast_labels.push_back(&&RomLine1828);
        main_exec_generated_fast_labels.push_back(&&RomLine1829);
        main_exec_generated_fast_labels.push_back(&&RomLine1830);
        main_exec_generated_fast_labels.push_back(&&RomLine1831);
        main_exec_generated_fast_labels.push_back(&&RomLine1832);
        main_exec_generated_fast_labels.push_back(&&RomLine1833);
        main_exec_generated_fast_labels.push_back(&&RomLine1834);
        main_exec_generated_fast_labels.push_back(&&RomLine1835);
        main_exec_generated_fast_labels.push_back(&&RomLine1836);
        main_exec_generated_fast_labels.push_back(&&RomLine1837);
        main_exec_generated_fast_labels.push_back(&&RomLine1838);
        main_exec_generated_fast_labels.push_back(&&RomLine1839);
        main_exec_generated_fast_labels.push_back(&&RomLine1840);
        main_exec_generated_fast_labels.push_back(&&RomLine1841);
        main_exec_generated_fast_labels.push_back(&&RomLine1842);
        main_exec_generated_fast_labels.push_back(&&RomLine1843);
        main_exec_generated_fast_labels.push_back(&&RomLine1844);
        main_exec_generated_fast_labels.push_back(&&RomLine1845);
        main_exec_generated_fast_labels.push_back(&&RomLine1846);
        main_exec_generated_fast_labels.push_back(&&RomLine1847);
        main_exec_generated_fast_labels.push_back(&&RomLine1848);
        main_exec_generated_fast_labels.push_back(&&RomLine1849);
        main_exec_generated_fast_labels.push_back(&&RomLine1850);
        main_exec_generated_fast_labels.push_back(&&RomLine1851);
        main_exec_generated_fast_labels.push_back(&&RomLine1852);
        main_exec_generated_fast_labels.push_back(&&RomLine1853);
        main_exec_generated_fast_labels.push_back(&&RomLine1854);
        main_exec_generated_fast_labels.push_back(&&RomLine1855);
        main_exec_generated_fast_labels.push_back(&&RomLine1856);
        main_exec_generated_fast_labels.push_back(&&RomLine1857);
        main_exec_generated_fast_labels.push_back(&&RomLine1858);
        main_exec_generated_fast_labels.push_back(&&RomLine1859);
        main_exec_generated_fast_labels.push_back(&&RomLine1860);
        main_exec_generated_fast_labels.push_back(&&RomLine1861);
        main_exec_generated_fast_labels.push_back(&&RomLine1862);
        main_exec_generated_fast_labels.push_back(&&RomLine1863);
        main_exec_generated_fast_labels.push_back(&&RomLine1864);
        main_exec_generated_fast_labels.push_back(&&RomLine1865);
        main_exec_generated_fast_labels.push_back(&&RomLine1866);
        main_exec_generated_fast_labels.push_back(&&RomLine1867);
        main_exec_generated_fast_labels.push_back(&&RomLine1868);
        main_exec_generated_fast_labels.push_back(&&RomLine1869);
        main_exec_generated_fast_labels.push_back(&&RomLine1870);
        main_exec_generated_fast_labels.push_back(&&RomLine1871);
        main_exec_generated_fast_labels.push_back(&&RomLine1872);
        main_exec_generated_fast_labels.push_back(&&RomLine1873);
        main_exec_generated_fast_labels.push_back(&&RomLine1874);
        main_exec_generated_fast_labels.push_back(&&RomLine1875);
        main_exec_generated_fast_labels.push_back(&&RomLine1876);
        main_exec_generated_fast_labels.push_back(&&RomLine1877);
        main_exec_generated_fast_labels.push_back(&&RomLine1878);
        main_exec_generated_fast_labels.push_back(&&RomLine1879);
        main_exec_generated_fast_labels.push_back(&&RomLine1880);
        main_exec_generated_fast_labels.push_back(&&RomLine1881);
        main_exec_generated_fast_labels.push_back(&&RomLine1882);
        main_exec_generated_fast_labels.push_back(&&RomLine1883);
        main_exec_generated_fast_labels.push_back(&&RomLine1884);
        main_exec_generated_fast_labels.push_back(&&RomLine1885);
        main_exec_generated_fast_labels.push_back(&&RomLine1886);
        main_exec_generated_fast_labels.push_back(&&RomLine1887);
        main_exec_generated_fast_labels.push_back(&&RomLine1888);
        main_exec_generated_fast_labels.push_back(&&RomLine1889);
        main_exec_generated_fast_labels.push_back(&&RomLine1890);
        main_exec_generated_fast_labels.push_back(&&RomLine1891);
        main_exec_generated_fast_labels.push_back(&&RomLine1892);
        main_exec_generated_fast_labels.push_back(&&RomLine1893);
        main_exec_generated_fast_labels.push_back(&&RomLine1894);
        main_exec_generated_fast_labels.push_back(&&RomLine1895);
        main_exec_generated_fast_labels.push_back(&&RomLine1896);
        main_exec_generated_fast_labels.push_back(&&RomLine1897);
        main_exec_generated_fast_labels.push_back(&&RomLine1898);
        main_exec_generated_fast_labels.push_back(&&RomLine1899);
        main_exec_generated_fast_labels.push_back(&&RomLine1900);
        main_exec_generated_fast_labels.push_back(&&RomLine1901);
        main_exec_generated_fast_labels.push_back(&&RomLine1902);
        main_exec_generated_fast_labels.push_back(&&RomLine1903);
        main_exec_generated_fast_labels.push_back(&&RomLine1904);
        main_exec_generated_fast_labels.push_back(&&RomLine1905);
        main_exec_generated_fast_labels.push_back(&&RomLine1906);
        main_exec_generated_fast_labels.push_back(&&RomLine1907);
        main_exec_generated_fast_labels.push_back(&&RomLine1908);
        main_exec_generated_fast_labels.push_back(&&RomLine1909);
        main_exec_generated_fast_labels.push_back(&&RomLine1910);
        main_exec_generated_fast_labels.push_back(&&RomLine1911);
        main_exec_generated_fast_labels.push_back(&&RomLine1912);
        main_exec_generated_fast_labels.push_back(&&RomLine1913);
        main_exec_generated_fast_labels.push_back(&&RomLine1914);
        main_exec_generated_fast_labels.push_back(&&RomLine1915);
        main_exec_generated_fast_labels.push_back(&&RomLine1916);
        main_exec_generated_fast_labels.push_back(&&RomLine1917);
        main_exec_generated_fast_labels.push_back(&&RomLine1918);
        main_exec_generated_fast_labels.push_back(&&RomLine1919);
        main_exec_generated_fast_labels.push_back(&&RomLine1920);
        main_exec_generated_fast_labels.push_back(&&RomLine1921);
        main_exec_generated_fast_labels.push_back(&&RomLine1922);
        main_exec_generated_fast_labels.push_back(&&RomLine1923);
        main_exec_generated_fast_labels.push_back(&&RomLine1924);
        main_exec_generated_fast_labels.push_back(&&RomLine1925);
        main_exec_generated_fast_labels.push_back(&&RomLine1926);
        main_exec_generated_fast_labels.push_back(&&RomLine1927);
        main_exec_generated_fast_labels.push_back(&&RomLine1928);
        main_exec_generated_fast_labels.push_back(&&RomLine1929);
        main_exec_generated_fast_labels.push_back(&&RomLine1930);
        main_exec_generated_fast_labels.push_back(&&RomLine1931);
        main_exec_generated_fast_labels.push_back(&&RomLine1932);
        main_exec_generated_fast_labels.push_back(&&RomLine1933);
        main_exec_generated_fast_labels.push_back(&&RomLine1934);
        main_exec_generated_fast_labels.push_back(&&RomLine1935);
        main_exec_generated_fast_labels.push_back(&&RomLine1936);
        main_exec_generated_fast_labels.push_back(&&RomLine1937);
        main_exec_generated_fast_labels.push_back(&&RomLine1938);
        main_exec_generated_fast_labels.push_back(&&RomLine1939);
        main_exec_generated_fast_labels.push_back(&&RomLine1940);
        main_exec_generated_fast_labels.push_back(&&RomLine1941);
        main_exec_generated_fast_labels.push_back(&&RomLine1942);
        main_exec_generated_fast_labels.push_back(&&RomLine1943);
        main_exec_generated_fast_labels.push_back(&&RomLine1944);
        main_exec_generated_fast_labels.push_back(&&RomLine1945);
        main_exec_generated_fast_labels.push_back(&&RomLine1946);
        main_exec_generated_fast_labels.push_back(&&RomLine1947);
        main_exec_generated_fast_labels.push_back(&&RomLine1948);
        main_exec_generated_fast_labels.push_back(&&RomLine1949);
        main_exec_generated_fast_labels.push_back(&&RomLine1950);
        main_exec_generated_fast_labels.push_back(&&RomLine1951);
        main_exec_generated_fast_labels.push_back(&&RomLine1952);
        main_exec_generated_fast_labels.push_back(&&RomLine1953);
        main_exec_generated_fast_labels.push_back(&&RomLine1954);
        main_exec_generated_fast_labels.push_back(&&RomLine1955);
        main_exec_generated_fast_labels.push_back(&&RomLine1956);
        main_exec_generated_fast_labels.push_back(&&RomLine1957);
        main_exec_generated_fast_labels.push_back(&&RomLine1958);
        main_exec_generated_fast_labels.push_back(&&RomLine1959);
        main_exec_generated_fast_labels.push_back(&&RomLine1960);
        main_exec_generated_fast_labels.push_back(&&RomLine1961);
        main_exec_generated_fast_labels.push_back(&&RomLine1962);
        main_exec_generated_fast_labels.push_back(&&RomLine1963);
        main_exec_generated_fast_labels.push_back(&&RomLine1964);
        main_exec_generated_fast_labels.push_back(&&RomLine1965);
        main_exec_generated_fast_labels.push_back(&&RomLine1966);
        main_exec_generated_fast_labels.push_back(&&RomLine1967);
        main_exec_generated_fast_labels.push_back(&&RomLine1968);
        main_exec_generated_fast_labels.push_back(&&RomLine1969);
        main_exec_generated_fast_labels.push_back(&&RomLine1970);
        main_exec_generated_fast_labels.push_back(&&RomLine1971);
        main_exec_generated_fast_labels.push_back(&&RomLine1972);
        main_exec_generated_fast_labels.push_back(&&RomLine1973);
        main_exec_generated_fast_labels.push_back(&&RomLine1974);
        main_exec_generated_fast_labels.push_back(&&RomLine1975);
        main_exec_generated_fast_labels.push_back(&&RomLine1976);
        main_exec_generated_fast_labels.push_back(&&RomLine1977);
        main_exec_generated_fast_labels.push_back(&&RomLine1978);
        main_exec_generated_fast_labels.push_back(&&RomLine1979);
        main_exec_generated_fast_labels.push_back(&&RomLine1980);
        main_exec_generated_fast_labels.push_back(&&RomLine1981);
        main_exec_generated_fast_labels.push_back(&&RomLine1982);
        main_exec_generated_fast_labels.push_back(&&RomLine1983);
        main_exec_generated_fast_labels.push_back(&&RomLine1984);
        main_exec_generated_fast_labels.push_back(&&RomLine1985);
        main_exec_generated_fast_labels.push_back(&&RomLine1986);
        main_exec_generated_fast_labels.push_back(&&RomLine1987);
        main_exec_generated_fast_labels.push_back(&&RomLine1988);
        main_exec_generated_fast_labels.push_back(&&RomLine1989);
        main_exec_generated_fast_labels.push_back(&&RomLine1990);
        main_exec_generated_fast_labels.push_back(&&RomLine1991);
        main_exec_generated_fast_labels.push_back(&&RomLine1992);
        main_exec_generated_fast_labels.push_back(&&RomLine1993);
        main_exec_generated_fast_labels.push_back(&&RomLine1994);
        main_exec_generated_fast_labels.push_back(&&RomLine1995);
        main_exec_generated_fast_labels.push_back(&&RomLine1996);
        main_exec_generated_fast_labels.push_back(&&RomLine1997);
        main_exec_generated_fast_labels.push_back(&&RomLine1998);
        main_exec_generated_fast_labels.push_back(&&RomLine1999);
        main_exec_generated_fast_labels.push_back(&&RomLine2000);
        main_exec_generated_fast_labels.push_back(&&RomLine2001);
        main_exec_generated_fast_labels.push_back(&&RomLine2002);
        main_exec_generated_fast_labels.push_back(&&RomLine2003);
        main_exec_generated_fast_labels.push_back(&&RomLine2004);
        main_exec_generated_fast_labels.push_back(&&RomLine2005);
        main_exec_generated_fast_labels.push_back(&&RomLine2006);
        main_exec_generated_fast_labels.push_back(&&RomLine2007);
        main_exec_generated_fast_labels.push_back(&&RomLine2008);
        main_exec_generated_fast_labels.push_back(&&RomLine2009);
        main_exec_generated_fast_labels.push_back(&&RomLine2010);
        main_exec_generated_fast_labels.push_back(&&RomLine2011);
        main_exec_generated_fast_labels.push_back(&&RomLine2012);
        main_exec_generated_fast_labels.push_back(&&RomLine2013);
        main_exec_generated_fast_labels.push_back(&&RomLine2014);
        main_exec_generated_fast_labels.push_back(&&RomLine2015);
        main_exec_generated_fast_labels.push_back(&&RomLine2016);
        main_exec_generated_fast_labels.push_back(&&RomLine2017);
        main_exec_generated_fast_labels.push_back(&&RomLine2018);
        main_exec_generated_fast_labels.push_back(&&RomLine2019);
        main_exec_generated_fast_labels.push_back(&&RomLine2020);
        main_exec_generated_fast_labels.push_back(&&RomLine2021);
        main_exec_generated_fast_labels.push_back(&&RomLine2022);
        main_exec_generated_fast_labels.push_back(&&RomLine2023);
        main_exec_generated_fast_labels.push_back(&&RomLine2024);
        main_exec_generated_fast_labels.push_back(&&RomLine2025);
        main_exec_generated_fast_labels.push_back(&&RomLine2026);
        main_exec_generated_fast_labels.push_back(&&RomLine2027);
        main_exec_generated_fast_labels.push_back(&&RomLine2028);
        main_exec_generated_fast_labels.push_back(&&RomLine2029);
        main_exec_generated_fast_labels.push_back(&&RomLine2030);
        main_exec_generated_fast_labels.push_back(&&RomLine2031);
        main_exec_generated_fast_labels.push_back(&&RomLine2032);
        main_exec_generated_fast_labels.push_back(&&RomLine2033);
        main_exec_generated_fast_labels.push_back(&&RomLine2034);
        main_exec_generated_fast_labels.push_back(&&RomLine2035);
        main_exec_generated_fast_labels.push_back(&&RomLine2036);
        main_exec_generated_fast_labels.push_back(&&RomLine2037);
        main_exec_generated_fast_labels.push_back(&&RomLine2038);
        main_exec_generated_fast_labels.push_back(&&RomLine2039);
        main_exec_generated_fast_labels.push_back(&&RomLine2040);
        main_exec_generated_fast_labels.push_back(&&RomLine2041);
        main_exec_generated_fast_labels.push_back(&&RomLine2042);
        main_exec_generated_fast_labels.push_back(&&RomLine2043);
        main_exec_generated_fast_labels.push_back(&&RomLine2044);
        main_exec_generated_fast_labels.push_back(&&RomLine2045);
        main_exec_generated_fast_labels.push_back(&&RomLine2046);
        main_exec_generated_fast_labels.push_back(&&RomLine2047);
        main_exec_generated_fast_labels.push_back(&&RomLine2048);
        main_exec_generated_fast_labels.push_back(&&RomLine2049);
        main_exec_generated_fast_labels.push_back(&&RomLine2050);
        main_exec_generated_fast_labels.push_back(&&RomLine2051);
        main_exec_generated_fast_labels.push_back(&&RomLine2052);
        main_exec_generated_fast_labels.push_back(&&RomLine2053);
        main_exec_generated_fast_labels.push_back(&&RomLine2054);
        main_exec_generated_fast_labels.push_back(&&RomLine2055);
        main_exec_generated_fast_labels.push_back(&&RomLine2056);
        main_exec_generated_fast_labels.push_back(&&RomLine2057);
        main_exec_generated_fast_labels.push_back(&&RomLine2058);
        main_exec_generated_fast_labels.push_back(&&RomLine2059);
        main_exec_generated_fast_labels.push_back(&&RomLine2060);
        main_exec_generated_fast_labels.push_back(&&RomLine2061);
        main_exec_generated_fast_labels.push_back(&&RomLine2062);
        main_exec_generated_fast_labels.push_back(&&RomLine2063);
        main_exec_generated_fast_labels.push_back(&&RomLine2064);
        main_exec_generated_fast_labels.push_back(&&RomLine2065);
        main_exec_generated_fast_labels.push_back(&&RomLine2066);
        main_exec_generated_fast_labels.push_back(&&RomLine2067);
        main_exec_generated_fast_labels.push_back(&&RomLine2068);
        main_exec_generated_fast_labels.push_back(&&RomLine2069);
        main_exec_generated_fast_labels.push_back(&&RomLine2070);
        main_exec_generated_fast_labels.push_back(&&RomLine2071);
        main_exec_generated_fast_labels.push_back(&&RomLine2072);
        main_exec_generated_fast_labels.push_back(&&RomLine2073);
        main_exec_generated_fast_labels.push_back(&&RomLine2074);
        main_exec_generated_fast_labels.push_back(&&RomLine2075);
        main_exec_generated_fast_labels.push_back(&&RomLine2076);
        main_exec_generated_fast_labels.push_back(&&RomLine2077);
        main_exec_generated_fast_labels.push_back(&&RomLine2078);
        main_exec_generated_fast_labels.push_back(&&RomLine2079);
        main_exec_generated_fast_labels.push_back(&&RomLine2080);
        main_exec_generated_fast_labels.push_back(&&RomLine2081);
        main_exec_generated_fast_labels.push_back(&&RomLine2082);
        main_exec_generated_fast_labels.push_back(&&RomLine2083);
        main_exec_generated_fast_labels.push_back(&&RomLine2084);
        main_exec_generated_fast_labels.push_back(&&RomLine2085);
        main_exec_generated_fast_labels.push_back(&&RomLine2086);
        main_exec_generated_fast_labels.push_back(&&RomLine2087);
        main_exec_generated_fast_labels.push_back(&&RomLine2088);
        main_exec_generated_fast_labels.push_back(&&RomLine2089);
        main_exec_generated_fast_labels.push_back(&&RomLine2090);
        main_exec_generated_fast_labels.push_back(&&RomLine2091);
        main_exec_generated_fast_labels.push_back(&&RomLine2092);
        main_exec_generated_fast_labels.push_back(&&RomLine2093);
        main_exec_generated_fast_labels.push_back(&&RomLine2094);
        main_exec_generated_fast_labels.push_back(&&RomLine2095);
        main_exec_generated_fast_labels.push_back(&&RomLine2096);
        main_exec_generated_fast_labels.push_back(&&RomLine2097);
        main_exec_generated_fast_labels.push_back(&&RomLine2098);
        main_exec_generated_fast_labels.push_back(&&RomLine2099);
        main_exec_generated_fast_labels.push_back(&&RomLine2100);
        main_exec_generated_fast_labels.push_back(&&RomLine2101);
        main_exec_generated_fast_labels.push_back(&&RomLine2102);
        main_exec_generated_fast_labels.push_back(&&RomLine2103);
        main_exec_generated_fast_labels.push_back(&&RomLine2104);
        main_exec_generated_fast_labels.push_back(&&RomLine2105);
        main_exec_generated_fast_labels.push_back(&&RomLine2106);
        main_exec_generated_fast_labels.push_back(&&RomLine2107);
        main_exec_generated_fast_labels.push_back(&&RomLine2108);
        main_exec_generated_fast_labels.push_back(&&RomLine2109);
        main_exec_generated_fast_labels.push_back(&&RomLine2110);
        main_exec_generated_fast_labels.push_back(&&RomLine2111);
        main_exec_generated_fast_labels.push_back(&&RomLine2112);
        main_exec_generated_fast_labels.push_back(&&RomLine2113);
        main_exec_generated_fast_labels.push_back(&&RomLine2114);
        main_exec_generated_fast_labels.push_back(&&RomLine2115);
        main_exec_generated_fast_labels.push_back(&&RomLine2116);
        main_exec_generated_fast_labels.push_back(&&RomLine2117);
        main_exec_generated_fast_labels.push_back(&&RomLine2118);
        main_exec_generated_fast_labels.push_back(&&RomLine2119);
        main_exec_generated_fast_labels.push_back(&&RomLine2120);
        main_exec_generated_fast_labels.push_back(&&RomLine2121);
        main_exec_generated_fast_labels.push_back(&&RomLine2122);
        main_exec_generated_fast_labels.push_back(&&RomLine2123);
        main_exec_generated_fast_labels.push_back(&&RomLine2124);
        main_exec_generated_fast_labels.push_back(&&RomLine2125);
        main_exec_generated_fast_labels.push_back(&&RomLine2126);
        main_exec_generated_fast_labels.push_back(&&RomLine2127);
        main_exec_generated_fast_labels.push_back(&&RomLine2128);
        main_exec_generated_fast_labels.push_back(&&RomLine2129);
        main_exec_generated_fast_labels.push_back(&&RomLine2130);
        main_exec_generated_fast_labels.push_back(&&RomLine2131);
        main_exec_generated_fast_labels.push_back(&&RomLine2132);
        main_exec_generated_fast_labels.push_back(&&RomLine2133);
        main_exec_generated_fast_labels.push_back(&&RomLine2134);
        main_exec_generated_fast_labels.push_back(&&RomLine2135);
        main_exec_generated_fast_labels.push_back(&&RomLine2136);
        main_exec_generated_fast_labels.push_back(&&RomLine2137);
        main_exec_generated_fast_labels.push_back(&&RomLine2138);
        main_exec_generated_fast_labels.push_back(&&RomLine2139);
        main_exec_generated_fast_labels.push_back(&&RomLine2140);
        main_exec_generated_fast_labels.push_back(&&RomLine2141);
        main_exec_generated_fast_labels.push_back(&&RomLine2142);
        main_exec_generated_fast_labels.push_back(&&RomLine2143);
        main_exec_generated_fast_labels.push_back(&&RomLine2144);
        main_exec_generated_fast_labels.push_back(&&RomLine2145);
        main_exec_generated_fast_labels.push_back(&&RomLine2146);
        main_exec_generated_fast_labels.push_back(&&RomLine2147);
        main_exec_generated_fast_labels.push_back(&&RomLine2148);
        main_exec_generated_fast_labels.push_back(&&RomLine2149);
        main_exec_generated_fast_labels.push_back(&&RomLine2150);
        main_exec_generated_fast_labels.push_back(&&RomLine2151);
        main_exec_generated_fast_labels.push_back(&&RomLine2152);
        main_exec_generated_fast_labels.push_back(&&RomLine2153);
        main_exec_generated_fast_labels.push_back(&&RomLine2154);
        main_exec_generated_fast_labels.push_back(&&RomLine2155);
        main_exec_generated_fast_labels.push_back(&&RomLine2156);
        main_exec_generated_fast_labels.push_back(&&RomLine2157);
        main_exec_generated_fast_labels.push_back(&&RomLine2158);
        main_exec_generated_fast_labels.push_back(&&RomLine2159);
        main_exec_generated_fast_labels.push_back(&&RomLine2160);
        main_exec_generated_fast_labels.push_back(&&RomLine2161);
        main_exec_generated_fast_labels.push_back(&&RomLine2162);
        main_exec_generated_fast_labels.push_back(&&RomLine2163);
        main_exec_generated_fast_labels.push_back(&&RomLine2164);
        main_exec_generated_fast_labels.push_back(&&RomLine2165);
        main_exec_generated_fast_labels.push_back(&&RomLine2166);
        main_exec_generated_fast_labels.push_back(&&RomLine2167);
        main_exec_generated_fast_labels.push_back(&&RomLine2168);
        main_exec_generated_fast_labels.push_back(&&RomLine2169);
        main_exec_generated_fast_labels.push_back(&&RomLine2170);
        main_exec_generated_fast_labels.push_back(&&RomLine2171);
        main_exec_generated_fast_labels.push_back(&&RomLine2172);
        main_exec_generated_fast_labels.push_back(&&RomLine2173);
        main_exec_generated_fast_labels.push_back(&&RomLine2174);
        main_exec_generated_fast_labels.push_back(&&RomLine2175);
        main_exec_generated_fast_labels.push_back(&&RomLine2176);
        main_exec_generated_fast_labels.push_back(&&RomLine2177);
        main_exec_generated_fast_labels.push_back(&&RomLine2178);
        main_exec_generated_fast_labels.push_back(&&RomLine2179);
        main_exec_generated_fast_labels.push_back(&&RomLine2180);
        main_exec_generated_fast_labels.push_back(&&RomLine2181);
        main_exec_generated_fast_labels.push_back(&&RomLine2182);
        main_exec_generated_fast_labels.push_back(&&RomLine2183);
        main_exec_generated_fast_labels.push_back(&&RomLine2184);
        main_exec_generated_fast_labels.push_back(&&RomLine2185);
        main_exec_generated_fast_labels.push_back(&&RomLine2186);
        main_exec_generated_fast_labels.push_back(&&RomLine2187);
        main_exec_generated_fast_labels.push_back(&&RomLine2188);
        main_exec_generated_fast_labels.push_back(&&RomLine2189);
        main_exec_generated_fast_labels.push_back(&&RomLine2190);
        main_exec_generated_fast_labels.push_back(&&RomLine2191);
        main_exec_generated_fast_labels.push_back(&&RomLine2192);
        main_exec_generated_fast_labels.push_back(&&RomLine2193);
        main_exec_generated_fast_labels.push_back(&&RomLine2194);
        main_exec_generated_fast_labels.push_back(&&RomLine2195);
        main_exec_generated_fast_labels.push_back(&&RomLine2196);
        main_exec_generated_fast_labels.push_back(&&RomLine2197);
        main_exec_generated_fast_labels.push_back(&&RomLine2198);
        main_exec_generated_fast_labels.push_back(&&RomLine2199);
        main_exec_generated_fast_labels.push_back(&&RomLine2200);
        main_exec_generated_fast_labels.push_back(&&RomLine2201);
        main_exec_generated_fast_labels.push_back(&&RomLine2202);
        main_exec_generated_fast_labels.push_back(&&RomLine2203);
        main_exec_generated_fast_labels.push_back(&&RomLine2204);
        main_exec_generated_fast_labels.push_back(&&RomLine2205);
        main_exec_generated_fast_labels.push_back(&&RomLine2206);
        main_exec_generated_fast_labels.push_back(&&RomLine2207);
        main_exec_generated_fast_labels.push_back(&&RomLine2208);
        main_exec_generated_fast_labels.push_back(&&RomLine2209);
        main_exec_generated_fast_labels.push_back(&&RomLine2210);
        main_exec_generated_fast_labels.push_back(&&RomLine2211);
        main_exec_generated_fast_labels.push_back(&&RomLine2212);
        main_exec_generated_fast_labels.push_back(&&RomLine2213);
        main_exec_generated_fast_labels.push_back(&&RomLine2214);
        main_exec_generated_fast_labels.push_back(&&RomLine2215);
        main_exec_generated_fast_labels.push_back(&&RomLine2216);
        main_exec_generated_fast_labels.push_back(&&RomLine2217);
        main_exec_generated_fast_labels.push_back(&&RomLine2218);
        main_exec_generated_fast_labels.push_back(&&RomLine2219);
        main_exec_generated_fast_labels.push_back(&&RomLine2220);
        main_exec_generated_fast_labels.push_back(&&RomLine2221);
        main_exec_generated_fast_labels.push_back(&&RomLine2222);
        main_exec_generated_fast_labels.push_back(&&RomLine2223);
        main_exec_generated_fast_labels.push_back(&&RomLine2224);
        main_exec_generated_fast_labels.push_back(&&RomLine2225);
        main_exec_generated_fast_labels.push_back(&&RomLine2226);
        main_exec_generated_fast_labels.push_back(&&RomLine2227);
        main_exec_generated_fast_labels.push_back(&&RomLine2228);
        main_exec_generated_fast_labels.push_back(&&RomLine2229);
        main_exec_generated_fast_labels.push_back(&&RomLine2230);
        main_exec_generated_fast_labels.push_back(&&RomLine2231);
        main_exec_generated_fast_labels.push_back(&&RomLine2232);
        main_exec_generated_fast_labels.push_back(&&RomLine2233);
        main_exec_generated_fast_labels.push_back(&&RomLine2234);
        main_exec_generated_fast_labels.push_back(&&RomLine2235);
        main_exec_generated_fast_labels.push_back(&&RomLine2236);
        main_exec_generated_fast_labels.push_back(&&RomLine2237);
        main_exec_generated_fast_labels.push_back(&&RomLine2238);
        main_exec_generated_fast_labels.push_back(&&RomLine2239);
        main_exec_generated_fast_labels.push_back(&&RomLine2240);
        main_exec_generated_fast_labels.push_back(&&RomLine2241);
        main_exec_generated_fast_labels.push_back(&&RomLine2242);
        main_exec_generated_fast_labels.push_back(&&RomLine2243);
        main_exec_generated_fast_labels.push_back(&&RomLine2244);
        main_exec_generated_fast_labels.push_back(&&RomLine2245);
        main_exec_generated_fast_labels.push_back(&&RomLine2246);
        main_exec_generated_fast_labels.push_back(&&RomLine2247);
        main_exec_generated_fast_labels.push_back(&&RomLine2248);
        main_exec_generated_fast_labels.push_back(&&RomLine2249);
        main_exec_generated_fast_labels.push_back(&&RomLine2250);
        main_exec_generated_fast_labels.push_back(&&RomLine2251);
        main_exec_generated_fast_labels.push_back(&&RomLine2252);
        main_exec_generated_fast_labels.push_back(&&RomLine2253);
        main_exec_generated_fast_labels.push_back(&&RomLine2254);
        main_exec_generated_fast_labels.push_back(&&RomLine2255);
        main_exec_generated_fast_labels.push_back(&&RomLine2256);
        main_exec_generated_fast_labels.push_back(&&RomLine2257);
        main_exec_generated_fast_labels.push_back(&&RomLine2258);
        main_exec_generated_fast_labels.push_back(&&RomLine2259);
        main_exec_generated_fast_labels.push_back(&&RomLine2260);
        main_exec_generated_fast_labels.push_back(&&RomLine2261);
        main_exec_generated_fast_labels.push_back(&&RomLine2262);
        main_exec_generated_fast_labels.push_back(&&RomLine2263);
        main_exec_generated_fast_labels.push_back(&&RomLine2264);
        main_exec_generated_fast_labels.push_back(&&RomLine2265);
        main_exec_generated_fast_labels.push_back(&&RomLine2266);
        main_exec_generated_fast_labels.push_back(&&RomLine2267);
        main_exec_generated_fast_labels.push_back(&&RomLine2268);
        main_exec_generated_fast_labels.push_back(&&RomLine2269);
        main_exec_generated_fast_labels.push_back(&&RomLine2270);
        main_exec_generated_fast_labels.push_back(&&RomLine2271);
        main_exec_generated_fast_labels.push_back(&&RomLine2272);
        main_exec_generated_fast_labels.push_back(&&RomLine2273);
        main_exec_generated_fast_labels.push_back(&&RomLine2274);
        main_exec_generated_fast_labels.push_back(&&RomLine2275);
        main_exec_generated_fast_labels.push_back(&&RomLine2276);
        main_exec_generated_fast_labels.push_back(&&RomLine2277);
        main_exec_generated_fast_labels.push_back(&&RomLine2278);
        main_exec_generated_fast_labels.push_back(&&RomLine2279);
        main_exec_generated_fast_labels.push_back(&&RomLine2280);
        main_exec_generated_fast_labels.push_back(&&RomLine2281);
        main_exec_generated_fast_labels.push_back(&&RomLine2282);
        main_exec_generated_fast_labels.push_back(&&RomLine2283);
        main_exec_generated_fast_labels.push_back(&&RomLine2284);
        main_exec_generated_fast_labels.push_back(&&RomLine2285);
        main_exec_generated_fast_labels.push_back(&&RomLine2286);
        main_exec_generated_fast_labels.push_back(&&RomLine2287);
        main_exec_generated_fast_labels.push_back(&&RomLine2288);
        main_exec_generated_fast_labels.push_back(&&RomLine2289);
        main_exec_generated_fast_labels.push_back(&&RomLine2290);
        main_exec_generated_fast_labels.push_back(&&RomLine2291);
        main_exec_generated_fast_labels.push_back(&&RomLine2292);
        main_exec_generated_fast_labels.push_back(&&RomLine2293);
        main_exec_generated_fast_labels.push_back(&&RomLine2294);
        main_exec_generated_fast_labels.push_back(&&RomLine2295);
        main_exec_generated_fast_labels.push_back(&&RomLine2296);
        main_exec_generated_fast_labels.push_back(&&RomLine2297);
        main_exec_generated_fast_labels.push_back(&&RomLine2298);
        main_exec_generated_fast_labels.push_back(&&RomLine2299);
        main_exec_generated_fast_labels.push_back(&&RomLine2300);
        main_exec_generated_fast_labels.push_back(&&RomLine2301);
        main_exec_generated_fast_labels.push_back(&&RomLine2302);
        main_exec_generated_fast_labels.push_back(&&RomLine2303);
        main_exec_generated_fast_labels.push_back(&&RomLine2304);
        main_exec_generated_fast_labels.push_back(&&RomLine2305);
        main_exec_generated_fast_labels.push_back(&&RomLine2306);
        main_exec_generated_fast_labels.push_back(&&RomLine2307);
        main_exec_generated_fast_labels.push_back(&&RomLine2308);
        main_exec_generated_fast_labels.push_back(&&RomLine2309);
        main_exec_generated_fast_labels.push_back(&&RomLine2310);
        main_exec_generated_fast_labels.push_back(&&RomLine2311);
        main_exec_generated_fast_labels.push_back(&&RomLine2312);
        main_exec_generated_fast_labels.push_back(&&RomLine2313);
        main_exec_generated_fast_labels.push_back(&&RomLine2314);
        main_exec_generated_fast_labels.push_back(&&RomLine2315);
        main_exec_generated_fast_labels.push_back(&&RomLine2316);
        main_exec_generated_fast_labels.push_back(&&RomLine2317);
        main_exec_generated_fast_labels.push_back(&&RomLine2318);
        main_exec_generated_fast_labels.push_back(&&RomLine2319);
        main_exec_generated_fast_labels.push_back(&&RomLine2320);
        main_exec_generated_fast_labels.push_back(&&RomLine2321);
        main_exec_generated_fast_labels.push_back(&&RomLine2322);
        main_exec_generated_fast_labels.push_back(&&RomLine2323);
        main_exec_generated_fast_labels.push_back(&&RomLine2324);
        main_exec_generated_fast_labels.push_back(&&RomLine2325);
        main_exec_generated_fast_labels.push_back(&&RomLine2326);
        main_exec_generated_fast_labels.push_back(&&RomLine2327);
        main_exec_generated_fast_labels.push_back(&&RomLine2328);
        main_exec_generated_fast_labels.push_back(&&RomLine2329);
        main_exec_generated_fast_labels.push_back(&&RomLine2330);
        main_exec_generated_fast_labels.push_back(&&RomLine2331);
        main_exec_generated_fast_labels.push_back(&&RomLine2332);
        main_exec_generated_fast_labels.push_back(&&RomLine2333);
        main_exec_generated_fast_labels.push_back(&&RomLine2334);
        main_exec_generated_fast_labels.push_back(&&RomLine2335);
        main_exec_generated_fast_labels.push_back(&&RomLine2336);
        main_exec_generated_fast_labels.push_back(&&RomLine2337);
        main_exec_generated_fast_labels.push_back(&&RomLine2338);
        main_exec_generated_fast_labels.push_back(&&RomLine2339);
        main_exec_generated_fast_labels.push_back(&&RomLine2340);
        main_exec_generated_fast_labels.push_back(&&RomLine2341);
        main_exec_generated_fast_labels.push_back(&&RomLine2342);
        main_exec_generated_fast_labels.push_back(&&RomLine2343);
        main_exec_generated_fast_labels.push_back(&&RomLine2344);
        main_exec_generated_fast_labels.push_back(&&RomLine2345);
        main_exec_generated_fast_labels.push_back(&&RomLine2346);
        main_exec_generated_fast_labels.push_back(&&RomLine2347);
        main_exec_generated_fast_labels.push_back(&&RomLine2348);
        main_exec_generated_fast_labels.push_back(&&RomLine2349);
        main_exec_generated_fast_labels.push_back(&&RomLine2350);
        main_exec_generated_fast_labels.push_back(&&RomLine2351);
        main_exec_generated_fast_labels.push_back(&&RomLine2352);
        main_exec_generated_fast_labels.push_back(&&RomLine2353);
        main_exec_generated_fast_labels.push_back(&&RomLine2354);
        main_exec_generated_fast_labels.push_back(&&RomLine2355);
        main_exec_generated_fast_labels.push_back(&&RomLine2356);
        main_exec_generated_fast_labels.push_back(&&RomLine2357);
        main_exec_generated_fast_labels.push_back(&&RomLine2358);
        main_exec_generated_fast_labels.push_back(&&RomLine2359);
        main_exec_generated_fast_labels.push_back(&&RomLine2360);
        main_exec_generated_fast_labels.push_back(&&RomLine2361);
        main_exec_generated_fast_labels.push_back(&&RomLine2362);
        main_exec_generated_fast_labels.push_back(&&RomLine2363);
        main_exec_generated_fast_labels.push_back(&&RomLine2364);
        main_exec_generated_fast_labels.push_back(&&RomLine2365);
        main_exec_generated_fast_labels.push_back(&&RomLine2366);
        main_exec_generated_fast_labels.push_back(&&RomLine2367);
        main_exec_generated_fast_labels.push_back(&&RomLine2368);
        main_exec_generated_fast_labels.push_back(&&RomLine2369);
        main_exec_generated_fast_labels.push_back(&&RomLine2370);
        main_exec_generated_fast_labels.push_back(&&RomLine2371);
        main_exec_generated_fast_labels.push_back(&&RomLine2372);
        main_exec_generated_fast_labels.push_back(&&RomLine2373);
        main_exec_generated_fast_labels.push_back(&&RomLine2374);
        main_exec_generated_fast_labels.push_back(&&RomLine2375);
        main_exec_generated_fast_labels.push_back(&&RomLine2376);
        main_exec_generated_fast_labels.push_back(&&RomLine2377);
        main_exec_generated_fast_labels.push_back(&&RomLine2378);
        main_exec_generated_fast_labels.push_back(&&RomLine2379);
        main_exec_generated_fast_labels.push_back(&&RomLine2380);
        main_exec_generated_fast_labels.push_back(&&RomLine2381);
        main_exec_generated_fast_labels.push_back(&&RomLine2382);
        main_exec_generated_fast_labels.push_back(&&RomLine2383);
        main_exec_generated_fast_labels.push_back(&&RomLine2384);
        main_exec_generated_fast_labels.push_back(&&RomLine2385);
        main_exec_generated_fast_labels.push_back(&&RomLine2386);
        main_exec_generated_fast_labels.push_back(&&RomLine2387);
        main_exec_generated_fast_labels.push_back(&&RomLine2388);
        main_exec_generated_fast_labels.push_back(&&RomLine2389);
        main_exec_generated_fast_labels.push_back(&&RomLine2390);
        main_exec_generated_fast_labels.push_back(&&RomLine2391);
        main_exec_generated_fast_labels.push_back(&&RomLine2392);
        main_exec_generated_fast_labels.push_back(&&RomLine2393);
        main_exec_generated_fast_labels.push_back(&&RomLine2394);
        main_exec_generated_fast_labels.push_back(&&RomLine2395);
        main_exec_generated_fast_labels.push_back(&&RomLine2396);
        main_exec_generated_fast_labels.push_back(&&RomLine2397);
        main_exec_generated_fast_labels.push_back(&&RomLine2398);
        main_exec_generated_fast_labels.push_back(&&RomLine2399);
        main_exec_generated_fast_labels.push_back(&&RomLine2400);
        main_exec_generated_fast_labels.push_back(&&RomLine2401);
        main_exec_generated_fast_labels.push_back(&&RomLine2402);
        main_exec_generated_fast_labels.push_back(&&RomLine2403);
        main_exec_generated_fast_labels.push_back(&&RomLine2404);
        main_exec_generated_fast_labels.push_back(&&RomLine2405);
        main_exec_generated_fast_labels.push_back(&&RomLine2406);
        main_exec_generated_fast_labels.push_back(&&RomLine2407);
        main_exec_generated_fast_labels.push_back(&&RomLine2408);
        main_exec_generated_fast_labels.push_back(&&RomLine2409);
        main_exec_generated_fast_labels.push_back(&&RomLine2410);
        main_exec_generated_fast_labels.push_back(&&RomLine2411);
        main_exec_generated_fast_labels.push_back(&&RomLine2412);
        main_exec_generated_fast_labels.push_back(&&RomLine2413);
        main_exec_generated_fast_labels.push_back(&&RomLine2414);
        main_exec_generated_fast_labels.push_back(&&RomLine2415);
        main_exec_generated_fast_labels.push_back(&&RomLine2416);
        main_exec_generated_fast_labels.push_back(&&RomLine2417);
        main_exec_generated_fast_labels.push_back(&&RomLine2418);
        main_exec_generated_fast_labels.push_back(&&RomLine2419);
        main_exec_generated_fast_labels.push_back(&&RomLine2420);
        main_exec_generated_fast_labels.push_back(&&RomLine2421);
        main_exec_generated_fast_labels.push_back(&&RomLine2422);
        main_exec_generated_fast_labels.push_back(&&RomLine2423);
        main_exec_generated_fast_labels.push_back(&&RomLine2424);
        main_exec_generated_fast_labels.push_back(&&RomLine2425);
        main_exec_generated_fast_labels.push_back(&&RomLine2426);
        main_exec_generated_fast_labels.push_back(&&RomLine2427);
        main_exec_generated_fast_labels.push_back(&&RomLine2428);
        main_exec_generated_fast_labels.push_back(&&RomLine2429);
        main_exec_generated_fast_labels.push_back(&&RomLine2430);
        main_exec_generated_fast_labels.push_back(&&RomLine2431);
        main_exec_generated_fast_labels.push_back(&&RomLine2432);
        main_exec_generated_fast_labels.push_back(&&RomLine2433);
        main_exec_generated_fast_labels.push_back(&&RomLine2434);
        main_exec_generated_fast_labels.push_back(&&RomLine2435);
        main_exec_generated_fast_labels.push_back(&&RomLine2436);
        main_exec_generated_fast_labels.push_back(&&RomLine2437);
        main_exec_generated_fast_labels.push_back(&&RomLine2438);
        main_exec_generated_fast_labels.push_back(&&RomLine2439);
        main_exec_generated_fast_labels.push_back(&&RomLine2440);
        main_exec_generated_fast_labels.push_back(&&RomLine2441);
        main_exec_generated_fast_labels.push_back(&&RomLine2442);
        main_exec_generated_fast_labels.push_back(&&RomLine2443);
        main_exec_generated_fast_labels.push_back(&&RomLine2444);
        main_exec_generated_fast_labels.push_back(&&RomLine2445);
        main_exec_generated_fast_labels.push_back(&&RomLine2446);
        main_exec_generated_fast_labels.push_back(&&RomLine2447);
        main_exec_generated_fast_labels.push_back(&&RomLine2448);
        main_exec_generated_fast_labels.push_back(&&RomLine2449);
        main_exec_generated_fast_labels.push_back(&&RomLine2450);
        main_exec_generated_fast_labels.push_back(&&RomLine2451);
        main_exec_generated_fast_labels.push_back(&&RomLine2452);
        main_exec_generated_fast_labels.push_back(&&RomLine2453);
        main_exec_generated_fast_labels.push_back(&&RomLine2454);
        main_exec_generated_fast_labels.push_back(&&RomLine2455);
        main_exec_generated_fast_labels.push_back(&&RomLine2456);
        main_exec_generated_fast_labels.push_back(&&RomLine2457);
        main_exec_generated_fast_labels.push_back(&&RomLine2458);
        main_exec_generated_fast_labels.push_back(&&RomLine2459);
        main_exec_generated_fast_labels.push_back(&&RomLine2460);
        main_exec_generated_fast_labels.push_back(&&RomLine2461);
        main_exec_generated_fast_labels.push_back(&&RomLine2462);
        main_exec_generated_fast_labels.push_back(&&RomLine2463);
        main_exec_generated_fast_labels.push_back(&&RomLine2464);
        main_exec_generated_fast_labels.push_back(&&RomLine2465);
        main_exec_generated_fast_labels.push_back(&&RomLine2466);
        main_exec_generated_fast_labels.push_back(&&RomLine2467);
        main_exec_generated_fast_labels.push_back(&&RomLine2468);
        main_exec_generated_fast_labels.push_back(&&RomLine2469);
        main_exec_generated_fast_labels.push_back(&&RomLine2470);
        main_exec_generated_fast_labels.push_back(&&RomLine2471);
        main_exec_generated_fast_labels.push_back(&&RomLine2472);
        main_exec_generated_fast_labels.push_back(&&RomLine2473);
        main_exec_generated_fast_labels.push_back(&&RomLine2474);
        main_exec_generated_fast_labels.push_back(&&RomLine2475);
        main_exec_generated_fast_labels.push_back(&&RomLine2476);
        main_exec_generated_fast_labels.push_back(&&RomLine2477);
        main_exec_generated_fast_labels.push_back(&&RomLine2478);
        main_exec_generated_fast_labels.push_back(&&RomLine2479);
        main_exec_generated_fast_labels.push_back(&&RomLine2480);
        main_exec_generated_fast_labels.push_back(&&RomLine2481);
        main_exec_generated_fast_labels.push_back(&&RomLine2482);
        main_exec_generated_fast_labels.push_back(&&RomLine2483);
        main_exec_generated_fast_labels.push_back(&&RomLine2484);
        main_exec_generated_fast_labels.push_back(&&RomLine2485);
        main_exec_generated_fast_labels.push_back(&&RomLine2486);
        main_exec_generated_fast_labels.push_back(&&RomLine2487);
        main_exec_generated_fast_labels.push_back(&&RomLine2488);
        main_exec_generated_fast_labels.push_back(&&RomLine2489);
        main_exec_generated_fast_labels.push_back(&&RomLine2490);
        main_exec_generated_fast_labels.push_back(&&RomLine2491);
        main_exec_generated_fast_labels.push_back(&&RomLine2492);
        main_exec_generated_fast_labels.push_back(&&RomLine2493);
        main_exec_generated_fast_labels.push_back(&&RomLine2494);
        main_exec_generated_fast_labels.push_back(&&RomLine2495);
        main_exec_generated_fast_labels.push_back(&&RomLine2496);
        main_exec_generated_fast_labels.push_back(&&RomLine2497);
        main_exec_generated_fast_labels.push_back(&&RomLine2498);
        main_exec_generated_fast_labels.push_back(&&RomLine2499);
        main_exec_generated_fast_labels.push_back(&&RomLine2500);
        main_exec_generated_fast_labels.push_back(&&RomLine2501);
        main_exec_generated_fast_labels.push_back(&&RomLine2502);
        main_exec_generated_fast_labels.push_back(&&RomLine2503);
        main_exec_generated_fast_labels.push_back(&&RomLine2504);
        main_exec_generated_fast_labels.push_back(&&RomLine2505);
        main_exec_generated_fast_labels.push_back(&&RomLine2506);
        main_exec_generated_fast_labels.push_back(&&RomLine2507);
        main_exec_generated_fast_labels.push_back(&&RomLine2508);
        main_exec_generated_fast_labels.push_back(&&RomLine2509);
        main_exec_generated_fast_labels.push_back(&&RomLine2510);
        main_exec_generated_fast_labels.push_back(&&RomLine2511);
        main_exec_generated_fast_labels.push_back(&&RomLine2512);
        main_exec_generated_fast_labels.push_back(&&RomLine2513);
        main_exec_generated_fast_labels.push_back(&&RomLine2514);
        main_exec_generated_fast_labels.push_back(&&RomLine2515);
        main_exec_generated_fast_labels.push_back(&&RomLine2516);
        main_exec_generated_fast_labels.push_back(&&RomLine2517);
        main_exec_generated_fast_labels.push_back(&&RomLine2518);
        main_exec_generated_fast_labels.push_back(&&RomLine2519);
        main_exec_generated_fast_labels.push_back(&&RomLine2520);
        main_exec_generated_fast_labels.push_back(&&RomLine2521);
        main_exec_generated_fast_labels.push_back(&&RomLine2522);
        main_exec_generated_fast_labels.push_back(&&RomLine2523);
        main_exec_generated_fast_labels.push_back(&&RomLine2524);
        main_exec_generated_fast_labels.push_back(&&RomLine2525);
        main_exec_generated_fast_labels.push_back(&&RomLine2526);
        main_exec_generated_fast_labels.push_back(&&RomLine2527);
        main_exec_generated_fast_labels.push_back(&&RomLine2528);
        main_exec_generated_fast_labels.push_back(&&RomLine2529);
        main_exec_generated_fast_labels.push_back(&&RomLine2530);
        main_exec_generated_fast_labels.push_back(&&RomLine2531);
        main_exec_generated_fast_labels.push_back(&&RomLine2532);
        main_exec_generated_fast_labels.push_back(&&RomLine2533);
        main_exec_generated_fast_labels.push_back(&&RomLine2534);
        main_exec_generated_fast_labels.push_back(&&RomLine2535);
        main_exec_generated_fast_labels.push_back(&&RomLine2536);
        main_exec_generated_fast_labels.push_back(&&RomLine2537);
        main_exec_generated_fast_labels.push_back(&&RomLine2538);
        main_exec_generated_fast_labels.push_back(&&RomLine2539);
        main_exec_generated_fast_labels.push_back(&&RomLine2540);
        main_exec_generated_fast_labels.push_back(&&RomLine2541);
        main_exec_generated_fast_labels.push_back(&&RomLine2542);
        main_exec_generated_fast_labels.push_back(&&RomLine2543);
        main_exec_generated_fast_labels.push_back(&&RomLine2544);
        main_exec_generated_fast_labels.push_back(&&RomLine2545);
        main_exec_generated_fast_labels.push_back(&&RomLine2546);
        main_exec_generated_fast_labels.push_back(&&RomLine2547);
        main_exec_generated_fast_labels.push_back(&&RomLine2548);
        main_exec_generated_fast_labels.push_back(&&RomLine2549);
        main_exec_generated_fast_labels.push_back(&&RomLine2550);
        main_exec_generated_fast_labels.push_back(&&RomLine2551);
        main_exec_generated_fast_labels.push_back(&&RomLine2552);
        main_exec_generated_fast_labels.push_back(&&RomLine2553);
        main_exec_generated_fast_labels.push_back(&&RomLine2554);
        main_exec_generated_fast_labels.push_back(&&RomLine2555);
        main_exec_generated_fast_labels.push_back(&&RomLine2556);
        main_exec_generated_fast_labels.push_back(&&RomLine2557);
        main_exec_generated_fast_labels.push_back(&&RomLine2558);
        main_exec_generated_fast_labels.push_back(&&RomLine2559);
        main_exec_generated_fast_labels.push_back(&&RomLine2560);
        main_exec_generated_fast_labels.push_back(&&RomLine2561);
        main_exec_generated_fast_labels.push_back(&&RomLine2562);
        main_exec_generated_fast_labels.push_back(&&RomLine2563);
        main_exec_generated_fast_labels.push_back(&&RomLine2564);
        main_exec_generated_fast_labels.push_back(&&RomLine2565);
        main_exec_generated_fast_labels.push_back(&&RomLine2566);
        main_exec_generated_fast_labels.push_back(&&RomLine2567);
        main_exec_generated_fast_labels.push_back(&&RomLine2568);
        main_exec_generated_fast_labels.push_back(&&RomLine2569);
        main_exec_generated_fast_labels.push_back(&&RomLine2570);
        main_exec_generated_fast_labels.push_back(&&RomLine2571);
        main_exec_generated_fast_labels.push_back(&&RomLine2572);
        main_exec_generated_fast_labels.push_back(&&RomLine2573);
        main_exec_generated_fast_labels.push_back(&&RomLine2574);
        main_exec_generated_fast_labels.push_back(&&RomLine2575);
        main_exec_generated_fast_labels.push_back(&&RomLine2576);
        main_exec_generated_fast_labels.push_back(&&RomLine2577);
        main_exec_generated_fast_labels.push_back(&&RomLine2578);
        main_exec_generated_fast_labels.push_back(&&RomLine2579);
        main_exec_generated_fast_labels.push_back(&&RomLine2580);
        main_exec_generated_fast_labels.push_back(&&RomLine2581);
        main_exec_generated_fast_labels.push_back(&&RomLine2582);
        main_exec_generated_fast_labels.push_back(&&RomLine2583);
        main_exec_generated_fast_labels.push_back(&&RomLine2584);
        main_exec_generated_fast_labels.push_back(&&RomLine2585);
        main_exec_generated_fast_labels.push_back(&&RomLine2586);
        main_exec_generated_fast_labels.push_back(&&RomLine2587);
        main_exec_generated_fast_labels.push_back(&&RomLine2588);
        main_exec_generated_fast_labels.push_back(&&RomLine2589);
        main_exec_generated_fast_labels.push_back(&&RomLine2590);
        main_exec_generated_fast_labels.push_back(&&RomLine2591);
        main_exec_generated_fast_labels.push_back(&&RomLine2592);
        main_exec_generated_fast_labels.push_back(&&RomLine2593);
        main_exec_generated_fast_labels.push_back(&&RomLine2594);
        main_exec_generated_fast_labels.push_back(&&RomLine2595);
        main_exec_generated_fast_labels.push_back(&&RomLine2596);
        main_exec_generated_fast_labels.push_back(&&RomLine2597);
        main_exec_generated_fast_labels.push_back(&&RomLine2598);
        main_exec_generated_fast_labels.push_back(&&RomLine2599);
        main_exec_generated_fast_labels.push_back(&&RomLine2600);
        main_exec_generated_fast_labels.push_back(&&RomLine2601);
        main_exec_generated_fast_labels.push_back(&&RomLine2602);
        main_exec_generated_fast_labels.push_back(&&RomLine2603);
        main_exec_generated_fast_labels.push_back(&&RomLine2604);
        main_exec_generated_fast_labels.push_back(&&RomLine2605);
        main_exec_generated_fast_labels.push_back(&&RomLine2606);
        main_exec_generated_fast_labels.push_back(&&RomLine2607);
        main_exec_generated_fast_labels.push_back(&&RomLine2608);
        main_exec_generated_fast_labels.push_back(&&RomLine2609);
        main_exec_generated_fast_labels.push_back(&&RomLine2610);
        main_exec_generated_fast_labels.push_back(&&RomLine2611);
        main_exec_generated_fast_labels.push_back(&&RomLine2612);
        main_exec_generated_fast_labels.push_back(&&RomLine2613);
        main_exec_generated_fast_labels.push_back(&&RomLine2614);
        main_exec_generated_fast_labels.push_back(&&RomLine2615);
        main_exec_generated_fast_labels.push_back(&&RomLine2616);
        main_exec_generated_fast_labels.push_back(&&RomLine2617);
        main_exec_generated_fast_labels.push_back(&&RomLine2618);
        main_exec_generated_fast_labels.push_back(&&RomLine2619);
        main_exec_generated_fast_labels.push_back(&&RomLine2620);
        main_exec_generated_fast_labels.push_back(&&RomLine2621);
        main_exec_generated_fast_labels.push_back(&&RomLine2622);
        main_exec_generated_fast_labels.push_back(&&RomLine2623);
        main_exec_generated_fast_labels.push_back(&&RomLine2624);
        main_exec_generated_fast_labels.push_back(&&RomLine2625);
        main_exec_generated_fast_labels.push_back(&&RomLine2626);
        main_exec_generated_fast_labels.push_back(&&RomLine2627);
        main_exec_generated_fast_labels.push_back(&&RomLine2628);
        main_exec_generated_fast_labels.push_back(&&RomLine2629);
        main_exec_generated_fast_labels.push_back(&&RomLine2630);
        main_exec_generated_fast_labels.push_back(&&RomLine2631);
        main_exec_generated_fast_labels.push_back(&&RomLine2632);
        main_exec_generated_fast_labels.push_back(&&RomLine2633);
        main_exec_generated_fast_labels.push_back(&&RomLine2634);
        main_exec_generated_fast_labels.push_back(&&RomLine2635);
        main_exec_generated_fast_labels.push_back(&&RomLine2636);
        main_exec_generated_fast_labels.push_back(&&RomLine2637);
        main_exec_generated_fast_labels.push_back(&&RomLine2638);
        main_exec_generated_fast_labels.push_back(&&RomLine2639);
        main_exec_generated_fast_labels.push_back(&&RomLine2640);
        main_exec_generated_fast_labels.push_back(&&RomLine2641);
        main_exec_generated_fast_labels.push_back(&&RomLine2642);
        main_exec_generated_fast_labels.push_back(&&RomLine2643);
        main_exec_generated_fast_labels.push_back(&&RomLine2644);
        main_exec_generated_fast_labels.push_back(&&RomLine2645);
        main_exec_generated_fast_labels.push_back(&&RomLine2646);
        main_exec_generated_fast_labels.push_back(&&RomLine2647);
        main_exec_generated_fast_labels.push_back(&&RomLine2648);
        main_exec_generated_fast_labels.push_back(&&RomLine2649);
        main_exec_generated_fast_labels.push_back(&&RomLine2650);
        main_exec_generated_fast_labels.push_back(&&RomLine2651);
        main_exec_generated_fast_labels.push_back(&&RomLine2652);
        main_exec_generated_fast_labels.push_back(&&RomLine2653);
        main_exec_generated_fast_labels.push_back(&&RomLine2654);
        main_exec_generated_fast_labels.push_back(&&RomLine2655);
        main_exec_generated_fast_labels.push_back(&&RomLine2656);
        main_exec_generated_fast_labels.push_back(&&RomLine2657);
        main_exec_generated_fast_labels.push_back(&&RomLine2658);
        main_exec_generated_fast_labels.push_back(&&RomLine2659);
        main_exec_generated_fast_labels.push_back(&&RomLine2660);
        main_exec_generated_fast_labels.push_back(&&RomLine2661);
        main_exec_generated_fast_labels.push_back(&&RomLine2662);
        main_exec_generated_fast_labels.push_back(&&RomLine2663);
        main_exec_generated_fast_labels.push_back(&&RomLine2664);
        main_exec_generated_fast_labels.push_back(&&RomLine2665);
        main_exec_generated_fast_labels.push_back(&&RomLine2666);
        main_exec_generated_fast_labels.push_back(&&RomLine2667);
        main_exec_generated_fast_labels.push_back(&&RomLine2668);
        main_exec_generated_fast_labels.push_back(&&RomLine2669);
        main_exec_generated_fast_labels.push_back(&&RomLine2670);
        main_exec_generated_fast_labels.push_back(&&RomLine2671);
        main_exec_generated_fast_labels.push_back(&&RomLine2672);
        main_exec_generated_fast_labels.push_back(&&RomLine2673);
        main_exec_generated_fast_labels.push_back(&&RomLine2674);
        main_exec_generated_fast_labels.push_back(&&RomLine2675);
        main_exec_generated_fast_labels.push_back(&&RomLine2676);
        main_exec_generated_fast_labels.push_back(&&RomLine2677);
        main_exec_generated_fast_labels.push_back(&&RomLine2678);
        main_exec_generated_fast_labels.push_back(&&RomLine2679);
        main_exec_generated_fast_labels.push_back(&&RomLine2680);
        main_exec_generated_fast_labels.push_back(&&RomLine2681);
        main_exec_generated_fast_labels.push_back(&&RomLine2682);
        main_exec_generated_fast_labels.push_back(&&RomLine2683);
        main_exec_generated_fast_labels.push_back(&&RomLine2684);
        main_exec_generated_fast_labels.push_back(&&RomLine2685);
        main_exec_generated_fast_labels.push_back(&&RomLine2686);
        main_exec_generated_fast_labels.push_back(&&RomLine2687);
        main_exec_generated_fast_labels.push_back(&&RomLine2688);
        main_exec_generated_fast_labels.push_back(&&RomLine2689);
        main_exec_generated_fast_labels.push_back(&&RomLine2690);
        main_exec_generated_fast_labels.push_back(&&RomLine2691);
        main_exec_generated_fast_labels.push_back(&&RomLine2692);
        main_exec_generated_fast_labels.push_back(&&RomLine2693);
        main_exec_generated_fast_labels.push_back(&&RomLine2694);
        main_exec_generated_fast_labels.push_back(&&RomLine2695);
        main_exec_generated_fast_labels.push_back(&&RomLine2696);
        main_exec_generated_fast_labels.push_back(&&RomLine2697);
        main_exec_generated_fast_labels.push_back(&&RomLine2698);
        main_exec_generated_fast_labels.push_back(&&RomLine2699);
        main_exec_generated_fast_labels.push_back(&&RomLine2700);
        main_exec_generated_fast_labels.push_back(&&RomLine2701);
        main_exec_generated_fast_labels.push_back(&&RomLine2702);
        main_exec_generated_fast_labels.push_back(&&RomLine2703);
        main_exec_generated_fast_labels.push_back(&&RomLine2704);
        main_exec_generated_fast_labels.push_back(&&RomLine2705);
        main_exec_generated_fast_labels.push_back(&&RomLine2706);
        main_exec_generated_fast_labels.push_back(&&RomLine2707);
        main_exec_generated_fast_labels.push_back(&&RomLine2708);
        main_exec_generated_fast_labels.push_back(&&RomLine2709);
        main_exec_generated_fast_labels.push_back(&&RomLine2710);
        main_exec_generated_fast_labels.push_back(&&RomLine2711);
        main_exec_generated_fast_labels.push_back(&&RomLine2712);
        main_exec_generated_fast_labels.push_back(&&RomLine2713);
        main_exec_generated_fast_labels.push_back(&&RomLine2714);
        main_exec_generated_fast_labels.push_back(&&RomLine2715);
        main_exec_generated_fast_labels.push_back(&&RomLine2716);
        main_exec_generated_fast_labels.push_back(&&RomLine2717);
        main_exec_generated_fast_labels.push_back(&&RomLine2718);
        main_exec_generated_fast_labels.push_back(&&RomLine2719);
        main_exec_generated_fast_labels.push_back(&&RomLine2720);
        main_exec_generated_fast_labels.push_back(&&RomLine2721);
        main_exec_generated_fast_labels.push_back(&&RomLine2722);
        main_exec_generated_fast_labels.push_back(&&RomLine2723);
        main_exec_generated_fast_labels.push_back(&&RomLine2724);
        main_exec_generated_fast_labels.push_back(&&RomLine2725);
        main_exec_generated_fast_labels.push_back(&&RomLine2726);
        main_exec_generated_fast_labels.push_back(&&RomLine2727);
        main_exec_generated_fast_labels.push_back(&&RomLine2728);
        main_exec_generated_fast_labels.push_back(&&RomLine2729);
        main_exec_generated_fast_labels.push_back(&&RomLine2730);
        main_exec_generated_fast_labels.push_back(&&RomLine2731);
        main_exec_generated_fast_labels.push_back(&&RomLine2732);
        main_exec_generated_fast_labels.push_back(&&RomLine2733);
        main_exec_generated_fast_labels.push_back(&&RomLine2734);
        main_exec_generated_fast_labels.push_back(&&RomLine2735);
        main_exec_generated_fast_labels.push_back(&&RomLine2736);
        main_exec_generated_fast_labels.push_back(&&RomLine2737);
        main_exec_generated_fast_labels.push_back(&&RomLine2738);
        main_exec_generated_fast_labels.push_back(&&RomLine2739);
        main_exec_generated_fast_labels.push_back(&&RomLine2740);
        main_exec_generated_fast_labels.push_back(&&RomLine2741);
        main_exec_generated_fast_labels.push_back(&&RomLine2742);
        main_exec_generated_fast_labels.push_back(&&RomLine2743);
        main_exec_generated_fast_labels.push_back(&&RomLine2744);
        main_exec_generated_fast_labels.push_back(&&RomLine2745);
        main_exec_generated_fast_labels.push_back(&&RomLine2746);
        main_exec_generated_fast_labels.push_back(&&RomLine2747);
        main_exec_generated_fast_labels.push_back(&&RomLine2748);
        main_exec_generated_fast_labels.push_back(&&RomLine2749);
        main_exec_generated_fast_labels.push_back(&&RomLine2750);
        main_exec_generated_fast_labels.push_back(&&RomLine2751);
        main_exec_generated_fast_labels.push_back(&&RomLine2752);
        main_exec_generated_fast_labels.push_back(&&RomLine2753);
        main_exec_generated_fast_labels.push_back(&&RomLine2754);
        main_exec_generated_fast_labels.push_back(&&RomLine2755);
        main_exec_generated_fast_labels.push_back(&&RomLine2756);
        main_exec_generated_fast_labels.push_back(&&RomLine2757);
        main_exec_generated_fast_labels.push_back(&&RomLine2758);
        main_exec_generated_fast_labels.push_back(&&RomLine2759);
        main_exec_generated_fast_labels.push_back(&&RomLine2760);
        main_exec_generated_fast_labels.push_back(&&RomLine2761);
        main_exec_generated_fast_labels.push_back(&&RomLine2762);
        main_exec_generated_fast_labels.push_back(&&RomLine2763);
        main_exec_generated_fast_labels.push_back(&&RomLine2764);
        main_exec_generated_fast_labels.push_back(&&RomLine2765);
        main_exec_generated_fast_labels.push_back(&&RomLine2766);
        main_exec_generated_fast_labels.push_back(&&RomLine2767);
        main_exec_generated_fast_labels.push_back(&&RomLine2768);
        main_exec_generated_fast_labels.push_back(&&RomLine2769);
        main_exec_generated_fast_labels.push_back(&&RomLine2770);
        main_exec_generated_fast_labels.push_back(&&RomLine2771);
        main_exec_generated_fast_labels.push_back(&&RomLine2772);
        main_exec_generated_fast_labels.push_back(&&RomLine2773);
        main_exec_generated_fast_labels.push_back(&&RomLine2774);
        main_exec_generated_fast_labels.push_back(&&RomLine2775);
        main_exec_generated_fast_labels.push_back(&&RomLine2776);
        main_exec_generated_fast_labels.push_back(&&RomLine2777);
        main_exec_generated_fast_labels.push_back(&&RomLine2778);
        main_exec_generated_fast_labels.push_back(&&RomLine2779);
        main_exec_generated_fast_labels.push_back(&&RomLine2780);
        main_exec_generated_fast_labels.push_back(&&RomLine2781);
        main_exec_generated_fast_labels.push_back(&&RomLine2782);
        main_exec_generated_fast_labels.push_back(&&RomLine2783);
        main_exec_generated_fast_labels.push_back(&&RomLine2784);
        main_exec_generated_fast_labels.push_back(&&RomLine2785);
        main_exec_generated_fast_labels.push_back(&&RomLine2786);
        main_exec_generated_fast_labels.push_back(&&RomLine2787);
        main_exec_generated_fast_labels.push_back(&&RomLine2788);
        main_exec_generated_fast_labels.push_back(&&RomLine2789);
        main_exec_generated_fast_labels.push_back(&&RomLine2790);
        main_exec_generated_fast_labels.push_back(&&RomLine2791);
        main_exec_generated_fast_labels.push_back(&&RomLine2792);
        main_exec_generated_fast_labels.push_back(&&RomLine2793);
        main_exec_generated_fast_labels.push_back(&&RomLine2794);
        main_exec_generated_fast_labels.push_back(&&RomLine2795);
        main_exec_generated_fast_labels.push_back(&&RomLine2796);
        main_exec_generated_fast_labels.push_back(&&RomLine2797);
        main_exec_generated_fast_labels.push_back(&&RomLine2798);
        main_exec_generated_fast_labels.push_back(&&RomLine2799);
        main_exec_generated_fast_labels.push_back(&&RomLine2800);
        main_exec_generated_fast_labels.push_back(&&RomLine2801);
        main_exec_generated_fast_labels.push_back(&&RomLine2802);
        main_exec_generated_fast_labels.push_back(&&RomLine2803);
        main_exec_generated_fast_labels.push_back(&&RomLine2804);
        main_exec_generated_fast_labels.push_back(&&RomLine2805);
        main_exec_generated_fast_labels.push_back(&&RomLine2806);
        main_exec_generated_fast_labels.push_back(&&RomLine2807);
        main_exec_generated_fast_labels.push_back(&&RomLine2808);
        main_exec_generated_fast_labels.push_back(&&RomLine2809);
        main_exec_generated_fast_labels.push_back(&&RomLine2810);
        main_exec_generated_fast_labels.push_back(&&RomLine2811);
        main_exec_generated_fast_labels.push_back(&&RomLine2812);
        main_exec_generated_fast_labels.push_back(&&RomLine2813);
        main_exec_generated_fast_labels.push_back(&&RomLine2814);
        main_exec_generated_fast_labels.push_back(&&RomLine2815);
        main_exec_generated_fast_labels.push_back(&&RomLine2816);
        main_exec_generated_fast_labels.push_back(&&RomLine2817);
        main_exec_generated_fast_labels.push_back(&&RomLine2818);
        main_exec_generated_fast_labels.push_back(&&RomLine2819);
        main_exec_generated_fast_labels.push_back(&&RomLine2820);
        main_exec_generated_fast_labels.push_back(&&RomLine2821);
        main_exec_generated_fast_labels.push_back(&&RomLine2822);
        main_exec_generated_fast_labels.push_back(&&RomLine2823);
        main_exec_generated_fast_labels.push_back(&&RomLine2824);
        main_exec_generated_fast_labels.push_back(&&RomLine2825);
        main_exec_generated_fast_labels.push_back(&&RomLine2826);
        main_exec_generated_fast_labels.push_back(&&RomLine2827);
        main_exec_generated_fast_labels.push_back(&&RomLine2828);
        main_exec_generated_fast_labels.push_back(&&RomLine2829);
        main_exec_generated_fast_labels.push_back(&&RomLine2830);
        main_exec_generated_fast_labels.push_back(&&RomLine2831);
        main_exec_generated_fast_labels.push_back(&&RomLine2832);
        main_exec_generated_fast_labels.push_back(&&RomLine2833);
        main_exec_generated_fast_labels.push_back(&&RomLine2834);
        main_exec_generated_fast_labels.push_back(&&RomLine2835);
        main_exec_generated_fast_labels.push_back(&&RomLine2836);
        main_exec_generated_fast_labels.push_back(&&RomLine2837);
        main_exec_generated_fast_labels.push_back(&&RomLine2838);
        main_exec_generated_fast_labels.push_back(&&RomLine2839);
        main_exec_generated_fast_labels.push_back(&&RomLine2840);
        main_exec_generated_fast_labels.push_back(&&RomLine2841);
        main_exec_generated_fast_labels.push_back(&&RomLine2842);
        main_exec_generated_fast_labels.push_back(&&RomLine2843);
        main_exec_generated_fast_labels.push_back(&&RomLine2844);
        main_exec_generated_fast_labels.push_back(&&RomLine2845);
        main_exec_generated_fast_labels.push_back(&&RomLine2846);
        main_exec_generated_fast_labels.push_back(&&RomLine2847);
        main_exec_generated_fast_labels.push_back(&&RomLine2848);
        main_exec_generated_fast_labels.push_back(&&RomLine2849);
        main_exec_generated_fast_labels.push_back(&&RomLine2850);
        main_exec_generated_fast_labels.push_back(&&RomLine2851);
        main_exec_generated_fast_labels.push_back(&&RomLine2852);
        main_exec_generated_fast_labels.push_back(&&RomLine2853);
        main_exec_generated_fast_labels.push_back(&&RomLine2854);
        main_exec_generated_fast_labels.push_back(&&RomLine2855);
        main_exec_generated_fast_labels.push_back(&&RomLine2856);
        main_exec_generated_fast_labels.push_back(&&RomLine2857);
        main_exec_generated_fast_labels.push_back(&&RomLine2858);
        main_exec_generated_fast_labels.push_back(&&RomLine2859);
        main_exec_generated_fast_labels.push_back(&&RomLine2860);
        main_exec_generated_fast_labels.push_back(&&RomLine2861);
        main_exec_generated_fast_labels.push_back(&&RomLine2862);
        main_exec_generated_fast_labels.push_back(&&RomLine2863);
        main_exec_generated_fast_labels.push_back(&&RomLine2864);
        main_exec_generated_fast_labels.push_back(&&RomLine2865);
        main_exec_generated_fast_labels.push_back(&&RomLine2866);
        main_exec_generated_fast_labels.push_back(&&RomLine2867);
        main_exec_generated_fast_labels.push_back(&&RomLine2868);
        main_exec_generated_fast_labels.push_back(&&RomLine2869);
        main_exec_generated_fast_labels.push_back(&&RomLine2870);
        main_exec_generated_fast_labels.push_back(&&RomLine2871);
        main_exec_generated_fast_labels.push_back(&&RomLine2872);
        main_exec_generated_fast_labels.push_back(&&RomLine2873);
        main_exec_generated_fast_labels.push_back(&&RomLine2874);
        main_exec_generated_fast_labels.push_back(&&RomLine2875);
        main_exec_generated_fast_labels.push_back(&&RomLine2876);
        main_exec_generated_fast_labels.push_back(&&RomLine2877);
        main_exec_generated_fast_labels.push_back(&&RomLine2878);
        main_exec_generated_fast_labels.push_back(&&RomLine2879);
        main_exec_generated_fast_labels.push_back(&&RomLine2880);
        main_exec_generated_fast_labels.push_back(&&RomLine2881);
        main_exec_generated_fast_labels.push_back(&&RomLine2882);
        main_exec_generated_fast_labels.push_back(&&RomLine2883);
        main_exec_generated_fast_labels.push_back(&&RomLine2884);
        main_exec_generated_fast_labels.push_back(&&RomLine2885);
        main_exec_generated_fast_labels.push_back(&&RomLine2886);
        main_exec_generated_fast_labels.push_back(&&RomLine2887);
        main_exec_generated_fast_labels.push_back(&&RomLine2888);
        main_exec_generated_fast_labels.push_back(&&RomLine2889);
        main_exec_generated_fast_labels.push_back(&&RomLine2890);
        main_exec_generated_fast_labels.push_back(&&RomLine2891);
        main_exec_generated_fast_labels.push_back(&&RomLine2892);
        main_exec_generated_fast_labels.push_back(&&RomLine2893);
        main_exec_generated_fast_labels.push_back(&&RomLine2894);
        main_exec_generated_fast_labels.push_back(&&RomLine2895);
        main_exec_generated_fast_labels.push_back(&&RomLine2896);
        main_exec_generated_fast_labels.push_back(&&RomLine2897);
        main_exec_generated_fast_labels.push_back(&&RomLine2898);
        main_exec_generated_fast_labels.push_back(&&RomLine2899);
        main_exec_generated_fast_labels.push_back(&&RomLine2900);
        main_exec_generated_fast_labels.push_back(&&RomLine2901);
        main_exec_generated_fast_labels.push_back(&&RomLine2902);
        main_exec_generated_fast_labels.push_back(&&RomLine2903);
        main_exec_generated_fast_labels.push_back(&&RomLine2904);
        main_exec_generated_fast_labels.push_back(&&RomLine2905);
        main_exec_generated_fast_labels.push_back(&&RomLine2906);
        main_exec_generated_fast_labels.push_back(&&RomLine2907);
        main_exec_generated_fast_labels.push_back(&&RomLine2908);
        main_exec_generated_fast_labels.push_back(&&RomLine2909);
        main_exec_generated_fast_labels.push_back(&&RomLine2910);
        main_exec_generated_fast_labels.push_back(&&RomLine2911);
        main_exec_generated_fast_labels.push_back(&&RomLine2912);
        main_exec_generated_fast_labels.push_back(&&RomLine2913);
        main_exec_generated_fast_labels.push_back(&&RomLine2914);
        main_exec_generated_fast_labels.push_back(&&RomLine2915);
        main_exec_generated_fast_labels.push_back(&&RomLine2916);
        main_exec_generated_fast_labels.push_back(&&RomLine2917);
        main_exec_generated_fast_labels.push_back(&&RomLine2918);
        main_exec_generated_fast_labels.push_back(&&RomLine2919);
        main_exec_generated_fast_labels.push_back(&&RomLine2920);
        main_exec_generated_fast_labels.push_back(&&RomLine2921);
        main_exec_generated_fast_labels.push_back(&&RomLine2922);
        main_exec_generated_fast_labels.push_back(&&RomLine2923);
        main_exec_generated_fast_labels.push_back(&&RomLine2924);
        main_exec_generated_fast_labels.push_back(&&RomLine2925);
        main_exec_generated_fast_labels.push_back(&&RomLine2926);
        main_exec_generated_fast_labels.push_back(&&RomLine2927);
        main_exec_generated_fast_labels.push_back(&&RomLine2928);
        main_exec_generated_fast_labels.push_back(&&RomLine2929);
        main_exec_generated_fast_labels.push_back(&&RomLine2930);
        main_exec_generated_fast_labels.push_back(&&RomLine2931);
        main_exec_generated_fast_labels.push_back(&&RomLine2932);
        main_exec_generated_fast_labels.push_back(&&RomLine2933);
        main_exec_generated_fast_labels.push_back(&&RomLine2934);
        main_exec_generated_fast_labels.push_back(&&RomLine2935);
        main_exec_generated_fast_labels.push_back(&&RomLine2936);
        main_exec_generated_fast_labels.push_back(&&RomLine2937);
        main_exec_generated_fast_labels.push_back(&&RomLine2938);
        main_exec_generated_fast_labels.push_back(&&RomLine2939);
        main_exec_generated_fast_labels.push_back(&&RomLine2940);
        main_exec_generated_fast_labels.push_back(&&RomLine2941);
        main_exec_generated_fast_labels.push_back(&&RomLine2942);
        main_exec_generated_fast_labels.push_back(&&RomLine2943);
        main_exec_generated_fast_labels.push_back(&&RomLine2944);
        main_exec_generated_fast_labels.push_back(&&RomLine2945);
        main_exec_generated_fast_labels.push_back(&&RomLine2946);
        main_exec_generated_fast_labels.push_back(&&RomLine2947);
        main_exec_generated_fast_labels.push_back(&&RomLine2948);
        main_exec_generated_fast_labels.push_back(&&RomLine2949);
        main_exec_generated_fast_labels.push_back(&&RomLine2950);
        main_exec_generated_fast_labels.push_back(&&RomLine2951);
        main_exec_generated_fast_labels.push_back(&&RomLine2952);
        main_exec_generated_fast_labels.push_back(&&RomLine2953);
        main_exec_generated_fast_labels.push_back(&&RomLine2954);
        main_exec_generated_fast_labels.push_back(&&RomLine2955);
        main_exec_generated_fast_labels.push_back(&&RomLine2956);
        main_exec_generated_fast_labels.push_back(&&RomLine2957);
        main_exec_generated_fast_labels.push_back(&&RomLine2958);
        main_exec_generated_fast_labels.push_back(&&RomLine2959);
        main_exec_generated_fast_labels.push_back(&&RomLine2960);
        main_exec_generated_fast_labels.push_back(&&RomLine2961);
        main_exec_generated_fast_labels.push_back(&&RomLine2962);
        main_exec_generated_fast_labels.push_back(&&RomLine2963);
        main_exec_generated_fast_labels.push_back(&&RomLine2964);
        main_exec_generated_fast_labels.push_back(&&RomLine2965);
        main_exec_generated_fast_labels.push_back(&&RomLine2966);
        main_exec_generated_fast_labels.push_back(&&RomLine2967);
        main_exec_generated_fast_labels.push_back(&&RomLine2968);
        main_exec_generated_fast_labels.push_back(&&RomLine2969);
        main_exec_generated_fast_labels.push_back(&&RomLine2970);
        main_exec_generated_fast_labels.push_back(&&RomLine2971);
        main_exec_generated_fast_labels.push_back(&&RomLine2972);
        main_exec_generated_fast_labels.push_back(&&RomLine2973);
        main_exec_generated_fast_labels.push_back(&&RomLine2974);
        main_exec_generated_fast_labels.push_back(&&RomLine2975);
        main_exec_generated_fast_labels.push_back(&&RomLine2976);
        main_exec_generated_fast_labels.push_back(&&RomLine2977);
        main_exec_generated_fast_labels.push_back(&&RomLine2978);
        main_exec_generated_fast_labels.push_back(&&RomLine2979);
        main_exec_generated_fast_labels.push_back(&&RomLine2980);
        main_exec_generated_fast_labels.push_back(&&RomLine2981);
        main_exec_generated_fast_labels.push_back(&&RomLine2982);
        main_exec_generated_fast_labels.push_back(&&RomLine2983);
        main_exec_generated_fast_labels.push_back(&&RomLine2984);
        main_exec_generated_fast_labels.push_back(&&RomLine2985);
        main_exec_generated_fast_labels.push_back(&&RomLine2986);
        main_exec_generated_fast_labels.push_back(&&RomLine2987);
        main_exec_generated_fast_labels.push_back(&&RomLine2988);
        main_exec_generated_fast_labels.push_back(&&RomLine2989);
        main_exec_generated_fast_labels.push_back(&&RomLine2990);
        main_exec_generated_fast_labels.push_back(&&RomLine2991);
        main_exec_generated_fast_labels.push_back(&&RomLine2992);
        main_exec_generated_fast_labels.push_back(&&RomLine2993);
        main_exec_generated_fast_labels.push_back(&&RomLine2994);
        main_exec_generated_fast_labels.push_back(&&RomLine2995);
        main_exec_generated_fast_labels.push_back(&&RomLine2996);
        main_exec_generated_fast_labels.push_back(&&RomLine2997);
        main_exec_generated_fast_labels.push_back(&&RomLine2998);
        main_exec_generated_fast_labels.push_back(&&RomLine2999);
        main_exec_generated_fast_labels.push_back(&&RomLine3000);
        main_exec_generated_fast_labels.push_back(&&RomLine3001);
        main_exec_generated_fast_labels.push_back(&&RomLine3002);
        main_exec_generated_fast_labels.push_back(&&RomLine3003);
        main_exec_generated_fast_labels.push_back(&&RomLine3004);
        main_exec_generated_fast_labels.push_back(&&RomLine3005);
        main_exec_generated_fast_labels.push_back(&&RomLine3006);
        main_exec_generated_fast_labels.push_back(&&RomLine3007);
        main_exec_generated_fast_labels.push_back(&&RomLine3008);
        main_exec_generated_fast_labels.push_back(&&RomLine3009);
        main_exec_generated_fast_labels.push_back(&&RomLine3010);
        main_exec_generated_fast_labels.push_back(&&RomLine3011);
        main_exec_generated_fast_labels.push_back(&&RomLine3012);
        main_exec_generated_fast_labels.push_back(&&RomLine3013);
        main_exec_generated_fast_labels.push_back(&&RomLine3014);
        main_exec_generated_fast_labels.push_back(&&RomLine3015);
        main_exec_generated_fast_labels.push_back(&&RomLine3016);
        main_exec_generated_fast_labels.push_back(&&RomLine3017);
        main_exec_generated_fast_labels.push_back(&&RomLine3018);
        main_exec_generated_fast_labels.push_back(&&RomLine3019);
        main_exec_generated_fast_labels.push_back(&&RomLine3020);
        main_exec_generated_fast_labels.push_back(&&RomLine3021);
        main_exec_generated_fast_labels.push_back(&&RomLine3022);
        main_exec_generated_fast_labels.push_back(&&RomLine3023);
        main_exec_generated_fast_labels.push_back(&&RomLine3024);
        main_exec_generated_fast_labels.push_back(&&RomLine3025);
        main_exec_generated_fast_labels.push_back(&&RomLine3026);
        main_exec_generated_fast_labels.push_back(&&RomLine3027);
        main_exec_generated_fast_labels.push_back(&&RomLine3028);
        main_exec_generated_fast_labels.push_back(&&RomLine3029);
        main_exec_generated_fast_labels.push_back(&&RomLine3030);
        main_exec_generated_fast_labels.push_back(&&RomLine3031);
        main_exec_generated_fast_labels.push_back(&&RomLine3032);
        main_exec_generated_fast_labels.push_back(&&RomLine3033);
        main_exec_generated_fast_labels.push_back(&&RomLine3034);
        main_exec_generated_fast_labels.push_back(&&RomLine3035);
        main_exec_generated_fast_labels.push_back(&&RomLine3036);
        main_exec_generated_fast_labels.push_back(&&RomLine3037);
        main_exec_generated_fast_labels.push_back(&&RomLine3038);
        main_exec_generated_fast_labels.push_back(&&RomLine3039);
        main_exec_generated_fast_labels.push_back(&&RomLine3040);
        main_exec_generated_fast_labels.push_back(&&RomLine3041);
        main_exec_generated_fast_labels.push_back(&&RomLine3042);
        main_exec_generated_fast_labels.push_back(&&RomLine3043);
        main_exec_generated_fast_labels.push_back(&&RomLine3044);
        main_exec_generated_fast_labels.push_back(&&RomLine3045);
        main_exec_generated_fast_labels.push_back(&&RomLine3046);
        main_exec_generated_fast_labels.push_back(&&RomLine3047);
        main_exec_generated_fast_labels.push_back(&&RomLine3048);
        main_exec_generated_fast_labels.push_back(&&RomLine3049);
        main_exec_generated_fast_labels.push_back(&&RomLine3050);
        main_exec_generated_fast_labels.push_back(&&RomLine3051);
        main_exec_generated_fast_labels.push_back(&&RomLine3052);
        main_exec_generated_fast_labels.push_back(&&RomLine3053);
        main_exec_generated_fast_labels.push_back(&&RomLine3054);
        main_exec_generated_fast_labels.push_back(&&RomLine3055);
        main_exec_generated_fast_labels.push_back(&&RomLine3056);
        main_exec_generated_fast_labels.push_back(&&RomLine3057);
        main_exec_generated_fast_labels.push_back(&&RomLine3058);
        main_exec_generated_fast_labels.push_back(&&RomLine3059);
        main_exec_generated_fast_labels.push_back(&&RomLine3060);
        main_exec_generated_fast_labels.push_back(&&RomLine3061);
        main_exec_generated_fast_labels.push_back(&&RomLine3062);
        main_exec_generated_fast_labels.push_back(&&RomLine3063);
        main_exec_generated_fast_labels.push_back(&&RomLine3064);
        main_exec_generated_fast_labels.push_back(&&RomLine3065);
        main_exec_generated_fast_labels.push_back(&&RomLine3066);
        main_exec_generated_fast_labels.push_back(&&RomLine3067);
        main_exec_generated_fast_labels.push_back(&&RomLine3068);
        main_exec_generated_fast_labels.push_back(&&RomLine3069);
        main_exec_generated_fast_labels.push_back(&&RomLine3070);
        main_exec_generated_fast_labels.push_back(&&RomLine3071);
        main_exec_generated_fast_labels.push_back(&&RomLine3072);
        main_exec_generated_fast_labels.push_back(&&RomLine3073);
        main_exec_generated_fast_labels.push_back(&&RomLine3074);
        main_exec_generated_fast_labels.push_back(&&RomLine3075);
        main_exec_generated_fast_labels.push_back(&&RomLine3076);
        main_exec_generated_fast_labels.push_back(&&RomLine3077);
        main_exec_generated_fast_labels.push_back(&&RomLine3078);
        main_exec_generated_fast_labels.push_back(&&RomLine3079);
        main_exec_generated_fast_labels.push_back(&&RomLine3080);
        main_exec_generated_fast_labels.push_back(&&RomLine3081);
        main_exec_generated_fast_labels.push_back(&&RomLine3082);
        main_exec_generated_fast_labels.push_back(&&RomLine3083);
        main_exec_generated_fast_labels.push_back(&&RomLine3084);
        main_exec_generated_fast_labels.push_back(&&RomLine3085);
        main_exec_generated_fast_labels.push_back(&&RomLine3086);
        main_exec_generated_fast_labels.push_back(&&RomLine3087);
        main_exec_generated_fast_labels.push_back(&&RomLine3088);
        main_exec_generated_fast_labels.push_back(&&RomLine3089);
        main_exec_generated_fast_labels.push_back(&&RomLine3090);
        main_exec_generated_fast_labels.push_back(&&RomLine3091);
        main_exec_generated_fast_labels.push_back(&&RomLine3092);
        main_exec_generated_fast_labels.push_back(&&RomLine3093);
        main_exec_generated_fast_labels.push_back(&&RomLine3094);
        main_exec_generated_fast_labels.push_back(&&RomLine3095);
        main_exec_generated_fast_labels.push_back(&&RomLine3096);
        main_exec_generated_fast_labels.push_back(&&RomLine3097);
        main_exec_generated_fast_labels.push_back(&&RomLine3098);
        main_exec_generated_fast_labels.push_back(&&RomLine3099);
        main_exec_generated_fast_labels.push_back(&&RomLine3100);
        main_exec_generated_fast_labels.push_back(&&RomLine3101);
        main_exec_generated_fast_labels.push_back(&&RomLine3102);
        main_exec_generated_fast_labels.push_back(&&RomLine3103);
        main_exec_generated_fast_labels.push_back(&&RomLine3104);
        main_exec_generated_fast_labels.push_back(&&RomLine3105);
        main_exec_generated_fast_labels.push_back(&&RomLine3106);
        main_exec_generated_fast_labels.push_back(&&RomLine3107);
        main_exec_generated_fast_labels.push_back(&&RomLine3108);
        main_exec_generated_fast_labels.push_back(&&RomLine3109);
        main_exec_generated_fast_labels.push_back(&&RomLine3110);
        main_exec_generated_fast_labels.push_back(&&RomLine3111);
        main_exec_generated_fast_labels.push_back(&&RomLine3112);
        main_exec_generated_fast_labels.push_back(&&RomLine3113);
        main_exec_generated_fast_labels.push_back(&&RomLine3114);
        main_exec_generated_fast_labels.push_back(&&RomLine3115);
        main_exec_generated_fast_labels.push_back(&&RomLine3116);
        main_exec_generated_fast_labels.push_back(&&RomLine3117);
        main_exec_generated_fast_labels.push_back(&&RomLine3118);
        main_exec_generated_fast_labels.push_back(&&RomLine3119);
        main_exec_generated_fast_labels.push_back(&&RomLine3120);
        main_exec_generated_fast_labels.push_back(&&RomLine3121);
        main_exec_generated_fast_labels.push_back(&&RomLine3122);
        main_exec_generated_fast_labels.push_back(&&RomLine3123);
        main_exec_generated_fast_labels.push_back(&&RomLine3124);
        main_exec_generated_fast_labels.push_back(&&RomLine3125);
        main_exec_generated_fast_labels.push_back(&&RomLine3126);
        main_exec_generated_fast_labels.push_back(&&RomLine3127);
        main_exec_generated_fast_labels.push_back(&&RomLine3128);
        main_exec_generated_fast_labels.push_back(&&RomLine3129);
        main_exec_generated_fast_labels.push_back(&&RomLine3130);
        main_exec_generated_fast_labels.push_back(&&RomLine3131);
        main_exec_generated_fast_labels.push_back(&&RomLine3132);
        main_exec_generated_fast_labels.push_back(&&RomLine3133);
        main_exec_generated_fast_labels.push_back(&&RomLine3134);
        main_exec_generated_fast_labels.push_back(&&RomLine3135);
        main_exec_generated_fast_labels.push_back(&&RomLine3136);
        main_exec_generated_fast_labels.push_back(&&RomLine3137);
        main_exec_generated_fast_labels.push_back(&&RomLine3138);
        main_exec_generated_fast_labels.push_back(&&RomLine3139);
        main_exec_generated_fast_labels.push_back(&&RomLine3140);
        main_exec_generated_fast_labels.push_back(&&RomLine3141);
        main_exec_generated_fast_labels.push_back(&&RomLine3142);
        main_exec_generated_fast_labels.push_back(&&RomLine3143);
        main_exec_generated_fast_labels.push_back(&&RomLine3144);
        main_exec_generated_fast_labels.push_back(&&RomLine3145);
        main_exec_generated_fast_labels.push_back(&&RomLine3146);
        main_exec_generated_fast_labels.push_back(&&RomLine3147);
        main_exec_generated_fast_labels.push_back(&&RomLine3148);
        main_exec_generated_fast_labels.push_back(&&RomLine3149);
        main_exec_generated_fast_labels.push_back(&&RomLine3150);
        main_exec_generated_fast_labels.push_back(&&RomLine3151);
        main_exec_generated_fast_labels.push_back(&&RomLine3152);
        main_exec_generated_fast_labels.push_back(&&RomLine3153);
        main_exec_generated_fast_labels.push_back(&&RomLine3154);
        main_exec_generated_fast_labels.push_back(&&RomLine3155);
        main_exec_generated_fast_labels.push_back(&&RomLine3156);
        main_exec_generated_fast_labels.push_back(&&RomLine3157);
        main_exec_generated_fast_labels.push_back(&&RomLine3158);
        main_exec_generated_fast_labels.push_back(&&RomLine3159);
        main_exec_generated_fast_labels.push_back(&&RomLine3160);
        main_exec_generated_fast_labels.push_back(&&RomLine3161);
        main_exec_generated_fast_labels.push_back(&&RomLine3162);
        main_exec_generated_fast_labels.push_back(&&RomLine3163);
        main_exec_generated_fast_labels.push_back(&&RomLine3164);
        main_exec_generated_fast_labels.push_back(&&RomLine3165);
        main_exec_generated_fast_labels.push_back(&&RomLine3166);
        main_exec_generated_fast_labels.push_back(&&RomLine3167);
        main_exec_generated_fast_labels.push_back(&&RomLine3168);
        main_exec_generated_fast_labels.push_back(&&RomLine3169);
        main_exec_generated_fast_labels.push_back(&&RomLine3170);
        main_exec_generated_fast_labels.push_back(&&RomLine3171);
        main_exec_generated_fast_labels.push_back(&&RomLine3172);
        main_exec_generated_fast_labels.push_back(&&RomLine3173);
        main_exec_generated_fast_labels.push_back(&&RomLine3174);
        main_exec_generated_fast_labels.push_back(&&RomLine3175);
        main_exec_generated_fast_labels.push_back(&&RomLine3176);
        main_exec_generated_fast_labels.push_back(&&RomLine3177);
        main_exec_generated_fast_labels.push_back(&&RomLine3178);
        main_exec_generated_fast_labels.push_back(&&RomLine3179);
        main_exec_generated_fast_labels.push_back(&&RomLine3180);
        main_exec_generated_fast_labels.push_back(&&RomLine3181);
        main_exec_generated_fast_labels.push_back(&&RomLine3182);
        main_exec_generated_fast_labels.push_back(&&RomLine3183);
        main_exec_generated_fast_labels.push_back(&&RomLine3184);
        main_exec_generated_fast_labels.push_back(&&RomLine3185);
        main_exec_generated_fast_labels.push_back(&&RomLine3186);
        main_exec_generated_fast_labels.push_back(&&RomLine3187);
        main_exec_generated_fast_labels.push_back(&&RomLine3188);
        main_exec_generated_fast_labels.push_back(&&RomLine3189);
        main_exec_generated_fast_labels.push_back(&&RomLine3190);
        main_exec_generated_fast_labels.push_back(&&RomLine3191);
        main_exec_generated_fast_labels.push_back(&&RomLine3192);
        main_exec_generated_fast_labels.push_back(&&RomLine3193);
        main_exec_generated_fast_labels.push_back(&&RomLine3194);
        main_exec_generated_fast_labels.push_back(&&RomLine3195);
        main_exec_generated_fast_labels.push_back(&&RomLine3196);
        main_exec_generated_fast_labels.push_back(&&RomLine3197);
        main_exec_generated_fast_labels.push_back(&&RomLine3198);
        main_exec_generated_fast_labels.push_back(&&RomLine3199);
        main_exec_generated_fast_labels.push_back(&&RomLine3200);
        main_exec_generated_fast_labels.push_back(&&RomLine3201);
        main_exec_generated_fast_labels.push_back(&&RomLine3202);
        main_exec_generated_fast_labels.push_back(&&RomLine3203);
        main_exec_generated_fast_labels.push_back(&&RomLine3204);
        main_exec_generated_fast_labels.push_back(&&RomLine3205);
        main_exec_generated_fast_labels.push_back(&&RomLine3206);
        main_exec_generated_fast_labels.push_back(&&RomLine3207);
        main_exec_generated_fast_labels.push_back(&&RomLine3208);
        main_exec_generated_fast_labels.push_back(&&RomLine3209);
        main_exec_generated_fast_labels.push_back(&&RomLine3210);
        main_exec_generated_fast_labels.push_back(&&RomLine3211);
        main_exec_generated_fast_labels.push_back(&&RomLine3212);
        main_exec_generated_fast_labels.push_back(&&RomLine3213);
        main_exec_generated_fast_labels.push_back(&&RomLine3214);
        main_exec_generated_fast_labels.push_back(&&RomLine3215);
        main_exec_generated_fast_labels.push_back(&&RomLine3216);
        main_exec_generated_fast_labels.push_back(&&RomLine3217);
        main_exec_generated_fast_labels.push_back(&&RomLine3218);
        main_exec_generated_fast_labels.push_back(&&RomLine3219);
        main_exec_generated_fast_labels.push_back(&&RomLine3220);
        main_exec_generated_fast_labels.push_back(&&RomLine3221);
        main_exec_generated_fast_labels.push_back(&&RomLine3222);
        main_exec_generated_fast_labels.push_back(&&RomLine3223);
        main_exec_generated_fast_labels.push_back(&&RomLine3224);
        main_exec_generated_fast_labels.push_back(&&RomLine3225);
        main_exec_generated_fast_labels.push_back(&&RomLine3226);
        main_exec_generated_fast_labels.push_back(&&RomLine3227);
        main_exec_generated_fast_labels.push_back(&&RomLine3228);
        main_exec_generated_fast_labels.push_back(&&RomLine3229);
        main_exec_generated_fast_labels.push_back(&&RomLine3230);
        main_exec_generated_fast_labels.push_back(&&RomLine3231);
        main_exec_generated_fast_labels.push_back(&&RomLine3232);
        main_exec_generated_fast_labels.push_back(&&RomLine3233);
        main_exec_generated_fast_labels.push_back(&&RomLine3234);
        main_exec_generated_fast_labels.push_back(&&RomLine3235);
        main_exec_generated_fast_labels.push_back(&&RomLine3236);
        main_exec_generated_fast_labels.push_back(&&RomLine3237);
        main_exec_generated_fast_labels.push_back(&&RomLine3238);
        main_exec_generated_fast_labels.push_back(&&RomLine3239);
        main_exec_generated_fast_labels.push_back(&&RomLine3240);
        main_exec_generated_fast_labels.push_back(&&RomLine3241);
        main_exec_generated_fast_labels.push_back(&&RomLine3242);
        main_exec_generated_fast_labels.push_back(&&RomLine3243);
        main_exec_generated_fast_labels.push_back(&&RomLine3244);
        main_exec_generated_fast_labels.push_back(&&RomLine3245);
        main_exec_generated_fast_labels.push_back(&&RomLine3246);
        main_exec_generated_fast_labels.push_back(&&RomLine3247);
        main_exec_generated_fast_labels.push_back(&&RomLine3248);
        main_exec_generated_fast_labels.push_back(&&RomLine3249);
        main_exec_generated_fast_labels.push_back(&&RomLine3250);
        main_exec_generated_fast_labels.push_back(&&RomLine3251);
        main_exec_generated_fast_labels.push_back(&&RomLine3252);
        main_exec_generated_fast_labels.push_back(&&RomLine3253);
        main_exec_generated_fast_labels.push_back(&&RomLine3254);
        main_exec_generated_fast_labels.push_back(&&RomLine3255);
        main_exec_generated_fast_labels.push_back(&&RomLine3256);
        main_exec_generated_fast_labels.push_back(&&RomLine3257);
        main_exec_generated_fast_labels.push_back(&&RomLine3258);
        main_exec_generated_fast_labels.push_back(&&RomLine3259);
        main_exec_generated_fast_labels.push_back(&&RomLine3260);
        main_exec_generated_fast_labels.push_back(&&RomLine3261);
        main_exec_generated_fast_labels.push_back(&&RomLine3262);
        main_exec_generated_fast_labels.push_back(&&RomLine3263);
        main_exec_generated_fast_labels.push_back(&&RomLine3264);
        main_exec_generated_fast_labels.push_back(&&RomLine3265);
        main_exec_generated_fast_labels.push_back(&&RomLine3266);
        main_exec_generated_fast_labels.push_back(&&RomLine3267);
        main_exec_generated_fast_labels.push_back(&&RomLine3268);
        main_exec_generated_fast_labels.push_back(&&RomLine3269);
        main_exec_generated_fast_labels.push_back(&&RomLine3270);
        main_exec_generated_fast_labels.push_back(&&RomLine3271);
        main_exec_generated_fast_labels.push_back(&&RomLine3272);
        main_exec_generated_fast_labels.push_back(&&RomLine3273);
        main_exec_generated_fast_labels.push_back(&&RomLine3274);
        main_exec_generated_fast_labels.push_back(&&RomLine3275);
        main_exec_generated_fast_labels.push_back(&&RomLine3276);
        main_exec_generated_fast_labels.push_back(&&RomLine3277);
        main_exec_generated_fast_labels.push_back(&&RomLine3278);
        main_exec_generated_fast_labels.push_back(&&RomLine3279);
        main_exec_generated_fast_labels.push_back(&&RomLine3280);
        main_exec_generated_fast_labels.push_back(&&RomLine3281);
        main_exec_generated_fast_labels.push_back(&&RomLine3282);
        main_exec_generated_fast_labels.push_back(&&RomLine3283);
        main_exec_generated_fast_labels.push_back(&&RomLine3284);
        main_exec_generated_fast_labels.push_back(&&RomLine3285);
        main_exec_generated_fast_labels.push_back(&&RomLine3286);
        main_exec_generated_fast_labels.push_back(&&RomLine3287);
        main_exec_generated_fast_labels.push_back(&&RomLine3288);
        main_exec_generated_fast_labels.push_back(&&RomLine3289);
        main_exec_generated_fast_labels.push_back(&&RomLine3290);
        main_exec_generated_fast_labels.push_back(&&RomLine3291);
        main_exec_generated_fast_labels.push_back(&&RomLine3292);
        main_exec_generated_fast_labels.push_back(&&RomLine3293);
        main_exec_generated_fast_labels.push_back(&&RomLine3294);
        main_exec_generated_fast_labels.push_back(&&RomLine3295);
        main_exec_generated_fast_labels.push_back(&&RomLine3296);
        main_exec_generated_fast_labels.push_back(&&RomLine3297);
        main_exec_generated_fast_labels.push_back(&&RomLine3298);
        main_exec_generated_fast_labels.push_back(&&RomLine3299);
        main_exec_generated_fast_labels.push_back(&&RomLine3300);
        main_exec_generated_fast_labels.push_back(&&RomLine3301);
        main_exec_generated_fast_labels.push_back(&&RomLine3302);
        main_exec_generated_fast_labels.push_back(&&RomLine3303);
        main_exec_generated_fast_labels.push_back(&&RomLine3304);
        main_exec_generated_fast_labels.push_back(&&RomLine3305);
        main_exec_generated_fast_labels.push_back(&&RomLine3306);
        main_exec_generated_fast_labels.push_back(&&RomLine3307);
        main_exec_generated_fast_labels.push_back(&&RomLine3308);
        main_exec_generated_fast_labels.push_back(&&RomLine3309);
        main_exec_generated_fast_labels.push_back(&&RomLine3310);
        main_exec_generated_fast_labels.push_back(&&RomLine3311);
        main_exec_generated_fast_labels.push_back(&&RomLine3312);
        main_exec_generated_fast_labels.push_back(&&RomLine3313);
        main_exec_generated_fast_labels.push_back(&&RomLine3314);
        main_exec_generated_fast_labels.push_back(&&RomLine3315);
        main_exec_generated_fast_labels.push_back(&&RomLine3316);
        main_exec_generated_fast_labels.push_back(&&RomLine3317);
        main_exec_generated_fast_labels.push_back(&&RomLine3318);
        main_exec_generated_fast_labels.push_back(&&RomLine3319);
        main_exec_generated_fast_labels.push_back(&&RomLine3320);
        main_exec_generated_fast_labels.push_back(&&RomLine3321);
        main_exec_generated_fast_labels.push_back(&&RomLine3322);
        main_exec_generated_fast_labels.push_back(&&RomLine3323);
        main_exec_generated_fast_labels.push_back(&&RomLine3324);
        main_exec_generated_fast_labels.push_back(&&RomLine3325);
        main_exec_generated_fast_labels.push_back(&&RomLine3326);
        main_exec_generated_fast_labels.push_back(&&RomLine3327);
        main_exec_generated_fast_labels.push_back(&&RomLine3328);
        main_exec_generated_fast_labels.push_back(&&RomLine3329);
        main_exec_generated_fast_labels.push_back(&&RomLine3330);
        main_exec_generated_fast_labels.push_back(&&RomLine3331);
        main_exec_generated_fast_labels.push_back(&&RomLine3332);
        main_exec_generated_fast_labels.push_back(&&RomLine3333);
        main_exec_generated_fast_labels.push_back(&&RomLine3334);
        main_exec_generated_fast_labels.push_back(&&RomLine3335);
        main_exec_generated_fast_labels.push_back(&&RomLine3336);
        main_exec_generated_fast_labels.push_back(&&RomLine3337);
        main_exec_generated_fast_labels.push_back(&&RomLine3338);
        main_exec_generated_fast_labels.push_back(&&RomLine3339);
        main_exec_generated_fast_labels.push_back(&&RomLine3340);
        main_exec_generated_fast_labels.push_back(&&RomLine3341);
        main_exec_generated_fast_labels.push_back(&&RomLine3342);
        main_exec_generated_fast_labels.push_back(&&RomLine3343);
        main_exec_generated_fast_labels.push_back(&&RomLine3344);
        main_exec_generated_fast_labels.push_back(&&RomLine3345);
        main_exec_generated_fast_labels.push_back(&&RomLine3346);
        main_exec_generated_fast_labels.push_back(&&RomLine3347);
        main_exec_generated_fast_labels.push_back(&&RomLine3348);
        main_exec_generated_fast_labels.push_back(&&RomLine3349);
        main_exec_generated_fast_labels.push_back(&&RomLine3350);
        main_exec_generated_fast_labels.push_back(&&RomLine3351);
        main_exec_generated_fast_labels.push_back(&&RomLine3352);
        main_exec_generated_fast_labels.push_back(&&RomLine3353);
        main_exec_generated_fast_labels.push_back(&&RomLine3354);
        main_exec_generated_fast_labels.push_back(&&RomLine3355);
        main_exec_generated_fast_labels.push_back(&&RomLine3356);
        main_exec_generated_fast_labels.push_back(&&RomLine3357);
        main_exec_generated_fast_labels.push_back(&&RomLine3358);
        main_exec_generated_fast_labels.push_back(&&RomLine3359);
        main_exec_generated_fast_labels.push_back(&&RomLine3360);
        main_exec_generated_fast_labels.push_back(&&RomLine3361);
        main_exec_generated_fast_labels.push_back(&&RomLine3362);
        main_exec_generated_fast_labels.push_back(&&RomLine3363);
        main_exec_generated_fast_labels.push_back(&&RomLine3364);
        main_exec_generated_fast_labels.push_back(&&RomLine3365);
        main_exec_generated_fast_labels.push_back(&&RomLine3366);
        main_exec_generated_fast_labels.push_back(&&RomLine3367);
        main_exec_generated_fast_labels.push_back(&&RomLine3368);
        main_exec_generated_fast_labels.push_back(&&RomLine3369);
        main_exec_generated_fast_labels.push_back(&&RomLine3370);
        main_exec_generated_fast_labels.push_back(&&RomLine3371);
        main_exec_generated_fast_labels.push_back(&&RomLine3372);
        main_exec_generated_fast_labels.push_back(&&RomLine3373);
        main_exec_generated_fast_labels.push_back(&&RomLine3374);
        main_exec_generated_fast_labels.push_back(&&RomLine3375);
        main_exec_generated_fast_labels.push_back(&&RomLine3376);
        main_exec_generated_fast_labels.push_back(&&RomLine3377);
        main_exec_generated_fast_labels.push_back(&&RomLine3378);
        main_exec_generated_fast_labels.push_back(&&RomLine3379);
        main_exec_generated_fast_labels.push_back(&&RomLine3380);
        main_exec_generated_fast_labels.push_back(&&RomLine3381);
        main_exec_generated_fast_labels.push_back(&&RomLine3382);
        main_exec_generated_fast_labels.push_back(&&RomLine3383);
        main_exec_generated_fast_labels.push_back(&&RomLine3384);
        main_exec_generated_fast_labels.push_back(&&RomLine3385);
        main_exec_generated_fast_labels.push_back(&&RomLine3386);
        main_exec_generated_fast_labels.push_back(&&RomLine3387);
        main_exec_generated_fast_labels.push_back(&&RomLine3388);
        main_exec_generated_fast_labels.push_back(&&RomLine3389);
        main_exec_generated_fast_labels.push_back(&&RomLine3390);
        main_exec_generated_fast_labels.push_back(&&RomLine3391);
        main_exec_generated_fast_labels.push_back(&&RomLine3392);
        main_exec_generated_fast_labels.push_back(&&RomLine3393);
        main_exec_generated_fast_labels.push_back(&&RomLine3394);
        main_exec_generated_fast_labels.push_back(&&RomLine3395);
        main_exec_generated_fast_labels.push_back(&&RomLine3396);
        main_exec_generated_fast_labels.push_back(&&RomLine3397);
        main_exec_generated_fast_labels.push_back(&&RomLine3398);
        main_exec_generated_fast_labels.push_back(&&RomLine3399);
        main_exec_generated_fast_labels.push_back(&&RomLine3400);
        main_exec_generated_fast_labels.push_back(&&RomLine3401);
        main_exec_generated_fast_labels.push_back(&&RomLine3402);
        main_exec_generated_fast_labels.push_back(&&RomLine3403);
        main_exec_generated_fast_labels.push_back(&&RomLine3404);
        main_exec_generated_fast_labels.push_back(&&RomLine3405);
        main_exec_generated_fast_labels.push_back(&&RomLine3406);
        main_exec_generated_fast_labels.push_back(&&RomLine3407);
        main_exec_generated_fast_labels.push_back(&&RomLine3408);
        main_exec_generated_fast_labels.push_back(&&RomLine3409);
        main_exec_generated_fast_labels.push_back(&&RomLine3410);
        main_exec_generated_fast_labels.push_back(&&RomLine3411);
        main_exec_generated_fast_labels.push_back(&&RomLine3412);
        main_exec_generated_fast_labels.push_back(&&RomLine3413);
        main_exec_generated_fast_labels.push_back(&&RomLine3414);
        main_exec_generated_fast_labels.push_back(&&RomLine3415);
        main_exec_generated_fast_labels.push_back(&&RomLine3416);
        main_exec_generated_fast_labels.push_back(&&RomLine3417);
        main_exec_generated_fast_labels.push_back(&&RomLine3418);
        main_exec_generated_fast_labels.push_back(&&RomLine3419);
        main_exec_generated_fast_labels.push_back(&&RomLine3420);
        main_exec_generated_fast_labels.push_back(&&RomLine3421);
        main_exec_generated_fast_labels.push_back(&&RomLine3422);
        main_exec_generated_fast_labels.push_back(&&RomLine3423);
        main_exec_generated_fast_labels.push_back(&&RomLine3424);
        main_exec_generated_fast_labels.push_back(&&RomLine3425);
        main_exec_generated_fast_labels.push_back(&&RomLine3426);
        main_exec_generated_fast_labels.push_back(&&RomLine3427);
        main_exec_generated_fast_labels.push_back(&&RomLine3428);
        main_exec_generated_fast_labels.push_back(&&RomLine3429);
        main_exec_generated_fast_labels.push_back(&&RomLine3430);
        main_exec_generated_fast_labels.push_back(&&RomLine3431);
        main_exec_generated_fast_labels.push_back(&&RomLine3432);
        main_exec_generated_fast_labels.push_back(&&RomLine3433);
        main_exec_generated_fast_labels.push_back(&&RomLine3434);
        main_exec_generated_fast_labels.push_back(&&RomLine3435);
        main_exec_generated_fast_labels.push_back(&&RomLine3436);
        main_exec_generated_fast_labels.push_back(&&RomLine3437);
        main_exec_generated_fast_labels.push_back(&&RomLine3438);
        main_exec_generated_fast_labels.push_back(&&RomLine3439);
        main_exec_generated_fast_labels.push_back(&&RomLine3440);
        main_exec_generated_fast_labels.push_back(&&RomLine3441);
        main_exec_generated_fast_labels.push_back(&&RomLine3442);
        main_exec_generated_fast_labels.push_back(&&RomLine3443);
        main_exec_generated_fast_labels.push_back(&&RomLine3444);
        main_exec_generated_fast_labels.push_back(&&RomLine3445);
        main_exec_generated_fast_labels.push_back(&&RomLine3446);
        main_exec_generated_fast_labels.push_back(&&RomLine3447);
        main_exec_generated_fast_labels.push_back(&&RomLine3448);
        main_exec_generated_fast_labels.push_back(&&RomLine3449);
        main_exec_generated_fast_labels.push_back(&&RomLine3450);
        main_exec_generated_fast_labels.push_back(&&RomLine3451);
        main_exec_generated_fast_labels.push_back(&&RomLine3452);
        main_exec_generated_fast_labels.push_back(&&RomLine3453);
        main_exec_generated_fast_labels.push_back(&&RomLine3454);
        main_exec_generated_fast_labels.push_back(&&RomLine3455);
        main_exec_generated_fast_labels.push_back(&&RomLine3456);
        main_exec_generated_fast_labels.push_back(&&RomLine3457);
        main_exec_generated_fast_labels.push_back(&&RomLine3458);
        main_exec_generated_fast_labels.push_back(&&RomLine3459);
        main_exec_generated_fast_labels.push_back(&&RomLine3460);
        main_exec_generated_fast_labels.push_back(&&RomLine3461);
        main_exec_generated_fast_labels.push_back(&&RomLine3462);
        main_exec_generated_fast_labels.push_back(&&RomLine3463);
        main_exec_generated_fast_labels.push_back(&&RomLine3464);
        main_exec_generated_fast_labels.push_back(&&RomLine3465);
        main_exec_generated_fast_labels.push_back(&&RomLine3466);
        main_exec_generated_fast_labels.push_back(&&RomLine3467);
        main_exec_generated_fast_labels.push_back(&&RomLine3468);
        main_exec_generated_fast_labels.push_back(&&RomLine3469);
        main_exec_generated_fast_labels.push_back(&&RomLine3470);
        main_exec_generated_fast_labels.push_back(&&RomLine3471);
        main_exec_generated_fast_labels.push_back(&&RomLine3472);
        main_exec_generated_fast_labels.push_back(&&RomLine3473);
        main_exec_generated_fast_labels.push_back(&&RomLine3474);
        main_exec_generated_fast_labels.push_back(&&RomLine3475);
        main_exec_generated_fast_labels.push_back(&&RomLine3476);
        main_exec_generated_fast_labels.push_back(&&RomLine3477);
        main_exec_generated_fast_labels.push_back(&&RomLine3478);
        main_exec_generated_fast_labels.push_back(&&RomLine3479);
        main_exec_generated_fast_labels.push_back(&&RomLine3480);
        main_exec_generated_fast_labels.push_back(&&RomLine3481);
        main_exec_generated_fast_labels.push_back(&&RomLine3482);
        main_exec_generated_fast_labels.push_back(&&RomLine3483);
        main_exec_generated_fast_labels.push_back(&&RomLine3484);
        main_exec_generated_fast_labels.push_back(&&RomLine3485);
        main_exec_generated_fast_labels.push_back(&&RomLine3486);
        main_exec_generated_fast_labels.push_back(&&RomLine3487);
        main_exec_generated_fast_labels.push_back(&&RomLine3488);
        main_exec_generated_fast_labels.push_back(&&RomLine3489);
        main_exec_generated_fast_labels.push_back(&&RomLine3490);
        main_exec_generated_fast_labels.push_back(&&RomLine3491);
        main_exec_generated_fast_labels.push_back(&&RomLine3492);
        main_exec_generated_fast_labels.push_back(&&RomLine3493);
        main_exec_generated_fast_labels.push_back(&&RomLine3494);
        main_exec_generated_fast_labels.push_back(&&RomLine3495);
        main_exec_generated_fast_labels.push_back(&&RomLine3496);
        main_exec_generated_fast_labels.push_back(&&RomLine3497);
        main_exec_generated_fast_labels.push_back(&&RomLine3498);
        main_exec_generated_fast_labels.push_back(&&RomLine3499);
        main_exec_generated_fast_labels.push_back(&&RomLine3500);
        main_exec_generated_fast_labels.push_back(&&RomLine3501);
        main_exec_generated_fast_labels.push_back(&&RomLine3502);
        main_exec_generated_fast_labels.push_back(&&RomLine3503);
        main_exec_generated_fast_labels.push_back(&&RomLine3504);
        main_exec_generated_fast_labels.push_back(&&RomLine3505);
        main_exec_generated_fast_labels.push_back(&&RomLine3506);
        main_exec_generated_fast_labels.push_back(&&RomLine3507);
        main_exec_generated_fast_labels.push_back(&&RomLine3508);
        main_exec_generated_fast_labels.push_back(&&RomLine3509);
        main_exec_generated_fast_labels.push_back(&&RomLine3510);
        main_exec_generated_fast_labels.push_back(&&RomLine3511);
        main_exec_generated_fast_labels.push_back(&&RomLine3512);
        main_exec_generated_fast_labels.push_back(&&RomLine3513);
        main_exec_generated_fast_labels.push_back(&&RomLine3514);
        main_exec_generated_fast_labels.push_back(&&RomLine3515);
        main_exec_generated_fast_labels.push_back(&&RomLine3516);
        main_exec_generated_fast_labels.push_back(&&RomLine3517);
        main_exec_generated_fast_labels.push_back(&&RomLine3518);
        main_exec_generated_fast_labels.push_back(&&RomLine3519);
        main_exec_generated_fast_labels.push_back(&&RomLine3520);
        main_exec_generated_fast_labels.push_back(&&RomLine3521);
        main_exec_generated_fast_labels.push_back(&&RomLine3522);
        main_exec_generated_fast_labels.push_back(&&RomLine3523);
        main_exec_generated_fast_labels.push_back(&&RomLine3524);
        main_exec_generated_fast_labels.push_back(&&RomLine3525);
        main_exec_generated_fast_labels.push_back(&&RomLine3526);
        main_exec_generated_fast_labels.push_back(&&RomLine3527);
        main_exec_generated_fast_labels.push_back(&&RomLine3528);
        main_exec_generated_fast_labels.push_back(&&RomLine3529);
        main_exec_generated_fast_labels.push_back(&&RomLine3530);
        main_exec_generated_fast_labels.push_back(&&RomLine3531);
        main_exec_generated_fast_labels.push_back(&&RomLine3532);
        main_exec_generated_fast_labels.push_back(&&RomLine3533);
        main_exec_generated_fast_labels.push_back(&&RomLine3534);
        main_exec_generated_fast_labels.push_back(&&RomLine3535);
        main_exec_generated_fast_labels.push_back(&&RomLine3536);
        main_exec_generated_fast_labels.push_back(&&RomLine3537);
        main_exec_generated_fast_labels.push_back(&&RomLine3538);
        main_exec_generated_fast_labels.push_back(&&RomLine3539);
        main_exec_generated_fast_labels.push_back(&&RomLine3540);
        main_exec_generated_fast_labels.push_back(&&RomLine3541);
        main_exec_generated_fast_labels.push_back(&&RomLine3542);
        main_exec_generated_fast_labels.push_back(&&RomLine3543);
        main_exec_generated_fast_labels.push_back(&&RomLine3544);
        main_exec_generated_fast_labels.push_back(&&RomLine3545);
        main_exec_generated_fast_labels.push_back(&&RomLine3546);
        main_exec_generated_fast_labels.push_back(&&RomLine3547);
        main_exec_generated_fast_labels.push_back(&&RomLine3548);
        main_exec_generated_fast_labels.push_back(&&RomLine3549);
        main_exec_generated_fast_labels.push_back(&&RomLine3550);
        main_exec_generated_fast_labels.push_back(&&RomLine3551);
        main_exec_generated_fast_labels.push_back(&&RomLine3552);
        main_exec_generated_fast_labels.push_back(&&RomLine3553);
    }

RomLine0:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSTEP*STEP, where inSTEP=1
    op0 = i;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
{
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 2 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
}

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine4:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 4 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine5:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine6:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 6 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine7:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine8:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine9:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine10:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 10 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine11:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 11 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine12:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 12 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine13:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 13 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine14:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(8))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 14 << endl;
        exit(-1);
    }
    addrRel += 8;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine15:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 15 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine16:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 16 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine17:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 17 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine18:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 18 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine19:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine20:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 20 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine21:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 21 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine22:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine23:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 23 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine24:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine25:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine26:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine27:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine28:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine29:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine30:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine31:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 31 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine32:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine33:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine34:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 34 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine35:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 35 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine36:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine37:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 37 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine38:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine39:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine40:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine41:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine42:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine43:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine44:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 44 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine45:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine46:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 46 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine47:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 47 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine48:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 48 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine49:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 49 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine50:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 50 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine51:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 51 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine52:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 52 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine53:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 53 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine54:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 54 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine55:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 55 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine56:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(106))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 56 << endl;
        exit(-1);
    }
    addrRel += 106;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine57:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(58))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 57 << endl;
        exit(-1);
    }
    addrRel += 58;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine58:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(59))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 58 << endl;
        exit(-1);
    }
    addrRel += 59;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine59:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 59 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine60:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 60 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine61:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(67))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 61 << endl;
        exit(-1);
    }
    addrRel += 67;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine62:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 62 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine63:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 63 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine64:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(843))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 64 << endl;
        exit(-1);
    }
    addrRel += 843;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine65:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine66:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(59))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 66 << endl;
        exit(-1);
    }
    addrRel += 59;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine67:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine68:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine69:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine70:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine71:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 71 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
{
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 71 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
}

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine72:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 72 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine73:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 73 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
{
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 73 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
}

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine74:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine75:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 75 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine76:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine77:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 77 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine78:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine79:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine80:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 80 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine81:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine82:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine83:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 83 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine84:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine85:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine86:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(8))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 86 << endl;
        exit(-1);
    }
    addrRel += 8;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine87:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine88:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 88 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine89:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine90:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine91:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 91 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine92:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
{
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 92 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
}

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine93:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 93 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine94:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine95:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine96:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 96 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine97:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine98:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 98 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine99:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine100:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine101:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine102:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
{
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 102 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
}

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine103:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine104:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op
    SP = fe2n(fr, op0); // If setSP, SP'=op
    PC = fe2n(fr, op0); // If setPC, PC'=op
    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine105:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine106:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine107:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 107 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine108:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 108 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine109:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine110:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine111:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 112;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 111 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine112:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 113;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 112 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine113:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(192));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 113 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine114:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(248));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(119))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 114 << endl;
        exit(-1);
    }
    addrRel += 119;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine115:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(247));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine116:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 117;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 116 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine117:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 118;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 117 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine118:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(120))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 118 << endl;
        exit(-1);
    }
    addrRel += 120;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine119:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(192));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine120:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 120 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine121:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine122:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 123;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 122 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine123:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 124;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 123 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine124:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 124 << endl;
        exit(-1);
    }
    addrRel += 135;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine125:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(128))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 125 << endl;
        exit(-1);
    }
    addrRel += 128;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine126:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(137));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(131))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 126 << endl;
        exit(-1);
    }
    addrRel += 131;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine127:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 127 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine128:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 128 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine129:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine130:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 130 << endl;
        exit(-1);
    }
    addrRel += 135;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine131:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine132:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 132 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine133:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 134;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 133 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine134:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 135;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 134 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine135:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 135 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine136:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine137:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 138;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 137 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine138:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 139;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 138 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine139:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(149))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 139 << endl;
        exit(-1);
    }
    addrRel += 149;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine140:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(143))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 140 << endl;
        exit(-1);
    }
    addrRel += 143;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine141:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(161));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(145))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 141 << endl;
        exit(-1);
    }
    addrRel += 145;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine142:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 142 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine143:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine144:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(149))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 144 << endl;
        exit(-1);
    }
    addrRel += 149;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine145:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine146:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(149))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 146 << endl;
        exit(-1);
    }
    addrRel += 149;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine147:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 148;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 147 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine148:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 149;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 148 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine149:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 149 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine150:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine151:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 152;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 151 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine152:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 153;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 152 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine153:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(162))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 153 << endl;
        exit(-1);
    }
    addrRel += 162;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine154:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(157))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 154 << endl;
        exit(-1);
    }
    addrRel += 157;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine155:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(161));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(158))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 155 << endl;
        exit(-1);
    }
    addrRel += 158;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine156:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 156 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine157:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(162))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 157 << endl;
        exit(-1);
    }
    addrRel += 162;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine158:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine159:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(162))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 159 << endl;
        exit(-1);
    }
    addrRel += 162;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine160:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 161;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 160 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine161:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 162;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 161 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine162:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine163:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine164:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 165;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 164 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine165:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 166;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 165 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine166:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 166 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine167:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(171))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 167 << endl;
        exit(-1);
    }
    addrRel += 171;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine168:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(148));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 168 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine169:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(149));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(173))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 169 << endl;
        exit(-1);
    }
    addrRel += 173;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine170:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 170 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine171:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 171 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine172:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(178))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 172 << endl;
        exit(-1);
    }
    addrRel += 178;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine173:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine174:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 175;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 174 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine175:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 176;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 175 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine176:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 176 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine177:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 177 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine178:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine179:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 180;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 179 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine180:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 181;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 180 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine181:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(191))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 181 << endl;
        exit(-1);
    }
    addrRel += 191;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine182:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(185))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 182 << endl;
        exit(-1);
    }
    addrRel += 185;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine183:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(161));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(187))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 183 << endl;
        exit(-1);
    }
    addrRel += 187;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine184:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 184 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine185:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine186:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(191))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 186 << endl;
        exit(-1);
    }
    addrRel += 191;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine187:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine188:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(191))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 188 << endl;
        exit(-1);
    }
    addrRel += 191;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine189:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 190;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 189 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine190:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 191;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 190 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine191:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 191 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine192:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine193:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine194:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 195;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 194 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine195:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 196;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 195 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine196:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(201))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 196 << endl;
        exit(-1);
    }
    addrRel += 201;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine197:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 197 << endl;
        exit(-1);
    }
    addrRel += 227;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine198:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(184));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(206))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 198 << endl;
        exit(-1);
    }
    addrRel += 206;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine199:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(192));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(208))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 199 << endl;
        exit(-1);
    }
    addrRel += 208;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine200:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 200 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine201:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 201 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine202:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 31;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine203:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 204;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 203 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine204:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine205:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 205 << endl;
        exit(-1);
    }
    addrRel += 227;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine206:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 206 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine207:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(212))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 207 << endl;
        exit(-1);
    }
    addrRel += 212;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine208:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(183));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine209:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 210;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 209 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine210:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 211;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 210 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine211:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 211 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine212:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine213:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(220))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 213 << endl;
        exit(-1);
    }
    addrRel += 220;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine214:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 214 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine215:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 216;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 215 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine216:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 217;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 216 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine217:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine218:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 218 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine219:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(212))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 219 << endl;
        exit(-1);
    }
    addrRel += 212;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine220:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 220 << endl;
        exit(-1);
    }
    addrRel += 227;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine221:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine222:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 223;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 222 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine223:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 224;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 223 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine224:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine225:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 226;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 225 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine226:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine227:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine228:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 229;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 228 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine229:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 230;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 229 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine230:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(240))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 230 << endl;
        exit(-1);
    }
    addrRel += 240;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine231:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(129));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(234))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 231 << endl;
        exit(-1);
    }
    addrRel += 234;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine232:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(137));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(236))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 232 << endl;
        exit(-1);
    }
    addrRel += 236;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine233:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 233 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine234:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine235:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(240))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 235 << endl;
        exit(-1);
    }
    addrRel += 240;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine236:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine237:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(240))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 237 << endl;
        exit(-1);
    }
    addrRel += 240;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine238:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 239;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 238 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine239:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 240;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 239 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine240:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(11))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 240 << endl;
        exit(-1);
    }
    addrRel += 11;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine241:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine242:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 243;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(285))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 242 << endl;
        exit(-1);
    }
    addrRel += 285;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine243:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 244;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 243 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine244:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32896;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine245:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(247))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 245 << endl;
        exit(-1);
    }
    addrRel += 247;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine246:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 246 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine247:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine248:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 248 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine249:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 249 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine250:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 250 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine251:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine252:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine253:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 254;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(280))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 253 << endl;
        exit(-1);
    }
    addrRel += 280;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine254:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 254 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine255:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine256:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 257;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 256 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine257:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine258:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 259;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(280))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 258 << endl;
        exit(-1);
    }
    addrRel += 280;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine259:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 259 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine260:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine261:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 262;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 261 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine262:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine263:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 264;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(280))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 263 << endl;
        exit(-1);
    }
    addrRel += 280;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine264:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 264 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine265:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine266:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 267;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(273))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 266 << endl;
        exit(-1);
    }
    addrRel += 273;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine267:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 267 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine268:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 268 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine269:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 269 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine270:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 270 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine271:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 271 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine272:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(52))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 272 << endl;
        exit(-1);
    }
    addrRel += 52;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine273:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 273 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine274:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 274 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine275:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine276:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 276 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine277:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine278:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 278 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine279:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine280:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 280 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine281:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 281 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine282:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 282 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine283:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine284:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine285:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 285 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine286:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 286 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine287:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 287 << endl;
        exit(-1);
    }
    addrRel += 292;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine288:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine289:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine290:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine291:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine292:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 292 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine293:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 293 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine294:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 294 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine295:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(21))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 295 << endl;
        exit(-1);
    }
    addrRel += 21;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine296:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(302))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 296 << endl;
        exit(-1);
    }
    addrRel += 302;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine297:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine298:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine299:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine300:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine301:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(296))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 301 << endl;
        exit(-1);
    }
    addrRel += 296;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine302:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=-1
    op0 = fr.add(op0, fr.neg(C0));
    op1 = fr.add(op1, fr.neg(C1));
    op2 = fr.add(op2, fr.neg(C2));
    op3 = fr.add(op3, fr.neg(C3));
    op4 = fr.add(op4, fr.neg(C4));
    op5 = fr.add(op5, fr.neg(C5));
    op6 = fr.add(op6, fr.neg(C6));
    op7 = fr.add(op7, fr.neg(C7));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine303:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(307))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 303 << endl;
        exit(-1);
    }
    addrRel += 307;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine304:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine305:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine306:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine307:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(22))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 307 << endl;
        exit(-1);
    }
    addrRel += 22;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine308:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(67))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 308 << endl;
        exit(-1);
    }
    addrRel += 67;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine309:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1594))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 309 << endl;
        exit(-1);
    }
    addrRel += 1594;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine310:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1607))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 310 << endl;
        exit(-1);
    }
    addrRel += 1607;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine311:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1619))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 311 << endl;
        exit(-1);
    }
    addrRel += 1619;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine312:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1631))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 312 << endl;
        exit(-1);
    }
    addrRel += 1631;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine313:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1643))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 313 << endl;
        exit(-1);
    }
    addrRel += 1643;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine314:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1655))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 314 << endl;
        exit(-1);
    }
    addrRel += 1655;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine315:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1688))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 315 << endl;
        exit(-1);
    }
    addrRel += 1688;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine316:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1700))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 316 << endl;
        exit(-1);
    }
    addrRel += 1700;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine317:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1733))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 317 << endl;
        exit(-1);
    }
    addrRel += 1733;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine318:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1750))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 318 << endl;
        exit(-1);
    }
    addrRel += 1750;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine319:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1767))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 319 << endl;
        exit(-1);
    }
    addrRel += 1767;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine320:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1777))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 320 << endl;
        exit(-1);
    }
    addrRel += 1777;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine321:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 321 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine322:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 322 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine323:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 323 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine324:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 324 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine325:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1822))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 325 << endl;
        exit(-1);
    }
    addrRel += 1822;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine326:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1838))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 326 << endl;
        exit(-1);
    }
    addrRel += 1838;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine327:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1814))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 327 << endl;
        exit(-1);
    }
    addrRel += 1814;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine328:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1830))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 328 << endl;
        exit(-1);
    }
    addrRel += 1830;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine329:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1846))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 329 << endl;
        exit(-1);
    }
    addrRel += 1846;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine330:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1854))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 330 << endl;
        exit(-1);
    }
    addrRel += 1854;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine331:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1861))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 331 << endl;
        exit(-1);
    }
    addrRel += 1861;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine332:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1869))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 332 << endl;
        exit(-1);
    }
    addrRel += 1869;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine333:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1877))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 333 << endl;
        exit(-1);
    }
    addrRel += 1877;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine334:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1885))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 334 << endl;
        exit(-1);
    }
    addrRel += 1885;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine335:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1892))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 335 << endl;
        exit(-1);
    }
    addrRel += 1892;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine336:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1912))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 336 << endl;
        exit(-1);
    }
    addrRel += 1912;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine337:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1903))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 337 << endl;
        exit(-1);
    }
    addrRel += 1903;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine338:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1921))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 338 << endl;
        exit(-1);
    }
    addrRel += 1921;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine339:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 339 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine340:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 340 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine341:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1953))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 341 << endl;
        exit(-1);
    }
    addrRel += 1953;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine342:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 342 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine343:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 343 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine344:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 344 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine345:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 345 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine346:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 346 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine347:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 347 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine348:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 348 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine349:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 349 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine350:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 350 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine351:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 351 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine352:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 352 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine353:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 353 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine354:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 354 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine355:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 355 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine356:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 356 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine357:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1997))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 357 << endl;
        exit(-1);
    }
    addrRel += 1997;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine358:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2006))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 358 << endl;
        exit(-1);
    }
    addrRel += 2006;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine359:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2015))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 359 << endl;
        exit(-1);
    }
    addrRel += 2015;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine360:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2020))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 360 << endl;
        exit(-1);
    }
    addrRel += 2020;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine361:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2025))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 361 << endl;
        exit(-1);
    }
    addrRel += 2025;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine362:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2030))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 362 << endl;
        exit(-1);
    }
    addrRel += 2030;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine363:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2060))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 363 << endl;
        exit(-1);
    }
    addrRel += 2060;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine364:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2065))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 364 << endl;
        exit(-1);
    }
    addrRel += 2065;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine365:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2128))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 365 << endl;
        exit(-1);
    }
    addrRel += 2128;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine366:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2144))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 366 << endl;
        exit(-1);
    }
    addrRel += 2144;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine367:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2175))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 367 << endl;
        exit(-1);
    }
    addrRel += 2175;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine368:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2180))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 368 << endl;
        exit(-1);
    }
    addrRel += 2180;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine369:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2191))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 369 << endl;
        exit(-1);
    }
    addrRel += 2191;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine370:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2221))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 370 << endl;
        exit(-1);
    }
    addrRel += 2221;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine371:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2226))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 371 << endl;
        exit(-1);
    }
    addrRel += 2226;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine372:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2266))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 372 << endl;
        exit(-1);
    }
    addrRel += 2266;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine373:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2292))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 373 << endl;
        exit(-1);
    }
    addrRel += 2292;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine374:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2314))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 374 << endl;
        exit(-1);
    }
    addrRel += 2314;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine375:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2319))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 375 << endl;
        exit(-1);
    }
    addrRel += 2319;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine376:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2324))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 376 << endl;
        exit(-1);
    }
    addrRel += 2324;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine377:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2329))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 377 << endl;
        exit(-1);
    }
    addrRel += 2329;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine378:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2334))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 378 << endl;
        exit(-1);
    }
    addrRel += 2334;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine379:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2339))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 379 << endl;
        exit(-1);
    }
    addrRel += 2339;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine380:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2344))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 380 << endl;
        exit(-1);
    }
    addrRel += 2344;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine381:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 381 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine382:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 382 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine383:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 383 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine384:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 384 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine385:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 385 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine386:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 386 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine387:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 387 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine388:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 388 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine389:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2351))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 389 << endl;
        exit(-1);
    }
    addrRel += 2351;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine390:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2354))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 390 << endl;
        exit(-1);
    }
    addrRel += 2354;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine391:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2363))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 391 << endl;
        exit(-1);
    }
    addrRel += 2363;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine392:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2375))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 392 << endl;
        exit(-1);
    }
    addrRel += 2375;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine393:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2388))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 393 << endl;
        exit(-1);
    }
    addrRel += 2388;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine394:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2398))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 394 << endl;
        exit(-1);
    }
    addrRel += 2398;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine395:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2485))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 395 << endl;
        exit(-1);
    }
    addrRel += 2485;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine396:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2490))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 396 << endl;
        exit(-1);
    }
    addrRel += 2490;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine397:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2500))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 397 << endl;
        exit(-1);
    }
    addrRel += 2500;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine398:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2504))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 398 << endl;
        exit(-1);
    }
    addrRel += 2504;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine399:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2509))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 399 << endl;
        exit(-1);
    }
    addrRel += 2509;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine400:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2513))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 400 << endl;
        exit(-1);
    }
    addrRel += 2513;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine401:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 401 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine402:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 402 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine403:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 403 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine404:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 404 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine405:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2553))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 405 << endl;
        exit(-1);
    }
    addrRel += 2553;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine406:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2557))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 406 << endl;
        exit(-1);
    }
    addrRel += 2557;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine407:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2561))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 407 << endl;
        exit(-1);
    }
    addrRel += 2561;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine408:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2565))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 408 << endl;
        exit(-1);
    }
    addrRel += 2565;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine409:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2569))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 409 << endl;
        exit(-1);
    }
    addrRel += 2569;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine410:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2573))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 410 << endl;
        exit(-1);
    }
    addrRel += 2573;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine411:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2577))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 411 << endl;
        exit(-1);
    }
    addrRel += 2577;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine412:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2581))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 412 << endl;
        exit(-1);
    }
    addrRel += 2581;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine413:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2585))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 413 << endl;
        exit(-1);
    }
    addrRel += 2585;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine414:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2589))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 414 << endl;
        exit(-1);
    }
    addrRel += 2589;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine415:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2593))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 415 << endl;
        exit(-1);
    }
    addrRel += 2593;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine416:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2597))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 416 << endl;
        exit(-1);
    }
    addrRel += 2597;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine417:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2601))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 417 << endl;
        exit(-1);
    }
    addrRel += 2601;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine418:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2605))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 418 << endl;
        exit(-1);
    }
    addrRel += 2605;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine419:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2609))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 419 << endl;
        exit(-1);
    }
    addrRel += 2609;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine420:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2613))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 420 << endl;
        exit(-1);
    }
    addrRel += 2613;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine421:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2617))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 421 << endl;
        exit(-1);
    }
    addrRel += 2617;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine422:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2621))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 422 << endl;
        exit(-1);
    }
    addrRel += 2621;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine423:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2625))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 423 << endl;
        exit(-1);
    }
    addrRel += 2625;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine424:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2629))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 424 << endl;
        exit(-1);
    }
    addrRel += 2629;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine425:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2633))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 425 << endl;
        exit(-1);
    }
    addrRel += 2633;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine426:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2637))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 426 << endl;
        exit(-1);
    }
    addrRel += 2637;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine427:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2641))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 427 << endl;
        exit(-1);
    }
    addrRel += 2641;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine428:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2645))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 428 << endl;
        exit(-1);
    }
    addrRel += 2645;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine429:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2649))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 429 << endl;
        exit(-1);
    }
    addrRel += 2649;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine430:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2653))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 430 << endl;
        exit(-1);
    }
    addrRel += 2653;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine431:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2657))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 431 << endl;
        exit(-1);
    }
    addrRel += 2657;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine432:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2661))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 432 << endl;
        exit(-1);
    }
    addrRel += 2661;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine433:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2665))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 433 << endl;
        exit(-1);
    }
    addrRel += 2665;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine434:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2669))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 434 << endl;
        exit(-1);
    }
    addrRel += 2669;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine435:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2673))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 435 << endl;
        exit(-1);
    }
    addrRel += 2673;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine436:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2677))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 436 << endl;
        exit(-1);
    }
    addrRel += 2677;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine437:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2681))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 437 << endl;
        exit(-1);
    }
    addrRel += 2681;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine438:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2688))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 438 << endl;
        exit(-1);
    }
    addrRel += 2688;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine439:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2695))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 439 << endl;
        exit(-1);
    }
    addrRel += 2695;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine440:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2702))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 440 << endl;
        exit(-1);
    }
    addrRel += 2702;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine441:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2709))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 441 << endl;
        exit(-1);
    }
    addrRel += 2709;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine442:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2716))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 442 << endl;
        exit(-1);
    }
    addrRel += 2716;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine443:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2723))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 443 << endl;
        exit(-1);
    }
    addrRel += 2723;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine444:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2730))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 444 << endl;
        exit(-1);
    }
    addrRel += 2730;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine445:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2737))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 445 << endl;
        exit(-1);
    }
    addrRel += 2737;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine446:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2744))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 446 << endl;
        exit(-1);
    }
    addrRel += 2744;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine447:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2751))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 447 << endl;
        exit(-1);
    }
    addrRel += 2751;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine448:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2758))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 448 << endl;
        exit(-1);
    }
    addrRel += 2758;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine449:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2765))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 449 << endl;
        exit(-1);
    }
    addrRel += 2765;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine450:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2772))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 450 << endl;
        exit(-1);
    }
    addrRel += 2772;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine451:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2779))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 451 << endl;
        exit(-1);
    }
    addrRel += 2779;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine452:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2786))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 452 << endl;
        exit(-1);
    }
    addrRel += 2786;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine453:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2793))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 453 << endl;
        exit(-1);
    }
    addrRel += 2793;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine454:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2803))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 454 << endl;
        exit(-1);
    }
    addrRel += 2803;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine455:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2814))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 455 << endl;
        exit(-1);
    }
    addrRel += 2814;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine456:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2825))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 456 << endl;
        exit(-1);
    }
    addrRel += 2825;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine457:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2836))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 457 << endl;
        exit(-1);
    }
    addrRel += 2836;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine458:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2847))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 458 << endl;
        exit(-1);
    }
    addrRel += 2847;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine459:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2858))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 459 << endl;
        exit(-1);
    }
    addrRel += 2858;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine460:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2869))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 460 << endl;
        exit(-1);
    }
    addrRel += 2869;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine461:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2880))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 461 << endl;
        exit(-1);
    }
    addrRel += 2880;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine462:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2891))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 462 << endl;
        exit(-1);
    }
    addrRel += 2891;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine463:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2902))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 463 << endl;
        exit(-1);
    }
    addrRel += 2902;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine464:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2913))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 464 << endl;
        exit(-1);
    }
    addrRel += 2913;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine465:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2924))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 465 << endl;
        exit(-1);
    }
    addrRel += 2924;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine466:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2935))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 466 << endl;
        exit(-1);
    }
    addrRel += 2935;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine467:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2946))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 467 << endl;
        exit(-1);
    }
    addrRel += 2946;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine468:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2957))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 468 << endl;
        exit(-1);
    }
    addrRel += 2957;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine469:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2968))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 469 << endl;
        exit(-1);
    }
    addrRel += 2968;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine470:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2981))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 470 << endl;
        exit(-1);
    }
    addrRel += 2981;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine471:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2994))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 471 << endl;
        exit(-1);
    }
    addrRel += 2994;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine472:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3007))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 472 << endl;
        exit(-1);
    }
    addrRel += 3007;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine473:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3020))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 473 << endl;
        exit(-1);
    }
    addrRel += 3020;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine474:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 474 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine475:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 475 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine476:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 476 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine477:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 477 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine478:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 478 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine479:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 479 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine480:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 480 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine481:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 481 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine482:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 482 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine483:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 483 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine484:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 484 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine485:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 485 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine486:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 486 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine487:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 487 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine488:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 488 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine489:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 489 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine490:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 490 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine491:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 491 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine492:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 492 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine493:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 493 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine494:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 494 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine495:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 495 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine496:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 496 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine497:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 497 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine498:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 498 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine499:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 499 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine500:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 500 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine501:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 501 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine502:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 502 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine503:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 503 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine504:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 504 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine505:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 505 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine506:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 506 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine507:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 507 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine508:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 508 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine509:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 509 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine510:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 510 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine511:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 511 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine512:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 512 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine513:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 513 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine514:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 514 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine515:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 515 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine516:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 516 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine517:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 517 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine518:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 518 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine519:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 519 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine520:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 520 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine521:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 521 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine522:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 522 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine523:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 523 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine524:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 524 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine525:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 525 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine526:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 526 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine527:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 527 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine528:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 528 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine529:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 529 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine530:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 530 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine531:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 531 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine532:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 532 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine533:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 533 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine534:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 534 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine535:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 535 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine536:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 536 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine537:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 537 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine538:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 538 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine539:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 539 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine540:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 540 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine541:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 541 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine542:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 542 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine543:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 543 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine544:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 544 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine545:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 545 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine546:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 546 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine547:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 547 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine548:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 548 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine549:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 549 << endl;
        exit(-1);
    }
    addrRel += 3053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine550:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3102))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 550 << endl;
        exit(-1);
    }
    addrRel += 3102;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine551:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3165))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 551 << endl;
        exit(-1);
    }
    addrRel += 3165;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine552:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3226))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 552 << endl;
        exit(-1);
    }
    addrRel += 3226;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine553:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3329))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 553 << endl;
        exit(-1);
    }
    addrRel += 3329;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine554:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3385))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 554 << endl;
        exit(-1);
    }
    addrRel += 3385;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine555:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 555 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine556:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 556 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine557:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 557 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine558:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 558 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine559:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3437))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 559 << endl;
        exit(-1);
    }
    addrRel += 3437;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine560:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 560 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine561:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 561 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine562:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3492))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 562 << endl;
        exit(-1);
    }
    addrRel += 3492;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine563:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 563 << endl;
        exit(-1);
    }
    addrRel += 3538;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine564:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3508))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 564 << endl;
        exit(-1);
    }
    addrRel += 3508;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine565:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 565 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine566:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine567:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine568:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine569:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 27;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine570:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(587))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 570 << endl;
        exit(-1);
    }
    addrRel += 587;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine571:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine572:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 28;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine573:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(587))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 573 << endl;
        exit(-1);
    }
    addrRel += 587;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine574:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine575:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine576:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine577:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine578:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine579:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine580:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine581:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(587))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 581 << endl;
        exit(-1);
    }
    addrRel += 587;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine582:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 582 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine583:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 583 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine584:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 584 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine585:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 586;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 585 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine586:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 586 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine587:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 587 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine588:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 588 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine589:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 589 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine590:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(60));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 590 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine591:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 591 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine592:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine593:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(603))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 593 << endl;
        exit(-1);
    }
    addrRel += 603;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine594:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(599))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 594 << endl;
        exit(-1);
    }
    addrRel += 599;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine595:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine596:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine597:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine598:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(593))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 598 << endl;
        exit(-1);
    }
    addrRel += 593;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine599:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine600:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine601:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 602;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 601 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine602:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine603:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine604:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine605:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 605 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine606:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 606 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine607:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 607 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine608:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 609;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 608 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine609:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 609 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine610:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 610 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine611:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(600));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 611 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine612:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 612 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine613:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine614:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(624))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 614 << endl;
        exit(-1);
    }
    addrRel += 624;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine615:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(620))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 615 << endl;
        exit(-1);
    }
    addrRel += 620;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine616:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine617:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine618:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine619:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(614))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 619 << endl;
        exit(-1);
    }
    addrRel += 614;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine620:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine621:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine622:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 623;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 622 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine623:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine624:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine625:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine626:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 626 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine627:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 627 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine628:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 628 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine629:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 630;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 629 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine630:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 630 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine631:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 631 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine632:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 632 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine633:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine634:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-3
    op0 = fr.mul(-3, A0);
    op1 = fr.mul(-3, A1);
    op2 = fr.mul(-3, A2);
    op3 = fr.mul(-3, A3);
    op4 = fr.mul(-3, A4);
    op5 = fr.mul(-3, A5);
    op6 = fr.mul(-3, A6);
    op7 = fr.mul(-3, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 634 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine635:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 635 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine636:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 636 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine637:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 637 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine638:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 638 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine639:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 639 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine640:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(650))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 640 << endl;
        exit(-1);
    }
    addrRel += 650;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine641:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 642;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 641 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine642:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine643:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine644:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 644 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine645:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 646;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 645 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine646:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine647:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine648:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine649:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(639))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 649 << endl;
        exit(-1);
    }
    addrRel += 639;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine650:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 651;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 650 << endl;
        exit(-1);
    }
    addrRel += 1340;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine651:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine652:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 652 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine653:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 654;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 653 << endl;
        exit(-1);
    }
    addrRel += 1262;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine654:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 654 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine655:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 655 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine656:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 656 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine657:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 657 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine658:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 658 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine659:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 660;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 659 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine660:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 660 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine661:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 662;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 661 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine662:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 662 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine663:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 664;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 663 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine664:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 664 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine665:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 665 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine666:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 667;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 666 << endl;
        exit(-1);
    }
    addrRel += 1340;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine667:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine668:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 668 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine669:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 670;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 669 << endl;
        exit(-1);
    }
    addrRel += 1340;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine670:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 670 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine671:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine672:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 672 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine673:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 674;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 673 << endl;
        exit(-1);
    }
    addrRel += 1340;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine674:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine675:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine676:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine677:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 677 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine678:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 678 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine679:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine680:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 681;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 680 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine681:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 681 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine682:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(685))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 682 << endl;
        exit(-1);
    }
    addrRel += 685;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine683:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 684;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 683 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine684:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(686))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 684 << endl;
        exit(-1);
    }
    addrRel += 686;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine685:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 686;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 685 << endl;
        exit(-1);
    }
    addrRel += 1262;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine686:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 686 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine687:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 687 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine688:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine689:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(691))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 689 << endl;
        exit(-1);
    }
    addrRel += 691;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine690:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine691:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine692:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine693:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine694:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 694 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine695:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 695 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine696:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 696 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine697:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(699))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 697 << endl;
        exit(-1);
    }
    addrRel += 699;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine698:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(702))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 698 << endl;
        exit(-1);
    }
    addrRel += 702;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine699:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine700:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(702))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 700 << endl;
        exit(-1);
    }
    addrRel += 702;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine701:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=8
    op0 = fr.mul(8, C0);
    op1 = fr.mul(8, C1);
    op2 = fr.mul(8, C2);
    op3 = fr.mul(8, C3);
    op4 = fr.mul(8, C4);
    op5 = fr.mul(8, C5);
    op6 = fr.mul(8, C6);
    op7 = fr.mul(8, C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine702:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine703:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine704:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine705:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(707))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 705 << endl;
        exit(-1);
    }
    addrRel += 707;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine706:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine707:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 707 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine708:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine709:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 200;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine710:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine711:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(713))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 711 << endl;
        exit(-1);
    }
    addrRel += 713;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine712:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 200;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine713:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 713 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine714:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 714 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine715:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 715 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine716:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 716 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine717:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 128;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine718:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine719:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(742))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 719 << endl;
        exit(-1);
    }
    addrRel += 742;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine720:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 720 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine721:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 64;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine722:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine723:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(742))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 723 << endl;
        exit(-1);
    }
    addrRel += 742;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine724:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 724 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine725:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 726;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 725 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine726:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine727:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 728;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 727 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine728:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine729:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 730;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 729 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine730:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine731:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 732;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 731 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine732:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 732 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine733:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine734:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine735:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 735 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine736:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 737;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 736 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine737:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine738:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 738 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine739:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 740;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 739 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine740:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(150));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 740 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine741:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 741 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine742:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(827))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 742 << endl;
        exit(-1);
    }
    addrRel += 827;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine743:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 743 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine744:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 744 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine745:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 96;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine746:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine747:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(768))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 747 << endl;
        exit(-1);
    }
    addrRel += 768;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine748:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 748 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine749:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 64;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine750:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine751:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(768))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 751 << endl;
        exit(-1);
    }
    addrRel += 768;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine752:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 752 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine753:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 754;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 753 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine754:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine755:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 756;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 755 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine756:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine757:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 758;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 757 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine758:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 758 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine759:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine760:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine761:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 761 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine762:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 763;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 762 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine763:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine764:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 764 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine765:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 766;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 765 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine766:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 766 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine767:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 767 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine768:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(827))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 768 << endl;
        exit(-1);
    }
    addrRel += 827;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine769:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 769 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine770:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 770 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine771:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine772:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine773:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine774:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(789))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 774 << endl;
        exit(-1);
    }
    addrRel += 789;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine775:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 775 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine776:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(781))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 776 << endl;
        exit(-1);
    }
    addrRel += 781;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine777:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 778;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 777 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine778:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine779:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine780:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(776))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 780 << endl;
        exit(-1);
    }
    addrRel += 776;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine781:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine782:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 782 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine783:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 783 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine784:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 785;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 784 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine785:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 785 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine786:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine787:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-34000
    op0 = fr.mul(-34000, A0);
    op1 = fr.mul(-34000, A1);
    op2 = fr.mul(-34000, A2);
    op3 = fr.mul(-34000, A3);
    op4 = fr.mul(-34000, A4);
    op5 = fr.mul(-34000, A5);
    op6 = fr.mul(-34000, A6);
    op7 = fr.mul(-34000, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(45000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 787 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine788:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 788 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine789:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(827))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 789 << endl;
        exit(-1);
    }
    addrRel += 827;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine790:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine791:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 791 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine792:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 213;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine793:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine794:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(818))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 794 << endl;
        exit(-1);
    }
    addrRel += 818;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine795:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine796:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(796))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 796 << endl;
        exit(-1);
    }
    addrRel += 796;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine797:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(802))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 797 << endl;
        exit(-1);
    }
    addrRel += 802;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine798:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine799:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine800:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine801:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(796))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 801 << endl;
        exit(-1);
    }
    addrRel += 796;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine802:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine803:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine804:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 805;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 804 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine805:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine806:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine807:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 807 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine808:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine809:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine810:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine811:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 811 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine812:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 812 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine813:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 813 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine814:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 815;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 814 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine815:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 815 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine816:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 817;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 816 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine817:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(820))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 817 << endl;
        exit(-1);
    }
    addrRel += 820;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine818:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 818 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine819:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(827))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 819 << endl;
        exit(-1);
    }
    addrRel += 827;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine820:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 820 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine821:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine822:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(833))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 822 << endl;
        exit(-1);
    }
    addrRel += 833;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine823:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 823 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine824:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 824 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine825:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine826:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 826 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine827:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 827 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine828:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(833))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 828 << endl;
        exit(-1);
    }
    addrRel += 833;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine829:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 829 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine830:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 830 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine831:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine832:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 832 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine833:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1056))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 833 << endl;
        exit(-1);
    }
    addrRel += 1056;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine834:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(565))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 834 << endl;
        exit(-1);
    }
    addrRel += 565;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine835:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1069))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 835 << endl;
        exit(-1);
    }
    addrRel += 1069;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine836:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1069))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 836 << endl;
        exit(-1);
    }
    addrRel += 1069;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine837:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(631))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 837 << endl;
        exit(-1);
    }
    addrRel += 631;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine838:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(655))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 838 << endl;
        exit(-1);
    }
    addrRel += 655;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine839:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1069))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 839 << endl;
        exit(-1);
    }
    addrRel += 1069;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine840:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1069))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 840 << endl;
        exit(-1);
    }
    addrRel += 1069;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine841:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1069))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 841 << endl;
        exit(-1);
    }
    addrRel += 1069;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine842:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1069))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 842 << endl;
        exit(-1);
    }
    addrRel += 1069;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine843:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 843 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine844:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 844 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine845:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 845 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine846:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine847:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(17))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 847 << endl;
        exit(-1);
    }
    addrRel += 17;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine848:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(16))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 848 << endl;
        exit(-1);
    }
    addrRel += 16;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine849:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(18))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 849 << endl;
        exit(-1);
    }
    addrRel += 18;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine850:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine851:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine852:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 852 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine853:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 853 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine854:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 854 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine855:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine856:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 856 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine857:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 857 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine858:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(11))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 858 << endl;
        exit(-1);
    }
    addrRel += 11;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine859:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(8))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 859 << endl;
        exit(-1);
    }
    addrRel += 8;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine860:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(864))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 860 << endl;
        exit(-1);
    }
    addrRel += 864;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine861:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine862:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(864))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 862 << endl;
        exit(-1);
    }
    addrRel += 864;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine863:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 863 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine864:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 864 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine865:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine866:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 866 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine867:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine868:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine869:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine870:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 870 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine871:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine872:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 872 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine873:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    if ( (!fr.eq(A0, op0)) ||
         (!fr.eq(A1, op1)) ||
         (!fr.eq(A2, op2)) ||
         (!fr.eq(A3, op3)) ||
         (!fr.eq(A4, op4)) ||
         (!fr.eq(A5, op5)) ||
         (!fr.eq(A6, op6)) ||
         (!fr.eq(A7, op7)) )
{
        cerr << "Error: ROM assert failed: AN!=opN ln: " << 873 << endl;
        cout << "A: " << fr.toString(A7, 16) << ":" << fr.toString(A6, 16) << ":" << fr.toString(A5, 16) << ":" << fr.toString(A4, 16) << ":" << fr.toString(A3, 16) << ":" << fr.toString(A2, 16) << ":" << fr.toString(A1, 16) << ":" << fr.toString(A0, 16) << endl;
        cout << "OP:" << fr.toString(op7, 16) << ":" << fr.toString(op6, 16) << ":" << fr.toString(op5, 16) << ":" << fr.toString(op4,16) << ":" << fr.toString(op3, 16) << ":" << fr.toString(op2, 16) << ":" << fr.toString(op1, 16) << ":" << fr.toString(op0, 16) << endl;
        exit(-1);
}

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine874:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine875:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine876:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine877:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine878:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine879:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine880:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 880 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine881:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 881 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine882:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 882 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine883:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 884;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1447))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 883 << endl;
        exit(-1);
    }
    addrRel += 1447;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine884:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 884 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine885:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 885 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine886:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine887:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine888:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine889:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 889 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine890:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine891:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine892:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 892 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine893:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 893 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine894:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 894 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine895:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine896:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine897:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 897 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine898:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine899:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(21000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 899 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine900:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 900 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine901:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine902:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 902 << endl;
        exit(-1);
    }
    addrRel += 925;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine903:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine904:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = fr.neg(1);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine905:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine906:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine907:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine908:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(909))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 908 << endl;
        exit(-1);
    }
    addrRel += 909;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine909:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 909 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine910:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 910 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine911:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 912;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1447))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 911 << endl;
        exit(-1);
    }
    addrRel += 1447;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine912:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 912 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine913:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 913 << endl;
        exit(-1);
    }
    addrRel += 925;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine914:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(905))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 914 << endl;
        exit(-1);
    }
    addrRel += 905;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine915:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine916:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine917:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine918:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(920))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 918 << endl;
        exit(-1);
    }
    addrRel += 920;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine919:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(922))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 919 << endl;
        exit(-1);
    }
    addrRel += 922;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine920:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 920 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine921:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(909))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 921 << endl;
        exit(-1);
    }
    addrRel += 909;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine922:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 922 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine923:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(909))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 923 << endl;
        exit(-1);
    }
    addrRel += 909;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine924:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 924 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine925:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 925 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine926:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(937))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 926 << endl;
        exit(-1);
    }
    addrRel += 937;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine927:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 927 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine928:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine929:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 10;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine930:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(834))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 930 << endl;
        exit(-1);
    }
    addrRel += 834;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine931:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine932:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine933:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine934:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine935:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1069))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 935 << endl;
        exit(-1);
    }
    addrRel += 1069;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine936:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1039))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 936 << endl;
        exit(-1);
    }
    addrRel += 1039;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine937:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine938:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 938 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine939:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 939 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine940:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 940 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine941:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(973))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 941 << endl;
        exit(-1);
    }
    addrRel += 973;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine942:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 942 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine943:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 943 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine944:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(128));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(956))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 944 << endl;
        exit(-1);
    }
    addrRel += 956;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine945:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 945 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine946:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine947:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 214);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine948:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 148;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine949:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine950:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine951:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine952:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 128);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine953:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine954:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine955:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(966))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 955 << endl;
        exit(-1);
    }
    addrRel += 966;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine956:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine957:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 214;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine958:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 148;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine959:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine960:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine961:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine962:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(965))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 962 << endl;
        exit(-1);
    }
    addrRel += 965;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine963:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine964:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(966))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 964 << endl;
        exit(-1);
    }
    addrRel += 966;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine965:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 128;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine966:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine967:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine968:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 12;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine969:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 970;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 969 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine970:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 971;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 970 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine971:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 971 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine972:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1015))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 972 << endl;
        exit(-1);
    }
    addrRel += 1015;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine973:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 973 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine974:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine975:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 975 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine976:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 976 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine977:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 978;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 977 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine978:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 978 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine979:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-6
    op0 = fr.mul(-6, A0);
    op1 = fr.mul(-6, A1);
    op2 = fr.mul(-6, A2);
    op3 = fr.mul(-6, A3);
    op4 = fr.mul(-6, A4);
    op5 = fr.mul(-6, A5);
    op6 = fr.mul(-6, A6);
    op7 = fr.mul(-6, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 979 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine980:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine981:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(982))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 981 << endl;
        exit(-1);
    }
    addrRel += 982;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine982:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(994))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 982 << endl;
        exit(-1);
    }
    addrRel += 994;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine983:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(989))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 983 << endl;
        exit(-1);
    }
    addrRel += 989;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine984:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine985:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine986:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine987:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine988:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(982))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 988 << endl;
        exit(-1);
    }
    addrRel += 982;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine989:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine990:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine991:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 992;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 991 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine992:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine993:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine994:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine995:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine996:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine997:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 997 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine998:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 998 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine999:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1000:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1001:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1002:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1002 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1003:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1004:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(36))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1004 << endl;
        exit(-1);
    }
    addrRel += 36;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1005:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1006:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1007:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1008:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1009:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1010:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1011:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 12;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1012:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1013;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1012 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1013:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1014;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1013 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1014:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1014 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1015:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1015 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1016:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1016 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1017:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1018:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1019:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1019 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1020:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1020 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1021:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1021 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1022:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1022 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1023:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1023 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1024:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1024 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1025:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1025 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1026:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1026 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1027:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1028;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1027 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1028:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1028 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1029:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1029 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1030:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = fr.add(op0, SP);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1031:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1031 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1032:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inPC*PC, where inPC=-1
    op0 = fr.add(op0, fr.neg(PC));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1059))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1032 << endl;
        exit(-1);
    }
    addrRel += 1059;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1033:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1034:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1034 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1035:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1036:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1037:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1038:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1038 << endl;
        exit(-1);
    }
    addrRel += 309;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1039:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1040:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1041:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1041 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1042:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1042 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1043:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1044:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1045:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1046:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1047:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inPC*PC, where inPC=-1
    op0 = fr.add(op0, fr.neg(PC));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1069))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1047 << endl;
        exit(-1);
    }
    addrRel += 1069;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1048:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1049:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1050:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1051:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1052:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(309))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1052 << endl;
        exit(-1);
    }
    addrRel += 309;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1053:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1053 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1054:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1023))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1054 << endl;
        exit(-1);
    }
    addrRel += 1023;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1055:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1042))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1055 << endl;
        exit(-1);
    }
    addrRel += 1042;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1056:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1056 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1057:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1059))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1057 << endl;
        exit(-1);
    }
    addrRel += 1059;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1058:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1069))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1058 << endl;
        exit(-1);
    }
    addrRel += 1069;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1059:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1059 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1060:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1061:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1062:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1063:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1064:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1064 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1065:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1066:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1067:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1068:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1069:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1069 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1070:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1071:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1072:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1072 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1073:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1073 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1074:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1075:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1075 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1076:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1077:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1078:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1078 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1079:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1080:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1081:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1081 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1082:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1082 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1083:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1083 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1084:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1085;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1429))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1084 << endl;
        exit(-1);
    }
    addrRel += 1429;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1085:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1085 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1086:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1086 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1087:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1088:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1089:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1090:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1090 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1091:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1100))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1091 << endl;
        exit(-1);
    }
    addrRel += 1100;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1092:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1093:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inGAS*GAS, where inGAS=-1
    op0 = fr.add(op0, fr.neg(GAS));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1094:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1094 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1095:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1095 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1096:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1097;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1096 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1097:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1097 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1098:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=-1
    op0 = fr.add(op0, fr.neg(B0));
    op1 = fr.add(op1, fr.neg(B1));
    op2 = fr.add(op2, fr.neg(B2));
    op3 = fr.add(op3, fr.neg(B3));
    op4 = fr.add(op4, fr.neg(B4));
    op5 = fr.add(op5, fr.neg(B5));
    op6 = fr.add(op6, fr.neg(B6));
    op7 = fr.add(op7, fr.neg(B7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1100))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1098 << endl;
        exit(-1);
    }
    addrRel += 1100;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1099:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1100:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1101:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1102:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1102 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1103:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1103 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1104:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1104 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1105:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1106;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1447))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1105 << endl;
        exit(-1);
    }
    addrRel += 1447;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1106:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1106 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1107:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1107 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1108:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1109:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1110:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1110 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1111:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1111 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1112:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1113;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1429))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1112 << endl;
        exit(-1);
    }
    addrRel += 1429;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1113:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1113 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1114:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1114 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1115:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1116:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1117:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1118:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inGAS*GAS, where inGAS=-1
    op0 = fr.add(op0, fr.neg(GAS));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1119:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1119 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1120:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1120 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1121:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1121 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1122:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1123;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1447))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1122 << endl;
        exit(-1);
    }
    addrRel += 1447;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1123:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1123 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1124:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1124 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1125:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1126:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1127:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1127 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1128:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1128 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1129:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1130;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1429))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1129 << endl;
        exit(-1);
    }
    addrRel += 1429;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1130:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1130 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1131:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1131 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1132:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1133:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1134:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(65))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1134 << endl;
        exit(-1);
    }
    addrRel += 65;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1135:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1135 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1136:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(65))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1136 << endl;
        exit(-1);
    }
    addrRel += 65;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1137:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1138:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1140))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1138 << endl;
        exit(-1);
    }
    addrRel += 1140;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1139:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1140:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1141:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1142:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1143:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1144:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1145:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1145 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1146:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1146 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1147:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1148:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1148 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1149:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1149 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1150:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1150 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1151:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1168))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1151 << endl;
        exit(-1);
    }
    addrRel += 1168;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1152:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1208))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1152 << endl;
        exit(-1);
    }
    addrRel += 1208;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1153:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1161))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1153 << endl;
        exit(-1);
    }
    addrRel += 1161;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1154:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1155:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1156:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1156 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1157:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1158:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1158 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1159:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1160:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1152))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1160 << endl;
        exit(-1);
    }
    addrRel += 1152;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1161:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1162:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1163:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1164;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1163 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1164:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1165;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1164 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1165:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1165 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1166:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1167:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1208))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1167 << endl;
        exit(-1);
    }
    addrRel += 1208;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1168:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1208))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1168 << endl;
        exit(-1);
    }
    addrRel += 1208;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1169:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1184))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1169 << endl;
        exit(-1);
    }
    addrRel += 1184;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1170:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1171:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1172:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1173:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1174;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1173 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1174:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1175:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1176:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1177:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1178:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1179;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1178 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1179:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1179 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1180:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1181:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1181 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1182:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1183:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1168))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1183 << endl;
        exit(-1);
    }
    addrRel += 1168;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1184:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1194))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1184 << endl;
        exit(-1);
    }
    addrRel += 1194;
    addr = addrRel;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1185:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1186:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1187:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1188:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1189:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1190;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1189 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1190:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1191;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1190 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1191:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1191 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1192:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1193:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1208))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1193 << endl;
        exit(-1);
    }
    addrRel += 1208;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1194:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1195:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1196:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1197:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1198;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1197 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1198:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1199:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1200:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1201:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1202:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1203:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1204;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1203 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1204:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1205:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1206;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1205 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1206:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1206 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1207:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1208:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1208 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1209:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1209 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1210:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1211:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1211 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1212:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1212 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1213:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1213 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1214:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1215:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1216:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1217:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1222))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1217 << endl;
        exit(-1);
    }
    addrRel += 1222;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1218:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1219:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1220;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1219 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1220:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1221:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1216))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1221 << endl;
        exit(-1);
    }
    addrRel += 1216;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1222:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1223:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1223 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1224:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1224 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1225:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1225 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1226:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1227:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1227 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1228:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1228 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1229:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1229 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1230:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1230 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1231:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1231 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1232:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1232 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1233:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = fr.neg(1);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1258))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1233 << endl;
        exit(-1);
    }
    addrRel += 1258;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1234:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1235:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1236:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1237:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1238:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1239;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1238 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1239:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1240;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1239 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1240:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1241:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1241 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1242:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1243:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1244;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1243 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1244:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1245:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1246:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1247:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1248:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1249;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1248 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1249:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1250;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1249 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1250:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1251:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1251 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1252:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1253:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1254;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1253 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1254:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1255:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1255 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1256:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1257:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1302))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1257 << endl;
        exit(-1);
    }
    addrRel += 1302;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1258:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1258 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1259:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1260:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1261:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1302))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1261 << endl;
        exit(-1);
    }
    addrRel += 1302;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1262:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1262 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1263:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1263 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1264:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1264 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1265:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1265 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1266:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1266 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1267:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1267 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1268:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1282))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1268 << endl;
        exit(-1);
    }
    addrRel += 1282;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1269:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1270:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1271:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1271 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1272:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1273;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1272 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1273:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1274:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1275:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1276:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1277;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1276 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1277:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1278;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1277 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1278:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1279:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1279 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1280:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1281:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1302))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1281 << endl;
        exit(-1);
    }
    addrRel += 1302;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1282:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1283:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1284:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1284 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1285:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1286;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1285 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1286:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1287:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1288:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1289:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1290;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1289 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1290:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1291;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1290 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1291:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1292:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1293:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1293 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1294:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1295;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1294 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1295:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1296:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1297:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1298:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1299;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1298 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1299:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1300:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1300 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1301:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1302:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1302 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1303:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1303 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1304:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1304 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1305:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1305 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1306:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1306 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1307:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1308:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1308 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1309:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1309 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1310:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1310 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1311:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1311 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1312:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1313:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1314:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1315:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1316:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1317:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1337))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1317 << endl;
        exit(-1);
    }
    addrRel += 1337;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1318:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1319:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1320:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1321:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1322:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1322 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1323:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1324:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1325:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1325 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1326:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1327:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1328:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1329;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1328 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1329:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1330:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1331:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1332:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1333:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1334;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1333 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1334:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1335:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1336:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1371))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1336 << endl;
        exit(-1);
    }
    addrRel += 1371;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1337:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1338:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1339:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1371))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1339 << endl;
        exit(-1);
    }
    addrRel += 1371;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1340:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1340 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1341:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1341 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1342:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1342 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1343:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1343 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1344:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1344 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1345:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1356))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1345 << endl;
        exit(-1);
    }
    addrRel += 1356;
    addr = addrRel;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1346:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1347:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1348:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1349:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1350:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1351;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1350 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1351:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1352:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1353;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1352 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1353:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1354;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1353 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1354:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1355:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1371))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1355 << endl;
        exit(-1);
    }
    addrRel += 1371;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1356:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1357:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1358:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1359:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1360;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1359 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1360:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1361:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1362:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    // If isMem, addr = addr + MEM_OFFSET
    addr += MEM_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    if (addrRel>mm)
    {
        maxMemCalculated = addrRel;
    } else {
        maxMemCalculated = mm;
    }
RomLine1363:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1364:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1365:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1366;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1365 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1366:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1367:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1368;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1367 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1368:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1369:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1369 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1370:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1371:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1371 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1372:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1372 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1373:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1373 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1374:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1374 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1375:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1376:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1376 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1377:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1377 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1378:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1378 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1379:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1379 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1380:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1381:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1382:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1383:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1384:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1399))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1384 << endl;
        exit(-1);
    }
    addrRel += 1399;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1385:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1386:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1387:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1388:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1389:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1390:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1399))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1390 << endl;
        exit(-1);
    }
    addrRel += 1399;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1391:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1392:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1393:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1394:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1395:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1396:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1399))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1396 << endl;
        exit(-1);
    }
    addrRel += 1399;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1397:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1398:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1401))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1398 << endl;
        exit(-1);
    }
    addrRel += 1401;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1399:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1400:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1401))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1400 << endl;
        exit(-1);
    }
    addrRel += 1401;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1401:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1401 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1402:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1402 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1403:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1403 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1404:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1404 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1405:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1406:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1406 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1407:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1407 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1408:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1408 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1409:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1409 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1410:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1411:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1411 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1412:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1414))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1412 << endl;
        exit(-1);
    }
    addrRel += 1414;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1413:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1414:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1414 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1415:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1415 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1416:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1416 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1417:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1417 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1418:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1419:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1419 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1420:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1420 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1421:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1421 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1422:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1423:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1424:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-3
    op0 = fr.mul(-3, A0);
    op1 = fr.mul(-3, A1);
    op2 = fr.mul(-3, A2);
    op3 = fr.mul(-3, A3);
    op4 = fr.mul(-3, A4);
    op5 = fr.mul(-3, A5);
    op6 = fr.mul(-3, A6);
    op7 = fr.mul(-3, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1424 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1425:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=3
    op0 = fr.mul(3, B0);
    op1 = fr.mul(3, B1);
    op2 = fr.mul(3, B2);
    op3 = fr.mul(3, B3);
    op4 = fr.mul(3, B4);
    op5 = fr.mul(3, B5);
    op6 = fr.mul(3, B6);
    op7 = fr.mul(3, B7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1425 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1426:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1426 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1427:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1427 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1428:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1429:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1429 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1430:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1431;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1477))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1430 << endl;
        exit(-1);
    }
    addrRel += 1477;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1431:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1431 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1432:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1432 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1433:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1434:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1434 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1435:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1436;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1471))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1435 << endl;
        exit(-1);
    }
    addrRel += 1471;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1436:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1436 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1437:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1438:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1438 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1439:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1440;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1477))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1439 << endl;
        exit(-1);
    }
    addrRel += 1477;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1440:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1440 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1441:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1441 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1442:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1443:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1443 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1444:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1445;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1471))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1444 << endl;
        exit(-1);
    }
    addrRel += 1471;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1445:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1445 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1446:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1447:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1447 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1448:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1449;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1477))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1448 << endl;
        exit(-1);
    }
    addrRel += 1477;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1449:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1449 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1450:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1450 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1451:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1452:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1453:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1454:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1454 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1455:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1456;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1471))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1455 << endl;
        exit(-1);
    }
    addrRel += 1471;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1456:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1456 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1457:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1458:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inRR*RR, where inRR=1
    op0 = RR;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1458 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1459:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1460;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1477))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1459 << endl;
        exit(-1);
    }
    addrRel += 1477;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1460:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1460 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1461:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1461 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1462:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1463:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1464:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1465:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1466:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1466 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1467:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1467 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1468:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1469;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1471))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1468 << endl;
        exit(-1);
    }
    addrRel += 1471;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1469:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(45))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1469 << endl;
        exit(-1);
    }
    addrRel += 45;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    RR = fe2n(fr, op0); // If setRR, RR'=op0

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1470:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1471:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1471 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1472:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1472 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1473:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1473 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1474:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1474 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1475:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1475 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1476:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1477:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1477 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1478:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1478 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1479:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1479 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1480:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1480 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1481:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1481 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1482:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1483:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1483 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1484:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1484 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1485:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1485 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1486:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1486 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1487:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1488:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1489:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1490:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1491:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1492:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1493:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1494:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1499))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1494 << endl;
        exit(-1);
    }
    addrRel += 1499;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1495:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1495 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1496:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1496 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1497:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1497 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1498:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1498 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1499:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1500:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1500 << endl;
        exit(-1);
    }
    addrRel += 1515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1501:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1502:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1503:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1504:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1514))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1504 << endl;
        exit(-1);
    }
    addrRel += 1514;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1505:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1506:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1507:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1508:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1509:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1510:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1511:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1512:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1513:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1513 << endl;
        exit(-1);
    }
    addrRel += 1515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1514:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1515:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1515 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1516:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1516 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1517:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1517 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1518:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1518 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1519:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1520:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1520 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1521:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1521 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1522:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1522 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1523:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1523 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1524:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1525:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1526:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1527:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1528:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1529:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1530:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1531:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1536))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1531 << endl;
        exit(-1);
    }
    addrRel += 1536;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1532:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1532 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1533:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1533 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1534:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1534 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1535:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1535 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1536:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1537:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1538:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1539:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1564))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1539 << endl;
        exit(-1);
    }
    addrRel += 1564;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1540:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1541:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1542:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1543:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 256);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1557))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1543 << endl;
        exit(-1);
    }
    addrRel += 1557;
    addr = addrRel;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1544:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1545:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1546:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1547:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1548:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1549:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1550:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1551:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 256);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1552:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1553:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1559))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1553 << endl;
        exit(-1);
    }
    addrRel += 1559;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1554:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1555:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1556:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1564))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1556 << endl;
        exit(-1);
    }
    addrRel += 1564;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1557:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1558:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1564))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1558 << endl;
        exit(-1);
    }
    addrRel += 1564;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1559:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 256);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1560:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1561:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1562:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1563:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1564:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1565:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1565 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1566:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(38))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1566 << endl;
        exit(-1);
    }
    addrRel += 38;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1567:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(39))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1567 << endl;
        exit(-1);
    }
    addrRel += 39;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1568:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(40))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1568 << endl;
        exit(-1);
    }
    addrRel += 40;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1569:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, RR);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1570:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1570 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1571:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1571 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1572:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1573:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1580))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1573 << endl;
        exit(-1);
    }
    addrRel += 1580;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1574:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1575:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1575 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1576:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1576 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1577:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1577 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1578:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1579:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1579 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1580:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1581:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1117))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1581 << endl;
        exit(-1);
    }
    addrRel += 1117;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1582:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1582 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1583:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1583 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1584:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1585:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1592))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1585 << endl;
        exit(-1);
    }
    addrRel += 1592;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1586:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1587:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1587 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1588:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1588 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1589:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1589 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1590:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1591:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1591 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1592:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1593:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1117))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1593 << endl;
        exit(-1);
    }
    addrRel += 1117;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1594:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1594 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1595:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1606))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1595 << endl;
        exit(-1);
    }
    addrRel += 1606;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1596:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1596 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1597:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1598:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1598 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1599:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1599 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1600:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1601:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1601 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1602:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1602 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1603:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1604:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1604 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1605:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1605 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1606:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1056))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1606 << endl;
        exit(-1);
    }
    addrRel += 1056;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1607:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1607 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1608:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1609:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1610:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1611:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1611 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1612:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1612 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1613:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1614;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1429))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1613 << endl;
        exit(-1);
    }
    addrRel += 1429;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1614:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1614 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1615:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1616:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1616 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1617:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1617 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1618:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1618 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1619:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1619 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1620:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1621:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1622:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1623:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1623 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1624:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1624 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1625:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1626;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1447))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1625 << endl;
        exit(-1);
    }
    addrRel += 1447;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1626:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1626 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1627:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1628:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1628 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1629:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1629 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1630:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1630 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1631:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1631 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1632:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1633:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1634:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1635:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1635 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1636:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1636 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1637:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1638;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1438))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1637 << endl;
        exit(-1);
    }
    addrRel += 1438;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1638:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1638 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1639:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1640:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1640 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1641:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1641 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1642:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1642 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1643:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1643 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1644:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1645:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1646:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1647:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1647 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1648:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1648 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1649:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1650;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1649 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1650:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1650 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1651:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1652:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1652 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1653:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1653 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1654:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1654 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1655:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1655 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1656:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1657:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1658:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1659;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1137))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1658 << endl;
        exit(-1);
    }
    addrRel += 1137;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1659:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1660:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1661:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1662:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1663;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1137))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1662 << endl;
        exit(-1);
    }
    addrRel += 1137;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1663:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1663 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1664:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1665:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1666:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1667:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1668:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1668 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1669:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1678))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1669 << endl;
        exit(-1);
    }
    addrRel += 1678;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1670:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1670 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1671:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1671 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1672:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1673;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1672 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1673:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1673 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1674:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1675:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1675 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1676:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1676 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1677:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1677 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1678:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1679:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1680:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1681:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1682:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1683:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1684:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1685:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1685 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1686:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1686 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1687:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1687 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1688:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1688 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1689:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1690:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1691:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1692:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1692 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1693:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1693 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1694:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1695;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1694 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1695:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1695 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1696:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1697:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1697 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1698:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1698 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1699:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1699 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1700:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1700 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1701:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1702:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1703:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1704;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1137))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1703 << endl;
        exit(-1);
    }
    addrRel += 1137;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1704:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1705:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1706:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1707:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1708;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1137))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1707 << endl;
        exit(-1);
    }
    addrRel += 1137;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1708:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1708 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1709:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1710:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1711:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1712:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1712 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1713:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1722))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1713 << endl;
        exit(-1);
    }
    addrRel += 1722;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1714:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1714 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1715:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1715 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1716:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1717;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1716 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1717:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1717 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1718:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1719:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1719 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1720:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1720 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1721:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1721 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1722:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1723:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1724:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1725:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1726:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1727:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1728:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1729:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1730:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1730 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1731:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1731 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1732:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1732 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1733:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1733 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1734:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1735:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1736:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1737:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1737 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1738:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1738 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1739:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1740;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1429))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1739 << endl;
        exit(-1);
    }
    addrRel += 1429;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1740:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1740 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1741:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1742:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1742 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1743:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1743 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1744:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1745;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1744 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1745:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1745 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1746:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1747:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1747 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1748:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1748 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1749:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1749 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1750:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1750 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1751:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1752:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1753:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1754:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1754 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1755:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1755 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1756:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1757;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1447))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1756 << endl;
        exit(-1);
    }
    addrRel += 1447;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1757:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1757 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1758:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1759:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1759 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1760:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1760 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1761:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1762;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1761 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1762:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1762 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1763:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1764:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1764 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1765:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1765 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1766:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1766 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1767:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1767 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1768:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1769:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1770:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1771:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1772:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1773:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1773 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1774:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1775;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1211))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1774 << endl;
        exit(-1);
    }
    addrRel += 1211;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1775:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-50
    op0 = fr.mul(-50, A0);
    op1 = fr.mul(-50, A1);
    op2 = fr.mul(-50, A2);
    op3 = fr.mul(-50, A3);
    op4 = fr.mul(-50, A4);
    op5 = fr.mul(-50, A5);
    op6 = fr.mul(-50, A6);
    op7 = fr.mul(-50, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1775 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1776:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1776 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1777:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1777 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1778:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1779:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1780:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1781:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 31;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1782:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1783:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1804))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1783 << endl;
        exit(-1);
    }
    addrRel += 1804;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1784:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1785:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1785 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1786:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 7;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1786 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1787:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1788;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1429))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1787 << endl;
        exit(-1);
    }
    addrRel += 1429;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1788:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1788 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1789:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1790:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1791:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1792:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1793:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1794:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1801))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1794 << endl;
        exit(-1);
    }
    addrRel += 1801;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1795:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1796:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1797:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1798:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1799:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1800:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1804))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1800 << endl;
        exit(-1);
    }
    addrRel += 1804;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1801:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1802:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1803:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1804:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1805:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1805 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1806:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1806 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1807:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1807 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1808:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1809:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1809 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1810:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1810 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1811:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1812:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1812 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1813:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1813 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1814:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1814 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1815:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1816:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1817:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1818:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1818 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1819:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1820:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1820 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1821:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1821 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1822:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1822 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1823:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1824:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1825:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1826:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1826 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1827:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1828:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1828 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1829:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1829 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1830:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1830 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1831:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1832:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1833:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1834:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1834 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1835:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1836:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1836 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1837:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1837 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1838:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1838 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1839:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1840:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1841:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1842:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1842 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1843:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1844:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1844 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1845:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1845 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1846:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1846 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1847:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1848:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1849:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1850:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1850 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1851:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1852:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1852 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1853:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1853 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1854:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1854 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1855:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1856:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1856 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1857:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1858:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1859:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1859 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1860:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1860 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1861:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1861 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1862:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1863:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1864:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1865:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1865 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1866:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1867:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1867 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1868:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1868 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1869:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1869 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1870:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1871:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1872:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1873:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1873 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1874:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1875:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1875 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1876:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1876 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1877:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1877 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1878:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1879:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1880:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1881:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1881 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1882:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1883:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1883 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1884:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1884 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1885:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1885 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1886:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1887:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1887 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1888:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + CONSTL

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1889:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1890:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1890 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1891:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1891 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1892:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1892 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1893:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1894:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1895:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1896:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1897:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1898;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1897 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1898:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1898 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1899:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 255;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1900:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1901:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1901 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1902:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1902 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1903:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1903 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1904:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1905:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1906:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1907:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1908;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1495))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1907 << endl;
        exit(-1);
    }
    addrRel += 1495;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1908:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1909:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1909 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1910:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1910 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1911:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1911 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1912:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1912 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1913:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1914:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1915:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1916:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1917;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1532))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1916 << endl;
        exit(-1);
    }
    addrRel += 1532;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1917:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1918:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1918 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1919:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1919 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1920:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1920 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1921:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1921 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1922:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1923:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1924:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1925:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1926:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1927:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1928:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1929:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1930:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1931:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1932:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1933;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1137))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1932 << endl;
        exit(-1);
    }
    addrRel += 1137;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1933:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1934;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1933 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1934:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1935:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1936:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1937:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1938:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1943))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1938 << endl;
        exit(-1);
    }
    addrRel += 1943;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1939:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1940:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1940 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1941:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1941 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1942:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1942 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1943:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1944:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1945:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1946:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1947:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1948:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1949:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1950:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1950 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1951:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1951 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1952:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1952 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1953:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1953 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1954:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1955:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1956:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1957:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1957 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1958:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(30));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1958 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1959:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1960:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1960 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1961:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1961 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1962:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1963;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1962 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1963:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1963 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1964:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 6;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1964 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1965:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1965 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1966:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1967;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1447))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1966 << endl;
        exit(-1);
    }
    addrRel += 1447;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1967:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1967 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1968:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1968 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine1969:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1969 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1970:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1970 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1971:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1972:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine1973:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1988))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1973 << endl;
        exit(-1);
    }
    addrRel += 1988;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1974:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1982))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1974 << endl;
        exit(-1);
    }
    addrRel += 1982;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1975:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1976;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1975 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1976:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1977:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1977 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1978:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1979:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1980:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1981:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1973))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1981 << endl;
        exit(-1);
    }
    addrRel += 1973;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1982:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1983;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1982 << endl;
        exit(-1);
    }
    addrRel += 1340;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1983:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1984:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1985;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1984 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1985:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1985 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1986:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1987:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1988:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1988 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1989:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1990:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1991:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1992:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1992 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1993:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1993 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1994:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1994 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1995:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1995 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1996:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1996 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1997:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1997 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1998:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2001))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1998 << endl;
        exit(-1);
    }
    addrRel += 2001;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine1999:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 1999 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2000:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2002))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2000 << endl;
        exit(-1);
    }
    addrRel += 2002;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2001:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2001 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2002:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2003:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2003 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2004:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2004 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2005:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2005 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2006:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2006 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2007:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2008:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2009:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2010:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2011:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2011 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2012:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2013:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2013 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2014:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2014 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2015:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2015 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2016:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2017:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2017 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2018:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2018 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2019:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2019 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2020:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2020 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2021:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2022:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2022 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2023:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2023 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2024:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2024 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2025:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2025 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2026:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2027:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2027 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2028:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2028 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2029:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2029 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2030:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2030 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2031:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2032:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2032 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2033:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2033 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2034:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2035;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2034 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2035:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2035 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2036:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2036 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2037:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2046))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2037 << endl;
        exit(-1);
    }
    addrRel += 2046;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2038:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2039:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2040:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2041:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2042:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2043:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2043 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2044:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2044 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2045:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2045 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2046:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2047:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2048:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2049:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2050:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2051;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2050 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2051:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2052:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2053:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2054:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2055;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2054 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2055:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2056:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2057:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2057 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2058:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2058 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2059:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2059 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2060:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2060 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2061:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2062:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2062 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2063:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2063 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2064:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2064 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2065:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2065 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2066:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2067:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2068:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2069:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2070:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2070 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2071:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2071 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2072:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2072 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2073:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2073 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2074:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2075))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2074 << endl;
        exit(-1);
    }
    addrRel += 2075;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2075:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2123))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2075 << endl;
        exit(-1);
    }
    addrRel += 2123;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2076:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2099))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2076 << endl;
        exit(-1);
    }
    addrRel += 2099;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2077:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2077 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2078:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2078 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2079:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2080;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2079 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2080:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2080 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2081:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2081 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2082:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2083:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2084:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2085;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2084 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2085:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2086:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2086 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2087:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1025);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2088:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2089:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2090:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2091;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2090 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2091:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2091 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2092:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2093;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2092 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2093:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2093 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2094:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2095:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2096:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2097:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2098:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2075))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2098 << endl;
        exit(-1);
    }
    addrRel += 2075;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2099:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2100:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1024;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2101:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2102:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2103;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2102 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2103:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2103 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2104:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2105:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1025;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2106:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=1
    op0 = fr.add(op0, D0);
    op1 = fr.add(op1, D1);
    op2 = fr.add(op2, D2);
    op3 = fr.add(op3, D3);
    op4 = fr.add(op4, D4);
    op5 = fr.add(op5, D5);
    op6 = fr.add(op6, D6);
    op7 = fr.add(op7, D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2107:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2118))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2107 << endl;
        exit(-1);
    }
    addrRel += 2118;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2108:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2109:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2110:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2111:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2112;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2111 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2112:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2113:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2114;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2113 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2114:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2115:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2115 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2116:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2117;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2116 << endl;
        exit(-1);
    }
    addrRel += 1262;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2117:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2123))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2117 << endl;
        exit(-1);
    }
    addrRel += 2123;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2118:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2119:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2120;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2119 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2120:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2121;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2120 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2121:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2121 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2122:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2123;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2122 << endl;
        exit(-1);
    }
    addrRel += 1262;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2123:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2123 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2124:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2124 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2125:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2125 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2126:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2126 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2127:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2127 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2128:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2128 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2129:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2139))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2129 << endl;
        exit(-1);
    }
    addrRel += 2139;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2130:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2130 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2131:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2132:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2133:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2134:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2135:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2136:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2136 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2137:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2137 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2138:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2138 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2139:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2139 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2140:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2141:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2141 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2142:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2142 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2143:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2143 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2144:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2144 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2145:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2145 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2146:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2065))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2146 << endl;
        exit(-1);
    }
    addrRel += 2065;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2147:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2147 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2148:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2149:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2150:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2151:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2152:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2153:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2154:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2155:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2155 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2156:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2156 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2157:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2157 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2158:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2171))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2158 << endl;
        exit(-1);
    }
    addrRel += 2171;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2159:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2166))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2159 << endl;
        exit(-1);
    }
    addrRel += 2166;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2160:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2161:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2161 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2162:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2163;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2162 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2163:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2164:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2165:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2158))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2165 << endl;
        exit(-1);
    }
    addrRel += 2158;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2166:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2167:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2168:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2169;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2168 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2169:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2169 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2170:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2171;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2170 << endl;
        exit(-1);
    }
    addrRel += 1262;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2171:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2171 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2172:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2172 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2173:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2173 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2174:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2174 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2175:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2175 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2176:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2177:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2177 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2178:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2178 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2179:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2179 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2180:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2180 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2181:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2182:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2183:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2184:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2185:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2186:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2187:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2188:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2188 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2189:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2189 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2190:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2190 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2191:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2191 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2192:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2193:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2194:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2195:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2196:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2197:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2198:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2199:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2200:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2201:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2201 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2202:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2202 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2203:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2203 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2204:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2217))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2204 << endl;
        exit(-1);
    }
    addrRel += 2217;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2205:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2212))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2205 << endl;
        exit(-1);
    }
    addrRel += 2212;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2206:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2207:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2207 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2208:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2209;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2208 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2209:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2210:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2211:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2204))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2211 << endl;
        exit(-1);
    }
    addrRel += 2204;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2212:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2213:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2214:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2215;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2214 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2215:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2215 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2216:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2217;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2216 << endl;
        exit(-1);
    }
    addrRel += 1262;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2217:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2217 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2218:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2218 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2219:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2219 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2220:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2220 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2221:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2221 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2222:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2223:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2223 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2224:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2224 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2225:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2225 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2226:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2226 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2227:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2228:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2229:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2230:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2230 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2231:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2232:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2233:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2233 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2234:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 31);

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2235:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2235 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2236:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2236 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2237:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2238;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2237 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2238:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2238 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2239:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2239 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2240:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2240 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2241:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2242;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1447))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2241 << endl;
        exit(-1);
    }
    addrRel += 1447;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2242:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2242 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2243:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2243 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2244:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inC*C, where inC=1
    op0 = fr.add(op0, C0);
    op1 = fr.add(op1, C1);
    op2 = fr.add(op2, C2);
    op3 = fr.add(op3, C3);
    op4 = fr.add(op4, C4);
    op5 = fr.add(op5, C5);
    op6 = fr.add(op6, C6);
    op7 = fr.add(op7, C7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2244 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2245:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2245 << endl;
        exit(-1);
    }
    addrRel += 2262;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2246:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2256))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2246 << endl;
        exit(-1);
    }
    addrRel += 2256;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2247:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2248:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2249;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2248 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2249:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2250:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2251:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2251 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2252:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2253;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2252 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2253:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2254:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2255:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2245))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2255 << endl;
        exit(-1);
    }
    addrRel += 2245;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2256:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2257:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2258;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2257 << endl;
        exit(-1);
    }
    addrRel += 1340;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2258:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2259:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2260:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2260 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2261:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2262;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2261 << endl;
        exit(-1);
    }
    addrRel += 1262;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2262:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2262 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2263:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2263 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2264:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2264 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2265:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2265 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2266:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2266 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2267:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2268:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2269:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2269 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2270:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2271:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2272:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2273:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2274:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2274 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2275:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2275 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2276:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine2277:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2278:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2287))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2278 << endl;
        exit(-1);
    }
    addrRel += 2287;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2279:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2284))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2279 << endl;
        exit(-1);
    }
    addrRel += 2284;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2280:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2281:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2282:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inD*D, where inD=-1
    op0 = fr.add(op0, fr.neg(D0));
    op1 = fr.add(op1, fr.neg(D1));
    op2 = fr.add(op2, fr.neg(D2));
    op3 = fr.add(op3, fr.neg(D3));
    op4 = fr.add(op4, fr.neg(D4));
    op5 = fr.add(op5, fr.neg(D5));
    op6 = fr.add(op6, fr.neg(D6));
    op7 = fr.add(op7, fr.neg(D7));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2283:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2277))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2283 << endl;
        exit(-1);
    }
    addrRel += 2277;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2284:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2285:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2286:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2287:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2288:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2289:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2290:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2290 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2291:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2291 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2292:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2292 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2293:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(20));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2293 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2294:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2295:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2295 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2296:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2311))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2296 << endl;
        exit(-1);
    }
    addrRel += 2311;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2297:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2297 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2298:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(6))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2298 << endl;
        exit(-1);
    }
    addrRel += 6;
    addr = addrRel;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2299:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    HASHPOS = fe2n(fr, op0) + incHashPos;
RomLine2300:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2301:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2302:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2303:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inHASHPOS*HASHPOS, where inHASHPOS=1
    op0 = HASHPOS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2304:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addrRel = fe2n(fr, E0);
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2305:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2306:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2307:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2308:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2309:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2309 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2310:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2310 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2311:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2312:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2312 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2313:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2313 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2314:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2314 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2315:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2316:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2316 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2317:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2317 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2318:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2318 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2319:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2319 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2320:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2321:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2321 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2322:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2322 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2323:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2323 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2324:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2324 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2325:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2326:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2326 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2327:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2327 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2328:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2328 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2329:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2330:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2331:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2331 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2332:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2332 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2333:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2333 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2334:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 30000000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2335:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2336:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2336 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2337:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2337 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2338:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2338 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2339:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2340:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2341:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2341 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2342:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2342 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2343:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2343 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2344:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2344 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2345:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2346:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2347:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2348:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2348 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2349:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2349 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2350:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2350 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2351:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2351 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2352:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2352 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2353:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2353 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2354:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2354 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2355:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2356:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2357;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2356 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2357:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2358:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2358 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2359:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2359 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2360:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2360 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2361:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2361 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2362:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2362 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2363:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2363 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2364:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2365:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2366:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2367:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2367 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2368:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2369;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2368 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2369:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2369 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2370:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2370 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2371:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2371 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2372:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2372 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2373:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2374;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1419))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2373 << endl;
        exit(-1);
    }
    addrRel += 1419;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2374:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2374 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2375:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2375 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2376:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2377:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2378:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2379:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2380:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2381:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2382;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1520))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2381 << endl;
        exit(-1);
    }
    addrRel += 1520;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2382:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2382 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2383:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2384;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2383 << endl;
        exit(-1);
    }
    addrRel += 1262;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2384:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2384 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2385:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2385 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2386:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2386 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2387:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2387 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2388:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2388 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2389:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2390:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2390 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2391:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2392:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2393:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2394:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2394 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2395:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2396:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-2000
    op0 = fr.mul(-2000, A0);
    op1 = fr.mul(-2000, A1);
    op2 = fr.mul(-2000, A2);
    op3 = fr.mul(-2000, A3);
    op4 = fr.mul(-2000, A4);
    op5 = fr.mul(-2000, A5);
    op6 = fr.mul(-2000, A6);
    op7 = fr.mul(-2000, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2396 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2397:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2397 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2398:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2398 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2399:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2399 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2400:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2400 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2401:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2402:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2403:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2403 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2404:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2405:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2405 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2406:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2409))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2406 << endl;
        exit(-1);
    }
    addrRel += 2409;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2407:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2407 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2408:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2410))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2408 << endl;
        exit(-1);
    }
    addrRel += 2410;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2409:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2409 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2410:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2411:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2412:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2412 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2413:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2413 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2414:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2415:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2415 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2416:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2417:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2418:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-2100
    op0 = fr.mul(-2100, A0);
    op1 = fr.mul(-2100, A1);
    op2 = fr.mul(-2100, A2);
    op3 = fr.mul(-2100, A3);
    op4 = fr.mul(-2100, A4);
    op5 = fr.mul(-2100, A5);
    op6 = fr.mul(-2100, A6);
    op7 = fr.mul(-2100, A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2418 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2419:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2420:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2421:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2422:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2425))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2422 << endl;
        exit(-1);
    }
    addrRel += 2425;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2423:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2423 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2424:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2475))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2424 << endl;
        exit(-1);
    }
    addrRel += 2475;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2425:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2426:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2427:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2428:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2435))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2428 << endl;
        exit(-1);
    }
    addrRel += 2435;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2429:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2430:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2431:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2432:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2467))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2432 << endl;
        exit(-1);
    }
    addrRel += 2467;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2433:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(20000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2433 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2434:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2475))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2434 << endl;
        exit(-1);
    }
    addrRel += 2475;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2435:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2435 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2436:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2437:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2438:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2439:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2450))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2439 << endl;
        exit(-1);
    }
    addrRel += 2450;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2440:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2441:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2442:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2443:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2475))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2443 << endl;
        exit(-1);
    }
    addrRel += 2475;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2444:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2445:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2446:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2464))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2446 << endl;
        exit(-1);
    }
    addrRel += 2464;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2447:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2447 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2448:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 19900);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2448 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2449:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2475))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2449 << endl;
        exit(-1);
    }
    addrRel += 2475;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2450:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2451:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2452:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2453:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2457))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2453 << endl;
        exit(-1);
    }
    addrRel += 2457;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2454:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2454 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2455:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2455 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2456:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2440))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2456 << endl;
        exit(-1);
    }
    addrRel += 2440;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2457:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2458:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2459:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2460:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2440))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2460 << endl;
        exit(-1);
    }
    addrRel += 2440;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2461:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2461 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2462:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15000);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2462 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2463:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2440))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2463 << endl;
        exit(-1);
    }
    addrRel += 2440;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2464:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2464 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2465:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 2800);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2465 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2466:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2475))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2466 << endl;
        exit(-1);
    }
    addrRel += 2475;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2467:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2900));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2467 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2468:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2469:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2470:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2471:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2475))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2471 << endl;
        exit(-1);
    }
    addrRel += 2475;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2472:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2472 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2473:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15000);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2473 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2474:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2475))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2474 << endl;
        exit(-1);
    }
    addrRel += 2475;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2475:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2475 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2476:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2479))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2476 << endl;
        exit(-1);
    }
    addrRel += 2479;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2477:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2477 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2478:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2480))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2478 << endl;
        exit(-1);
    }
    addrRel += 2480;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2479:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2479 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2480:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2481:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2481 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2482:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2483:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2484:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2484 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2485:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2485 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2486:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2487:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2488:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2488 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2489:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2489 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2490:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2490 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2491:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2492:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2492 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2493:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2494:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2495:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2495 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2496:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2497:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2498:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2499:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2499 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2500:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2500 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2501:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2502:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2502 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2503:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2503 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2504:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2504 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2505:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2505 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2506:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2507:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2507 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2508:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2508 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2509:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2509 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2510:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2511:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2511 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2512:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2512 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2513:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2513 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2514:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2514 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2515:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2516:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2517:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2517 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2518:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = fr.add(op0, PC);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2519:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2519 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2520:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2520 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2521:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2521 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2522:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(9))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2522 << endl;
        exit(-1);
    }
    addrRel += 9;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2523:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2523 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2524:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2524 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2525:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2526;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1458))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2525 << endl;
        exit(-1);
    }
    addrRel += 1458;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2526:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2526 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2527:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(44))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2527 << endl;
        exit(-1);
    }
    addrRel += 44;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2528:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = fr.add(op0, SP);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2529:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2538))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2529 << endl;
        exit(-1);
    }
    addrRel += 2538;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2530:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2531:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2531 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2532:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2533:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2534:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2534 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2535:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = fr.add(op0, PC);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2536:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2536 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2537:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2537 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2538:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-1
    op0 = fr.neg(C0);
    op1 = fr.neg(C1);
    op2 = fr.neg(C2);
    op3 = fr.neg(C3);
    op4 = fr.neg(C4);
    op5 = fr.neg(C5);
    op6 = fr.neg(C6);
    op7 = fr.neg(C7);

    // op0 = op0 + CONST
    op0 = fr.add(op0, 32);

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2539:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2540:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2541:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2542:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2543:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = fr.add(op0, PC);

    addrRel = 0;
    addr = 0;
    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2544:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2545:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2546:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2547:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2548;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1483))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2547 << endl;
        exit(-1);
    }
    addrRel += 1483;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2548:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(10))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2548 << endl;
        exit(-1);
    }
    addrRel += 10;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2549:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op = op + inB*B, where inB=1
    op0 = fr.add(op0, B0);
    op1 = fr.add(op1, B1);
    op2 = fr.add(op2, B2);
    op3 = fr.add(op3, B3);
    op4 = fr.add(op4, B4);
    op5 = fr.add(op5, B5);
    op6 = fr.add(op6, B6);
    op7 = fr.add(op7, B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2550:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2550 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2551:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2551 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2552:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2552 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2553:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2554:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2554 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2555:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2555 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2556:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2556 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2557:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2558:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2558 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2559:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2559 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2560:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2560 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2561:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2562:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2562 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2563:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2563 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2564:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2564 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2565:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 4;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2566:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2566 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2567:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2567 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2568:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2568 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2569:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 5;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2570:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2570 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2571:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2571 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2572:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2572 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2573:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 6;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2574:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2574 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2575:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2575 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2576:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2576 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2577:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 7;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2578:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2578 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2579:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2579 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2580:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2580 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2581:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 8;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2582:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2582 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2583:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2583 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2584:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2584 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2585:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 9;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2586:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2586 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2587:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2587 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2588:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2588 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2589:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 10;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2590:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2590 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2591:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2591 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2592:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2592 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2593:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 11;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2594:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2594 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2595:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2595 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2596:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2596 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2597:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 12;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2598:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2598 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2599:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2599 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2600:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2600 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2601:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 13;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2602:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2602 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2603:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2603 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2604:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2604 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2605:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 14;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2606:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2606 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2607:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2607 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2608:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2608 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2609:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 15;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2610:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2610 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2611:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2611 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2612:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2612 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2613:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 16;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2614:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2614 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2615:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2615 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2616:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2616 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2617:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 17;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2618:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2618 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2619:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2619 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2620:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2620 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2621:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 18;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2622:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2622 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2623:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2623 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2624:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2624 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2625:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 19;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2626:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2626 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2627:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2627 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2628:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2628 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2629:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 20;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2630:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2630 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2631:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2631 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2632:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2632 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2633:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 21;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2634:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2634 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2635:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2635 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2636:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2636 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2637:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 22;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2638:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2638 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2639:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2639 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2640:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2640 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2641:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 23;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2642:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2642 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2643:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2643 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2644:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2644 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2645:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 24;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2646:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2646 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2647:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2647 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2648:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2648 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2649:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 25;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2650:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2650 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2651:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2651 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2652:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2652 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2653:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 26;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2654:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2654 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2655:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2655 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2656:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2656 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2657:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 27;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2658:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2658 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2659:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2659 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2660:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2660 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2661:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 28;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2662:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2662 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2663:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2663 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2664:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2664 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2665:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 29;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2666:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2666 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2667:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2667 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2668:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2668 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2669:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 30;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2670:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2670 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2671:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2671 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2672:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2672 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2673:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 31;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2674:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2674 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2675:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2675 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2676:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2676 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2677:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 32;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2678:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2678 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2679:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2521))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2679 << endl;
        exit(-1);
    }
    addrRel += 2521;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2680:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2515))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2680 << endl;
        exit(-1);
    }
    addrRel += 2515;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2681:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2681 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2682:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2683:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2683 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2684:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2685:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2685 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2686:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2686 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2687:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2687 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2688:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2688 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2689:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2690:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 2);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2691:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2692:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2692 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2693:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2693 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2694:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2694 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2695:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2695 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2696:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2697:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 3);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2698:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2699:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2699 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2700:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2700 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2701:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2701 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2702:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2702 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2703:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2704:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 4);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2705:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2706:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2706 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2707:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2707 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2708:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2708 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2709:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2709 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2710:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2711:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 5);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2712:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2713:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2713 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2714:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2714 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2715:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2715 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2716:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2716 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2717:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2718:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 6);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2719:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2720:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2720 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2721:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2721 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2722:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2722 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2723:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2723 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2724:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2725:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 7);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2726:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2727:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2727 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2728:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2728 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2729:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2729 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2730:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2730 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2731:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2732:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 8);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2733:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2734:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2734 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2735:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2735 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2736:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2736 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2737:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2737 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2738:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2739:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 9);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2740:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2741:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2741 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2742:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2742 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2743:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2743 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2744:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2744 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2745:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2746:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 10);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2747:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2748:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2748 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2749:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2749 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2750:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2750 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2751:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(11));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2751 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2752:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2753:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 11);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2754:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2755:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2755 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2756:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2756 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2757:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2757 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2758:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(12));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2758 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2759:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2760:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 12);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2761:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2762:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2762 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2763:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2763 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2764:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2764 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2765:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(13));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2765 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2766:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2767:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 13);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2768:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2769:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2769 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2770:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2770 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2771:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2771 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2772:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(14));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2772 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2773:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2774:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 14);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2775:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2776:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2776 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2777:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2777 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2778:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2778 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2779:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2779 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2780:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2781:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2782:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2783:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2783 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2784:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2784 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2785:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2785 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2786:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2786 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2787:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2788:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 16);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2789:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2790:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2790 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2791:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2791 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2792:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2792 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2793:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2793 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2794:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2795:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2796:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2797:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2798:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2798 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2799:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2800:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2800 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2801:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2801 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2802:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2802 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2803:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2803 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2804:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2805:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2806:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2807:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2808:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2809:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 2);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2810:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2811:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2811 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2812:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2812 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2813:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2813 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2814:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2814 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2815:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2816:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2817:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2818:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2819:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2820:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 3);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2821:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2822:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2822 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2823:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2823 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2824:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2824 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2825:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2825 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2826:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2827:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2828:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2829:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2830:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2831:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 4);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2832:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2833:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2833 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2834:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2834 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2835:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2835 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2836:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2836 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2837:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2838:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2839:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2840:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2841:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2842:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 5);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2843:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2844:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2844 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2845:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2845 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2846:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2846 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2847:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2847 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2848:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2849:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2850:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2851:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2852:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2853:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 6);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2854:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2855:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2855 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2856:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2856 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2857:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2857 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2858:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2858 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2859:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2860:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2861:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2862:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2863:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2864:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 7);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2865:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2866:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2866 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2867:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2867 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2868:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2868 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2869:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2869 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2870:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2871:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2872:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(8));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2873:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2874:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2875:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 8);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2876:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2877:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2877 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2878:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2878 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2879:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2879 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2880:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2880 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2881:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2882:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2883:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2884:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2885:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2886:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 9);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2887:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2888:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2888 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2889:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2889 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2890:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2890 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2891:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(11));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2891 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2892:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2893:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2894:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(10));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2895:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2896:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2897:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 10);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2898:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2899:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2899 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2900:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2900 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2901:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2901 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2902:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(12));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2902 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2903:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2904:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2905:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(11));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2906:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2907:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2908:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 11);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2909:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2910:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2910 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2911:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2911 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2912:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2912 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2913:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(13));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2913 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2914:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2915:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2916:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(12));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2917:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2918:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2919:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 12);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2920:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2921:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2921 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2922:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2922 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2923:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2923 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2924:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(14));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2924 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2925:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2926:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2927:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(13));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2928:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2929:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2930:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 13);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2931:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2932:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2932 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2933:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2933 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2934:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2934 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2935:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2935 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2936:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2937:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2938:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(14));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2939:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2940:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2941:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 14);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2942:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2943:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2943 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2944:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2944 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2945:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2945 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2946:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2946 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2947:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2948:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2949:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(15));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2950:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2951:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2952:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 15);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2953:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2954:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2954 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2955:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2955 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2956:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2956 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2957:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(17));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2957 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2958:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2959:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2960:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(16));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2961:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2962:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2963:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 16);

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2964:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2965:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2965 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2966:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2966 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2967:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2967 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2968:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2968 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2969:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2969 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2970:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2970 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2971:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2972:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2973:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2974:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2974 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2975:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2975 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2976:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2976 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2977:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2977 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2978:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2978 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2979:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2979 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2980:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3033))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2980 << endl;
        exit(-1);
    }
    addrRel += 3033;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2981:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2981 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2982:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2982 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2983:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2983 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2984:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2985:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2986:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2987:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2987 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2988:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2988 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2989:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2989 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2990:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2990 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine2991:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2991 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2992:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2992 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2993:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3033))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2993 << endl;
        exit(-1);
    }
    addrRel += 3033;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2994:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2994 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2995:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2995 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2996:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 2996 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2997:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2998:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine2999:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3000:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3000 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3001:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3001 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3002:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3002 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3003:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3003 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3004:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3004 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3005:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3005 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3006:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3033))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3006 << endl;
        exit(-1);
    }
    addrRel += 3033;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3007:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3007 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3008:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3008 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3009:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3009 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3010:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3011:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3012:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3013:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3013 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3014:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3014 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3015:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3015 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3016:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3016 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3017:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3017 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3018:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3018 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3019:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3033))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3019 << endl;
        exit(-1);
    }
    addrRel += 3033;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3020:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3020 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3021:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3021 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3022:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3022 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3023:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3024:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3025:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3026:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3026 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3027:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 4;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3027 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3028:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3028 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3029:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-8
    op0 = fr.mul(-8, C0);
    op1 = fr.mul(-8, C1);
    op2 = fr.mul(-8, C2);
    op3 = fr.mul(-8, C3);
    op4 = fr.mul(-8, C4);
    op5 = fr.mul(-8, C5);
    op6 = fr.mul(-8, C6);
    op7 = fr.mul(-8, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3029 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3030:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3030 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3031:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3031 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3032:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3033))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3032 << endl;
        exit(-1);
    }
    addrRel += 3033;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3033:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3041))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3033 << endl;
        exit(-1);
    }
    addrRel += 3041;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3034:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3039))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3034 << endl;
        exit(-1);
    }
    addrRel += 3039;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3035:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3036;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3035 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3036:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3037:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3038:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3033))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3038 << endl;
        exit(-1);
    }
    addrRel += 3033;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3039:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3040;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3039 << endl;
        exit(-1);
    }
    addrRel += 1340;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3040:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3041:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(32))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3041 << endl;
        exit(-1);
    }
    addrRel += 32;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3042:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3049))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3042 << endl;
        exit(-1);
    }
    addrRel += 3049;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3043:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3043 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3044:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(375));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3044 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3045:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3046:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3047:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3048:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3042))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3048 << endl;
        exit(-1);
    }
    addrRel += 3042;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3049:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3049 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3050:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3050 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3051:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3051 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3052:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3052 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3053:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(3));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3053 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3054:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3054 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3055:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3055 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3056:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3057:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3058:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3058 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3059:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3060:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3060 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3061:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3062:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3062 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3063:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3063 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3064:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3064 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3065:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3065 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3066:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3066 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3067:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3067 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3068:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3068 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3069:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3069 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3070:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3070 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3071:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3071 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3072:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3072 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3073:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3073 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3074:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3074 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3075:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3075 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3076:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3077:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3078;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1406))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3077 << endl;
        exit(-1);
    }
    addrRel += 1406;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3078:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3078 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3079:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3079 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3080:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3080 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3081:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3082:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3082 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3083:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3083 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3084:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3085;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1145))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3084 << endl;
        exit(-1);
    }
    addrRel += 1145;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3085:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3086:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3087:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3088:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3089:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3089 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3090:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3091:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3092:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3093:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3094:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3094 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3095:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3096;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1211))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3095 << endl;
        exit(-1);
    }
    addrRel += 1211;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3096:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3096 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3097:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3097 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3098:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3098 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3099:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3099 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3100:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3100 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3101:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3101 << endl;
        exit(-1);
    }
    addrRel += 925;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3102:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3102 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3103:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3104:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3104 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3105:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3106:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3106 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3107:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3108:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3108 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3109:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3110:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3110 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3111:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3111 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3112:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3114))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3112 << endl;
        exit(-1);
    }
    addrRel += 3114;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3113:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3113 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3114:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3115:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3115 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3116:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3117:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3117 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3118:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3119:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3120:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3120 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3121:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3122:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3122 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3123:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3124:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3125:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3127))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3125 << endl;
        exit(-1);
    }
    addrRel += 3127;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3126:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3127:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3128:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3128 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3129:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3131))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3129 << endl;
        exit(-1);
    }
    addrRel += 3131;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3130:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3131;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1419))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3130 << endl;
        exit(-1);
    }
    addrRel += 1419;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3131:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3131 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3132:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3132 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3133:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3133 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3134:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3134 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3135:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3135 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3136:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3136 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3137:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3137 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3138:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3138 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3139:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3139 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3140:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3140 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3141:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3141 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3142:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3142 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3143:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3144:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3144 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3145:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3145 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3146:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3146 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3147:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3148:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3148 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3149:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3149 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3150:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3150 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3151:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3152:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3154))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3152 << endl;
        exit(-1);
    }
    addrRel += 3154;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3153:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3153 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3154:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3155;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1406))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3154 << endl;
        exit(-1);
    }
    addrRel += 1406;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3155:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3155 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3156:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3156 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3157:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3157 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3158:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3159:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3159 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3160:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3160 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3161:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3161 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3162:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3162 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3163:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3164;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1145))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3163 << endl;
        exit(-1);
    }
    addrRel += 1145;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3164:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3164 << endl;
        exit(-1);
    }
    addrRel += 925;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3165:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3165 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3166:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3167:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3167 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3168:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3169:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3169 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3170:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3171:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3171 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3172:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3173:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3173 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3174:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3175:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3175 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3176:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3177:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3177 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3178:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3179:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3180:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3180 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3181:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3182:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3182 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3183:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3184:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3185:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3187))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3185 << endl;
        exit(-1);
    }
    addrRel += 3187;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3186:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3187:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3188:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3188 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3189:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3191))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3189 << endl;
        exit(-1);
    }
    addrRel += 3191;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3190:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3191;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1419))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3190 << endl;
        exit(-1);
    }
    addrRel += 1419;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3191:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3191 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3192:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3192 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3193:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3193 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3194:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3194 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3195:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3195 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3196:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3196 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3197:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3197 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3198:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3198 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3199:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3199 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3200:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3200 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3201:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3201 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3202:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3202 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3203:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3203 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3204:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3204 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3205:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3205 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3206:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3207:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3207 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3208:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3208 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3209:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3210:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3210 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3211:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3211 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3212:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3212 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3213:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3215))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3213 << endl;
        exit(-1);
    }
    addrRel += 3215;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3214:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(9000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3214 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3215:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3216;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1406))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3215 << endl;
        exit(-1);
    }
    addrRel += 1406;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3216:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3216 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3217:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3217 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3218:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3218 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3219:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3220:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3220 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3221:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3221 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3222:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3222 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3223:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3223 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3224:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3225;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1145))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3224 << endl;
        exit(-1);
    }
    addrRel += 1145;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3225:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3225 << endl;
        exit(-1);
    }
    addrRel += 925;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3226:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3226 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3227:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3228:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3229:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3230:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3230 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3231:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3231 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3232:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-1
    op0 = fr.neg(D0);
    op1 = fr.neg(D1);
    op2 = fr.neg(D2);
    op3 = fr.neg(D3);
    op4 = fr.neg(D4);
    op5 = fr.neg(D5);
    op6 = fr.neg(D6);
    op7 = fr.neg(D7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3275))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3232 << endl;
        exit(-1);
    }
    addrRel += 3275;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3233:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3233 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3234:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3271))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3234 << endl;
        exit(-1);
    }
    addrRel += 3271;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3235:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3235 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3236:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3236 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3237:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3237 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3238:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3238 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3239:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3239 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3240:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3240 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3241:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3241 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3242:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3242 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3243:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3243 << endl;
        exit(-1);
    }
    addrRel += 3262;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3244:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3256))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3244 << endl;
        exit(-1);
    }
    addrRel += 3256;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3245:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3246;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1308))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3245 << endl;
        exit(-1);
    }
    addrRel += 1308;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3246:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3247:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3247 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3248:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3249:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3249 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3250:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3251;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1227))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3250 << endl;
        exit(-1);
    }
    addrRel += 1227;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3251:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3252:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3253:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32));

    addrRel = 0;
    addr = 0;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3254:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3254 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3255:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3243))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3255 << endl;
        exit(-1);
    }
    addrRel += 3243;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3256:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3257;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1340))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3256 << endl;
        exit(-1);
    }
    addrRel += 1340;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3257:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3257 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3258:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3259:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(46))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3259 << endl;
        exit(-1);
    }
    addrRel += 46;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3260:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3261;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1262))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3260 << endl;
        exit(-1);
    }
    addrRel += 1262;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3261:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3261 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3262:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3262 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3263:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3263 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3264:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3264 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3265:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3266:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3266 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3267:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3267 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3268:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3268 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3269:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3269 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3270:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3270 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3271:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3271 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3272:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3272 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3273:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op = op + inE*E, where inE=-1
    op0 = fr.add(op0, fr.neg(E0));
    op1 = fr.add(op1, fr.neg(E1));
    op2 = fr.add(op2, fr.neg(E2));
    op3 = fr.add(op3, fr.neg(E3));
    op4 = fr.add(op4, fr.neg(E4));
    op5 = fr.add(op5, fr.neg(E5));
    op6 = fr.add(op6, fr.neg(E6));
    op7 = fr.add(op7, fr.neg(E7));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2373))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3273 << endl;
        exit(-1);
    }
    addrRel += 2373;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3274:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1056))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3274 << endl;
        exit(-1);
    }
    addrRel += 1056;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3275:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=-200
    op0 = fr.mul(-200, C0);
    op1 = fr.mul(-200, C1);
    op2 = fr.mul(-200, C2);
    op3 = fr.mul(-200, C3);
    op4 = fr.mul(-200, C4);
    op5 = fr.mul(-200, C5);
    op6 = fr.mul(-200, C6);
    op7 = fr.mul(-200, C7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3275 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3276:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3276 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3277:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3279))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3277 << endl;
        exit(-1);
    }
    addrRel += 3279;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3278:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1056))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3278 << endl;
        exit(-1);
    }
    addrRel += 1056;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3279:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3279 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3280:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3280 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3281:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3281 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3282:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3282 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3283:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3283 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3284:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3284 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3285:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3285 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3286:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3286 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3287:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3287 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3288:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3288 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3289:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3289 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3290:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3291:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3292:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3293:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3294:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3295:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3296:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3297:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3298:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3298 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3299:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3300:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3321))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3300 << endl;
        exit(-1);
    }
    addrRel += 3321;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3301:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3301 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3302:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3303:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3304:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3304 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3305:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1135))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3305 << endl;
        exit(-1);
    }
    addrRel += 1135;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    if (carry)
    {
        goto *main_exec_generated_fast_labels[addr]; // If carry, jump to addr: zkPC'=addr
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3306:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3307:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3307 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3308:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3309:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3310:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3310 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3311:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3312:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3313:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3313 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3314:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3314 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3315:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3315 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3316:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3317;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1429))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3316 << endl;
        exit(-1);
    }
    addrRel += 1429;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3317:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3317 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3318:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3318 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3319:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3320:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3321:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(13))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3321 << endl;
        exit(-1);
    }
    addrRel += 13;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3322:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3322 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3323:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3324:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3324 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3325:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3325 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3326:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3327:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3327 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3328:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3328 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3329:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3329 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3330:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3331:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3331 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3332:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3333:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3333 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3334:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3335:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3335 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3336:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3337:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3337 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3338:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3339:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3339 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3340:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3341:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3342:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3342 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3343:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3344:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3344 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3345:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3346:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3347:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3349))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3347 << endl;
        exit(-1);
    }
    addrRel += 3349;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3348:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3349:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3350:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3350 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3351:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3353))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3351 << endl;
        exit(-1);
    }
    addrRel += 3353;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3352:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3353;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1419))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3352 << endl;
        exit(-1);
    }
    addrRel += 1419;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3353:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3353 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3354:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3354 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3355:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3355 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3356:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3356 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3357:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3357 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3358:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3358 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3359:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3359 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3360:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3360 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3361:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3361 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3362:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3362 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3363:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3363 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3364:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3364 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3365:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3365 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3366:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3366 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3367:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3367 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3368:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3369:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3369 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3370:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3370 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3371:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3371 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3372:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3373:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3373 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3374:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3375;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1406))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3374 << endl;
        exit(-1);
    }
    addrRel += 1406;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3375:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3375 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3376:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3376 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3377:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3377 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3378:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3379:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3379 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3380:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3380 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3381:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3381 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3382:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3382 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3383:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3384;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1145))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3383 << endl;
        exit(-1);
    }
    addrRel += 1145;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3384:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3384 << endl;
        exit(-1);
    }
    addrRel += 925;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3385:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(4));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3385 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3386:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3386 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3387:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3387 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3388:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3389:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3390:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3390 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3391:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3392:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3392 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3393:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3394:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3394 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3395:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3396:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3396 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3397:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3397 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3398:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(32000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3398 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3399:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3399 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;
    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3400:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3400 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3401:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3401 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3402:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3402 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3403:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3403 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3404:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3404 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3405:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(12))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3405 << endl;
        exit(-1);
    }
    addrRel += 12;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3406:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(34))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3406 << endl;
        exit(-1);
    }
    addrRel += 34;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3407:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(35))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3407 << endl;
        exit(-1);
    }
    addrRel += 35;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3408:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(36))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3408 << endl;
        exit(-1);
    }
    addrRel += 36;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3409:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3409 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3410:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3410 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3411:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3412:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3413;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1406))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3412 << endl;
        exit(-1);
    }
    addrRel += 1406;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3413:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3413 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3414:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3414 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3415:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3415 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3416:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3417:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3417 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3418:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3418 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3419:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3420;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1145))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3419 << endl;
        exit(-1);
    }
    addrRel += 1145;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3420:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3421:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3422:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3423:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3424:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(4))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3424 << endl;
        exit(-1);
    }
    addrRel += 4;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3425:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3426:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3427:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3428:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3429:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3429 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3430:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3431;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1211))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3430 << endl;
        exit(-1);
    }
    addrRel += 1211;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3431:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(5))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3431 << endl;
        exit(-1);
    }
    addrRel += 5;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3432:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3432 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3433:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3433 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3434:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3434 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3435:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3435 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3436:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3436 << endl;
        exit(-1);
    }
    addrRel += 925;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3437:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(6));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3437 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3438:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3439:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3439 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3440:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3441:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(25))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3441 << endl;
        exit(-1);
    }
    addrRel += 25;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3442:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3443:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3443 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3444:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3445:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3445 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3446:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3447:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3447 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3448:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3449:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3450:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3450 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3451:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3452:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(27))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3452 << endl;
        exit(-1);
    }
    addrRel += 27;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3453:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3454:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3455:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3457))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3455 << endl;
        exit(-1);
    }
    addrRel += 3457;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3456:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3457:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3458:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3458 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3459:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=-1
    op0 = fr.neg(B0);
    op1 = fr.neg(B1);
    op2 = fr.neg(B2);
    op3 = fr.neg(B3);
    op4 = fr.neg(B4);
    op5 = fr.neg(B5);
    op6 = fr.neg(B6);
    op7 = fr.neg(B7);

    // op = op + inE*E, where inE=1
    op0 = fr.add(op0, E0);
    op1 = fr.add(op1, E1);
    op2 = fr.add(op2, E2);
    op3 = fr.add(op3, E3);
    op4 = fr.add(op4, E4);
    op5 = fr.add(op5, E5);
    op6 = fr.add(op6, E6);
    op7 = fr.add(op7, E7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3461))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3459 << endl;
        exit(-1);
    }
    addrRel += 3461;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3460:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3461;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1419))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3460 << endl;
        exit(-1);
    }
    addrRel += 1419;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3461:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3461 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3462:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3462 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3463:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inSR*SR, where inSR=1
    op0 = SR0;
    op1 = SR1;
    op2 = SR2;
    op3 = SR3;
    op4 = SR4;
    op5 = SR5;
    op6 = SR6;
    op7 = SR7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3463 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3464:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3464 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3465:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inPC*PC, where inPC=1
    op0 = PC;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3465 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3466:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3466 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3467:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3467 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3468:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inCTX*CTX, where inCTX=1
    op0 = CTX;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3468 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3469:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(24))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3469 << endl;
        exit(-1);
    }
    addrRel += 24;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3470:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3470 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3471:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3471 << endl;
        exit(-1);
    }
    addrRel += 3;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3472:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3472 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3473:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(14))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3473 << endl;
        exit(-1);
    }
    addrRel += 14;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3474:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(15))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3474 << endl;
        exit(-1);
    }
    addrRel += 15;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3475:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3476:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(26))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3476 << endl;
        exit(-1);
    }
    addrRel += 26;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3477:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3477 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3478:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(2))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3478 << endl;
        exit(-1);
    }
    addrRel += 2;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3479:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3480:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=-2500
    op0 = fr.mul(-2500, D0);
    op1 = fr.mul(-2500, D1);
    op2 = fr.mul(-2500, D2);
    op3 = fr.mul(-2500, D3);
    op4 = fr.mul(-2500, D4);
    op5 = fr.mul(-2500, D5);
    op6 = fr.mul(-2500, D6);
    op7 = fr.mul(-2500, D7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(100));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3480 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3481:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3482;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1406))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3481 << endl;
        exit(-1);
    }
    addrRel += 1406;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3482:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3482 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3483:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3483 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3484:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(23))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3484 << endl;
        exit(-1);
    }
    addrRel += 23;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3485:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3486:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3486 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3487:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(7))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3487 << endl;
        exit(-1);
    }
    addrRel += 7;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3488:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3488 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3489:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(28))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3489 << endl;
        exit(-1);
    }
    addrRel += 28;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3490:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3491;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1145))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3490 << endl;
        exit(-1);
    }
    addrRel += 1145;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3491:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(925))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3491 << endl;
        exit(-1);
    }
    addrRel += 925;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3492:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(2));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3492 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3493:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(20))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3493 << endl;
        exit(-1);
    }
    addrRel += 20;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3494:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3495:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;

   SP = SP + -1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3496:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3497:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3497 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3498:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3507))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3498 << endl;
        exit(-1);
    }
    addrRel += 3507;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3499:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3500:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3500 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3501:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inC*C, where inC=1
    op0 = C0;
    op1 = C1;
    op2 = C2;
    op3 = C3;
    op4 = C4;
    op5 = C5;
    op6 = C6;
    op7 = C7;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3501 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3502:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3502 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3503:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3503 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3504:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3505:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3505 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3506:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3506 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3507:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1056))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3507 << endl;
        exit(-1);
    }
    addrRel += 1056;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3508:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(33))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3508 << endl;
        exit(-1);
    }
    addrRel += 33;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3509:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=-1
    op0 = fr.neg(A0);
    op1 = fr.neg(A1);
    op2 = fr.neg(A2);
    op3 = fr.neg(A3);
    op4 = fr.neg(A4);
    op5 = fr.neg(A5);
    op6 = fr.neg(A6);
    op7 = fr.neg(A7);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3546))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3509 << endl;
        exit(-1);
    }
    addrRel += 3546;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3510:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 24000;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(19))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3510 << endl;
        exit(-1);
    }
    addrRel += 19;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3511:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = GAS;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(5000));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3511 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3512:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3512 << endl;
        exit(-1);
    }
    addrRel += 1;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3513:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 2;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3514:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3515:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3516:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3517:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3518:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3519:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3520:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3521:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=1
    op0 = SP;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3521 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    SP = fe2n(fr, op0); // If setSP, SP'=op
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3522:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3523:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;
    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3524:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3525;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1376))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3524 << endl;
        exit(-1);
    }
    addrRel += 1376;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3525:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=-25000
    op0 = fr.mul(-25000, E0);
    op1 = fr.mul(-25000, E1);
    op2 = fr.mul(-25000, E2);
    op3 = fr.mul(-25000, E3);
    op4 = fr.mul(-25000, E4);
    op5 = fr.mul(-25000, E5);
    op6 = fr.mul(-25000, E6);
    op7 = fr.mul(-25000, E7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3525 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3526:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3527:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=-2600
    op0 = fr.mul(-2600, E0);
    op1 = fr.mul(-2600, E1);
    op2 = fr.mul(-2600, E2);
    op3 = fr.mul(-2600, E3);
    op4 = fr.mul(-2600, E4);
    op5 = fr.mul(-2600, E5);
    op6 = fr.mul(-2600, E6);
    op7 = fr.mul(-2600, E7);

    // op0 = op0 + inGAS*GAS, where inGAS=1
    op0 = fr.add(op0, GAS);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1570))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3527 << endl;
        exit(-1);
    }
    addrRel += 1570;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3528:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3529:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // E' = op
    E0 = op0;
    E1 = op1;
    E2 = op2;
    E3 = op3;
    E4 = op4;
    E5 = op5;
    E6 = op6;
    E7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3530:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inD*D, where inD=1
    op0 = D0;
    op1 = D1;
    op2 = D2;
    op3 = D3;
    op4 = D4;
    op5 = D5;
    op6 = D6;
    op7 = D7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(41))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3530 << endl;
        exit(-1);
    }
    addrRel += 41;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3531:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inE*E, where inE=1
    op0 = E0;
    op1 = E1;
    op2 = E2;
    op3 = E3;
    op4 = E4;
    op5 = E5;
    op6 = E6;
    op7 = E7;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(42))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3531 << endl;
        exit(-1);
    }
    addrRel += 42;
    addr = addrRel;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3532:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 3533;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1429))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3532 << endl;
        exit(-1);
    }
    addrRel += 1429;
    addr = addrRel;
    RR = fe2n(fr, op0); // If setRR, RR'=op0
    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3533:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(43))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3533 << endl;
        exit(-1);
    }
    addrRel += 43;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // D' = op
    D0 = op0;
    D1 = op1;
    D2 = op2;
    D3 = op3;
    D4 = op4;
    D5 = op5;
    D6 = op6;
    D7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3534:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3535:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;

    // C' = op
    C0 = op0;
    C1 = op1;
    C2 = op2;
    C3 = op3;
    C4 = op4;
    C5 = op5;
    C6 = op6;
    C7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3536:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // SR' = op
    SR0 = op0;
    SR1 = op1;
    SR2 = op2;
    SR3 = op3;
    SR4 = op4;
    SR5 = op5;
    SR6 = op6;
    SR7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3537:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1056))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3537 << endl;
        exit(-1);
    }
    addrRel += 1056;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3538:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3539:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3539 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // B' = op
    B0 = op0;
    B1 = op1;
    B2 = op2;
    B3 = op3;
    B4 = op4;
    B5 = op5;
    B6 = op6;
    B7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3540:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    // op0 = op0 + CONST
    op0 = fr.add(op0, fr.neg(1));

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(3545))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3540 << endl;
        exit(-1);
    }
    addrRel += 3545;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3541:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inB*B, where inB=1
    op0 = B0;
    op1 = B1;
    op2 = B2;
    op3 = B3;
    op4 = B4;
    op5 = B5;
    op6 = B6;
    op7 = B7;

    addrRel = 0;
    addr = 0;
    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3542:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3542 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3543:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3543 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3544:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3544 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3545:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1056))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3545 << endl;
        exit(-1);
    }
    addrRel += 1056;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3546:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(29))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3546 << endl;
        exit(-1);
    }
    addrRel += 29;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    CTX = fe2n(fr, op0); // If setCTX, CTX'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3547:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(37))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3547 << endl;
        exit(-1);
    }
    addrRel += 37;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    // A' = op
    A0 = op0;
    A1 = op1;
    A2 = op2;
    A3 = op3;
    A4 = op4;
    A5 = op5;
    A6 = op6;
    A7 = op7;


    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3548:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op = op + inA*A, where inA=1
    op0 = A0;
    op1 = A1;
    op2 = A2;
    op3 = A3;
    op4 = A4;
    op5 = A5;
    op6 = A6;
    op7 = A7;

    addrRel = 0;
    addr = 0;

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
    GAS = fe2n(fr, op0); // If setGAS, GAS'=op
RomLine3549:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(30))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3549 << endl;
        exit(-1);
    }
    addrRel += 30;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    SP = fe2n(fr, op0); // If setSP, SP'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3550:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(31))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3550 << endl;
        exit(-1);
    }
    addrRel += 31;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    PC = fe2n(fr, op0); // If setPC, PC'=op

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3551:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + CONST
    op0 = 1;
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    addr = addrRel;
    // If isStack, addr = addr + STACK_OFFSET
    addr += STACK_OFFSET;
   SP = SP + 1; // SP' = SP + incStack

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3552:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    // op0 = op0 + inSP*SP, where inSP=-1
    op0 = fr.neg(SP);
    op1 = fr.zero();
    op2 = fr.zero();
    op3 = fr.zero();
    op4 = fr.zero();
    op5 = fr.zero();
    op6 = fr.zero();
    op7 = fr.zero();

    // op0 = op0 + CONST
    op0 = fr.add(op0, 1024);

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1582))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3552 << endl;
        exit(-1);
    }
    addrRel += 1582;
    addr = addrRel;
    o = fe2n(fr, op0);
    if (o < 0) {
        goto *main_exec_generated_fast_labels[addr]; // If op<0, jump to addr: zkPC'=addr
    }
    else
    {
    }

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
RomLine3553:

    i++;
    if (i==N) return;
    if (i%100000==0) cout<<"Evaluation=" << i << endl;

    addrRel = 0;
    addr = 0;
    // If address is involved, load offset into addr
    // If offset is possitive, and the sum is too big, fail
    if ((uint64_t(addrRel)+uint64_t(1053))>=0x10000)
    {
        cerr << "Error: addrRel >= 0x10000 ln: " << 3553 << endl;
        exit(-1);
    }
    addrRel += 1053;
    addr = addrRel;
    op7 = op6 = op5 = op4 = op3 = op2 = op1 = op0 = fr.zero(); // Initialize op to zero

    goto *main_exec_generated_fast_labels[addr]; // If JMP, directly jump zkPC'=addr

    maxMemCalculated = 0;
    mm = MAXMEM;
    maxMemCalculated = mm;
}
